<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Story</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        .canvas { width: 1024px; height: 576px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .elem { position: absolute; }
        .elem img, .elem video { width: 100%; height: 100%; object-fit: cover; }
        .elem video { pointer-events: none; }
        .elem video::-webkit-media-controls { display: none !important; }
        .elem video::-webkit-media-controls-enclosure { display: none !important; }
        .elem-text { padding: 15px; border-radius: 6px; text-align: center; }
        .elem-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .elem-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .elem-draggable { cursor: grab; display: flex; align-items: center; justify-content: center; user-select: none; }
        .elem-draggable:active { cursor: grabbing; }
        .elem-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .elem-hotspot-visible { border: 3px dashed rgba(255,0,0,0.5); background: rgba(255,0,0,0.05); }
        .inventory-display { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; display: flex; gap: 10px; }
        .trans-fade { animation: fadeIn 0.5s ease-in forwards; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out forwards; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out forwards; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out forwards; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out forwards; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out forwards; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
    </style>
</head>
<body>
    <div id="game" class="canvas"></div>
    <div id="inventory" class="inventory-display" style="display:none"></div>
    <script>
const STEPS = [{"id":"Step_1","title":"Step 1","elements":[{"id":"video_1768057987208","type":"video","label":"video1","x":148.8215158924206,"y":126.43520782396088,"width":711.1882640586798,"height":358.2493887530562,"content":"http://satmis.hirakatajin.com/ykktux1.mp4","visible":true,"layer":0,"duration":0,"loop":false,"autoplay":true,"shape":"rect","color":"#f7931a","countdown":10,"fontSize":24,"contentType":"text","hotspotMode":"both","transition":"none","transitionDuration":0.5,"textColor":"#ffffff","textBgColor":"rgba(0,0,0,0.8)","textSize":24},{"id":"button_1768058054408","type":"button","label":"button1","x":544.4009779951099,"y":210.1613691931541,"width":300,"height":60,"content":"","visible":true,"layer":0,"duration":0,"loop":false,"autoplay":false,"shape":"rect","color":"#f7931a","countdown":10,"fontSize":24,"contentType":"text","hotspotMode":"both","transition":"none","transitionDuration":0.5,"textColor":"#ffffff","textBgColor":"rgba(0,0,0,0.8)","textSize":24}],"events":[{"id":"event_1768058104791","trigger":{"type":"onClick","delay":0,"sourceElement":"button_1768058054408"},"condition":null,"actions":[{"id":"action_1768058109674","type":"goto","target":"","value":"","targets":["Step_2"]}]}],"password":"","wrongPasswordStep":"","bgColor":"#000000","bgShapes":[]},{"id":"Step_2","title":"Step 2","elements":[{"id":"video_1768057978807","type":"video","label":"video1","x":100,"y":100,"width":400,"height":300,"content":"","visible":true,"layer":0,"duration":0,"loop":false,"autoplay":true,"shape":"rect","color":"#f7931a","countdown":10,"fontSize":24,"contentType":"text","hotspotMode":"both","transition":"none","transitionDuration":0.5,"textColor":"#ffffff","textBgColor":"rgba(0,0,0,0.8)","textSize":24},{"id":"video_1768058000458","type":"video","label":"video2","x":100,"y":100,"width":729.9657701711492,"height":430.85574572127143,"content":"http://satmis.hirakatajin.com/intro.mp4","visible":true,"layer":0,"duration":0,"loop":false,"autoplay":true,"shape":"rect","color":"#f7931a","countdown":10,"fontSize":24,"contentType":"text","hotspotMode":"both","transition":"none","transitionDuration":0.5,"textColor":"#ffffff","textBgColor":"rgba(0,0,0,0.8)","textSize":24},{"id":"button_1768058058991","type":"button","label":"button1","x":460.52811735941293,"y":395.43276283618553,"width":300,"height":60,"content":"","visible":true,"layer":0,"duration":0,"loop":false,"autoplay":false,"shape":"rect","color":"#f7931a","countdown":10,"fontSize":24,"contentType":"text","hotspotMode":"both","transition":"none","transitionDuration":0.5,"textColor":"#ffffff","textBgColor":"rgba(0,0,0,0.8)","textSize":24}],"events":[{"id":"event_1768058083690","trigger":{"type":"onClick","delay":0,"sourceElement":"button_1768058058991"},"condition":null,"actions":[{"id":"action_1768058094758","type":"goto","target":"","value":"","targets":["Step_1"]}]}],"password":"","wrongPasswordStep":"","bgColor":"#000000","bgShapes":[]}];
const INVENTORY_ITEMS = [];
let current = STEPS[0].id;
let visible = {};
let inventory = [];
let timers = [];
let timerCountdowns = {};
let hiding = {};
let rendered = {};
let draggedElem = null;
let dragOffset = { x: 0, y: 0 };
let dragPos = { x: 0, y: 0 };

function render() {
    timers.forEach(t => clearTimeout(t));
    timers = [];
    timerCountdowns = {};
    hiding = {};
    rendered = {};
    draggedElem = null;
    
    const s = STEPS.find(x => x.id === current);
    if (!s) return;
    
    if (s.password) {
        const pwd = prompt("Password:");
        if (pwd !== s.password) {
            if (s.wrongPasswordStep) { current = s.wrongPasswordStep; render(); return; }
            else { alert("Wrong!"); return; }
        }
    }
    
    visible = {};
    s.elements.forEach(e => {
        visible[e.id] = e.visible;
        if (e.visible && e.duration && e.duration > 0) {
            const t = setTimeout(() => hideElem(e.id), e.duration * 1000);
            timers.push(t);
        }
        if (e.type === "timer" && e.visible) startTimer(e.id, e.countdown);
    });
    
    s.events.forEach(ev => {
        if (checkCond(ev.condition)) {
            if (ev.trigger.type === "onLoad") exec(ev.actions);
            else if (ev.trigger.type === "afterDelay") {
                const t = setTimeout(() => exec(ev.actions), (ev.trigger.delay || 0) * 1000);
                timers.push(t);
            }
        }
    });
    
    fullDraw();
    
    setTimeout(() => {
        const vids = document.querySelectorAll("video");
        vids.forEach(v => {
            const elem = s.elements.find(e => e.content && v.src.includes(e.content));
            if (elem) {
                v.onended = () => {
                    s.events.forEach(ev => {
                        if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === elem.id && checkCond(ev.condition)) exec(ev.actions);
                    });
                };
            }
        });
    }, 100);
}

function startTimer(id, countdown) {
    let rem = countdown;
    timerCountdowns[id] = rem;
    const int = setInterval(() => {
        rem--;
        timerCountdowns[id] = rem;
        const timerDiv = document.querySelector('[data-elem-id="' + id + '"] .elem-timer');
        if (timerDiv) timerDiv.textContent = rem;
        if (rem <= 0) {
            clearInterval(int);
            const s = STEPS.find(x => x.id === current);
            s.events.forEach(ev => {
                if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    }, 1000);
    timers.push(int);
}

function hideElem(id) {
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    const elemDiv = document.querySelector('[data-elem-id="' + id + '"]');
    
    if (!elemDiv) {
        visible[id] = false;
        delete rendered[id];
        return;
    }
    
    const audio = elemDiv.querySelector('audio');
    const video = elemDiv.querySelector('video');
    if (audio) { audio.pause(); audio.currentTime = 0; }
    if (video) { video.pause(); video.currentTime = 0; }
    
    if (elem && elem.transition && elem.transition !== "none") {
        hiding[id] = true;
        elemDiv.className = elemDiv.className.replace(/\btrans-[\w-]+\b/g, '').trim() + ' trans-' + elem.transition + '-out';
        elemDiv.style.animationDuration = (elem.transitionDuration || 0.5) + 's';
        setTimeout(() => {
            visible[id] = false;
            hiding[id] = false;
            delete rendered[id];
            if (elemDiv.parentNode) elemDiv.remove();
        }, (elem.transitionDuration || 0.5) * 1000);
    } else {
        visible[id] = false;
        delete rendered[id];
        elemDiv.remove();
    }
}

function showElem(id) {
    if (visible[id] && rendered[id]) return;
    visible[id] = true;
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    if (elem) {
        if (elem.type === "timer") startTimer(id, elem.countdown);
        if (elem.duration && elem.duration > 0) {
            const t = setTimeout(() => hideElem(id), elem.duration * 1000);
            timers.push(t);
        }
        addElement(elem, true);
    }
}

function checkCond(c) {
    if (!c) return true;
    if (c.type === "hasItem") return inventory.includes(c.item);
    if (c.type === "notHasItem") return !inventory.includes(c.item);
    return true;
}

function exec(acts) {
    acts.forEach(a => {
        if (a.type === "show" || a.type === "showDelay") {
            const delay = (a.type === "showDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => showElem(t), delay); });
        } else if (a.type === "hide" || a.type === "hideDelay") {
            const delay = (a.type === "hideDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => hideElem(t), delay); });
        } else if (a.type === "goto") {
            if (a.targets && a.targets.length > 0) current = a.targets[Math.floor(Math.random() * a.targets.length)];
            else if (a.target) current = a.target;
            render();
            return;
        } else if (a.type === "addItem" && !inventory.includes(a.target)) inventory.push(a.target);
        else if (a.type === "removeItem") inventory = inventory.filter(x => x !== a.target);
    });
    updateInventory();
}

function createElemHTML(e, withTransition) {
    const isHiding = hiding[e.id];
    const transClass = withTransition && e.transition && e.transition !== "none" && !isHiding ? " trans-" + e.transition : (isHiding ? " trans-" + e.transition + "-out" : "");
    const transDur = e.transitionDuration || 0.5;
    const style = "left:" + e.x + "px;top:" + e.y + "px;width:" + e.width + "px;height:" + e.height + "px;z-index:" + e.layer + (e.shape === "circle" ? ";border-radius:50%" : "") + ";animation-duration:" + transDur + "s";
    const mousedown = e.type === "draggable" ? ' onmousedown="handleDragStart(event, \'' + e.id + '\')"' : "";
    const click = (e.type === "button" || (e.type === "hotspot" && e.hotspotMode !== "drop")) ? ' onclick="handleClick(\'' + e.id + '\')"' : "";
    const hotspotClass = (e.type === "hotspot" && e.showInGame) ? " elem-hotspot-visible" : "";
    
    let h = '<div class="elem' + (e.type === "draggable" ? " elem-draggable" : "") + hotspotClass + transClass + '" data-elem-id="' + e.id + '" style="' + style + '"' + mousedown + click + '>';
    if (e.type === "image" && e.content) h += '<img src="' + e.content + '">';
    if (e.type === "video" && e.content) h += '<video playsinline webkit-playsinline ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop' : '') + '><source src="' + e.content + '"></video>';
    if (e.type === "text") h += '<div class="elem-text" style="font-size:' + (e.textSize || 24) + 'px;color:' + (e.textColor || "#ffffff") + ';background:' + (e.textBgColor || "rgba(0,0,0,0.8)") + '">' + e.content + '</div>';
    if (e.type === "button") h += '<div class="elem-button" style="background:' + e.color + '">' + (e.content || "Button") + '</div>';
    if (e.type === "audio" && e.content) h += '<audio ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop' : '') + '><source src="' + e.content + '"></audio>';
    if (e.type === "timer") h += '<div class="elem-timer">' + (timerCountdowns[e.id] !== undefined ? timerCountdowns[e.id] : e.countdown) + '</div>';
    if (e.type === "draggable") {
        if (e.contentType === "image" && e.content) h += '<img src="' + e.content + '">';
        else h += '<div style="font-size:' + e.fontSize + 'px;color:#fff;pointer-events:none">' + (e.content || "ðŸ“¦") + '</div>';
    }
    h += '</div>';
    return h;
}

function addElement(e, withTransition) {
    if (!e || rendered[e.id]) return;
    const game = document.getElementById("game");
    const s = STEPS.find(x => x.id === current);
    const temp = document.createElement('div');
    temp.innerHTML = createElemHTML(e, withTransition);
    const newElem = temp.firstChild;
    
    const existingElems = Array.from(game.querySelectorAll('[data-elem-id]'));
    let inserted = false;
    for (const existing of existingElems) {
        const existingE = s.elements.find(el => el.id === existing.getAttribute('data-elem-id'));
        if (existingE && existingE.layer > e.layer) {
            game.insertBefore(newElem, existing);
            inserted = true;
            break;
        }
    }
    if (!inserted) game.appendChild(newElem);
    rendered[e.id] = true;
}

function fullDraw() {
    const s = STEPS.find(x => x.id === current);
    const game = document.getElementById("game");
    game.style.background = s.bgColor || "#000";
    let h = "";
    
    if (s.bgShapes) {
        s.bgShapes.forEach(sh => {
            h += '<div style="position:absolute;left:' + sh.x + 'px;top:' + sh.y + 'px;width:' + sh.width + 'px;height:' + sh.height + 'px;background:' + sh.color + ';border-radius:' + (sh.type === "circle" ? "50%" : "0") + ';z-index:0"></div>';
        });
    }
    
    s.elements.filter(e => visible[e.id] || hiding[e.id]).sort((a, b) => a.layer - b.layer).forEach(e => {
        h += createElemHTML(e, true);
        rendered[e.id] = true;
    });
    
    game.innerHTML = h;
    updateInventory();
}

function updateInventory() {
    const inv = document.getElementById("inventory");
    const visInv = inventory.filter(item => {
        const invItem = INVENTORY_ITEMS.find(i => (i.name || i) === item);
        return !invItem || (typeof invItem === "string") || invItem.visible;
    });
    if (visInv.length > 0) {
        inv.style.display = "flex";
        inv.innerHTML = visInv.map(x => '<div style="width:40px;height:40px;background:#f7931a;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px">' + x[0] + '</div>').join("");
    } else {
        inv.style.display = "none";
    }
}

function handleDragStart(ev, elemId) {
    ev.preventDefault();
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === elemId);
    if (!elem) return;
    draggedElem = elem;
    const rect = ev.target.getBoundingClientRect();
    const canvas = document.getElementById("game");
    const canvasRect = canvas.getBoundingClientRect();
    dragOffset.x = ev.clientX - rect.left;
    dragOffset.y = ev.clientY - rect.top;
    dragPos.x = ev.clientX - canvasRect.left;
    dragPos.y = ev.clientY - canvasRect.top;
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
}

function handleDragMove(ev) {
    if (!draggedElem) return;
    ev.preventDefault();
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    dragPos.x = ev.clientX - rect.left;
    dragPos.y = ev.clientY - rect.top;
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = (dragPos.x - dragOffset.x) + 'px';
        draggedDiv.style.top = (dragPos.y - dragOffset.y) + 'px';
    }
}

function handleDragEnd(ev) {
    if (!draggedElem) return;
    const s = STEPS.find(x => x.id === current);
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    const dropX = ev.clientX - rect.left;
    const dropY = ev.clientY - rect.top;
    s.elements.filter(e => e.type === "hotspot" && visible[e.id] && e.hotspotMode !== "click").forEach(h => {
        if (dropX >= h.x && dropX <= h.x + h.width && dropY >= h.y && dropY <= h.y + h.height) {
            s.events.forEach(ev => {
                if (ev.trigger.type === "onDrop" && ev.trigger.sourceElement === h.id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    });
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = draggedElem.x + 'px';
        draggedDiv.style.top = draggedElem.y + 'px';
    }
    draggedElem = null;
}

function handleClick(id) {
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "onClick" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
    });
}

render();
    </script>
</body>
</html>
