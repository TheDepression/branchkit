<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Builder Final</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: #0a0e27; color: #fff; overflow: hidden; }
        .app { display: grid; grid-template-columns: 200px 1fr 340px; grid-template-rows: 55px 1fr; height: 100vh; }
        .header { grid-column: 1/-1; background: #1a1f3a; border-bottom: 2px solid #f7931a; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; }
        .logo { font-size: 1.2rem; font-weight: 900; color: #f7931a; }
        .header-buttons { display: flex; gap: 6px; }
        .btn { padding: 6px 12px; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 11px; white-space: nowrap; }
        .btn-primary { background: #f7931a; color: #000; }
        .btn-secondary { background: #2d3748; color: #fff; }
        .btn-success { background: #10b981; color: #fff; }
        .btn-danger { background: #ef4444; color: #fff; }
        .btn-small { padding: 4px 8px; font-size: 10px; }
        .sidebar { background: #141829; border-right: 1px solid #2d3748; overflow-y: auto; padding: 10px; }
        .sidebar-right { border-left: 1px solid #2d3748; border-right: none; }
        .section-title { font-size: 0.65rem; font-weight: 700; text-transform: uppercase; color: #f7931a; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 2px solid #f7931a; }
        .step-item { background: #1a1f3a; border: 2px solid #2d3748; border-radius: 4px; padding: 6px; margin-bottom: 5px; cursor: move; font-size: 0.8rem; transition: all 0.2s; }
        .step-item:hover { border-color: #f7931a; }
        .step-item.active { border-color: #f7931a; background: #1f2541; }
        .step-item.drag-over { border: 2px dashed #10b981; background: #1e3a32; }
        .step-title { font-weight: 600; }
        .canvas { background: #0a0e27; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .preview-container { transform-origin: center center; }
        .preview { width: 1024px; height: 576px; background: #000; position: relative; border: 2px solid #f7931a; }
        .element { position: absolute; cursor: move; border: 2px dashed transparent; }
        .element:hover { border-color: #f7931a; }
        .element.selected { border-color: #10b981; border-style: solid; }
        .element img, .element video { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .element-text { background: rgba(0,0,0,0.8); padding: 15px; border-radius: 6px; color: white; font-size: 1.5rem; text-align: center; word-wrap: break-word; overflow: hidden; }
        .element-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; text-align: center; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .element-hotspot { border: 2px solid red; background: rgba(255,0,0,0.1); }
        .element-audio { background: rgba(0,100,200,0.3); border: 2px dashed #00aaff; display: flex; align-items: center; justify-content: center; font-size: 2rem; }
        .element-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .element-draggable { border: 2px dashed #00ff64; display: flex; align-items: center; justify-content: center; cursor: grab; overflow: hidden; }
        .element-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .resize-handle { position: absolute; width: 10px; height: 10px; background: #f7931a; right: -5px; bottom: -5px; cursor: se-resize; }
        .element-label { position: absolute; top: -20px; left: 0; background: #f7931a; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 700; }
        .form-group { margin-bottom: 10px; }
        .form-label { display: block; font-size: 0.65rem; font-weight: 600; text-transform: uppercase; color: #f7931a; margin-bottom: 4px; }
        .form-input, .form-textarea, .form-select { width: 100%; padding: 6px; background: #1a1f3a; border: 2px solid #2d3748; border-radius: 4px; color: #fff; font-size: 11px; }
        .form-textarea { resize: vertical; min-height: 50px; font-family: inherit; }
        .form-checkbox { margin-right: 6px; }
        .tabs { display: flex; gap: 3px; margin-bottom: 10px; border-bottom: 2px solid #2d3748; flex-wrap: wrap; }
        .tab { padding: 6px 8px; background: transparent; border: none; color: #6b7280; cursor: pointer; font-weight: 600; font-size: 0.65rem; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab.active { color: #f7931a; border-bottom-color: #f7931a; }
        .event-item { background: #1a1f3a; border: 1px solid #2d3748; border-radius: 4px; padding: 6px; margin-bottom: 5px; }
        .action-item { background: #0a0e27; padding: 5px; margin-top: 3px; border-radius: 4px; border: 1px solid #2d3748; }
        .condition-box { background: rgba(16, 185, 129, 0.1); border: 1px solid #10b981; padding: 5px; margin-bottom: 5px; border-radius: 4px; }
        .add-btn { width: 100%; padding: 6px; background: #2d3748; border: 1px dashed #6b7280; color: #6b7280; border-radius: 4px; cursor: pointer; font-size: 0.65rem; margin-top: 5px; }
        .add-btn:hover { background: #3d4758; border-color: #f7931a; color: #f7931a; }
        .info-box { background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; padding: 6px; margin-bottom: 10px; font-size: 0.65rem; line-height: 1.3; }
        .play-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 1000; }
        .play-exit { position: absolute; top: 20px; right: 20px; z-index: 1001; }
        .play-canvas { 
            width: 1024px; 
            height: 576px; 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .inventory-display { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; display: flex; gap: 10px; z-index: 100; }
        .inventory-item-icon { width: 40px; height: 40px; background: #f7931a; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .trans-fade { animation: fadeIn 0.5s ease-in; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
        .draggable-active { cursor: grabbing !important; opacity: 0.7; z-index: 9999 !important; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0e27; }
        ::-webkit-scrollbar-thumb { background: #2d3748; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        const { createElement: e, useState, useEffect, useRef } = React;

        function sanitizeStepName(name) {
            return name.replace(/[^a-zA-Z0-9_-]/g, '_');
        }

        function generateUniqueStepId(title, existingSteps) {
            let base = sanitizeStepName(title) || 'step';
            let id = base;
            let counter = 2;
            while (existingSteps.some(s => s.id === id)) {
                id = base + counter;
                counter++;
            }
            return id;
        }

        function createStep(title, existingSteps) {
            const id = generateUniqueStepId(title, existingSteps);
            return { id, title, elements: [], events: [], password: '', wrongPasswordStep: '', bgColor: '#000000', bgShapes: [] };
        }

        function createElement2(type) {
            const baseId = type + '_' + Date.now();
            return {
                id: baseId,
                type: type,
                label: type + '1',
                x: 100,
                y: 100,
                width: type === 'text' || type === 'button' ? 300 : type === 'audio' ? 200 : type === 'timer' ? 150 : type === 'draggable' ? 100 : 400,
                height: type === 'text' ? 100 : type === 'button' ? 60 : type === 'audio' ? 60 : type === 'timer' ? 150 : type === 'draggable' ? 100 : 300,
                content: '',
                visible: true,
                layer: 0,
                duration: 0,
                loop: false,
                autoplay: type === 'audio' || type === 'video',
                shape: 'rect',
                color: '#f7931a',
                countdown: 10,
                fontSize: 24,
                contentType: 'text',
                hotspotMode: 'both',
                transition: 'none',
                transitionDuration: 0.5,
                textColor: '#ffffff',
                textBgColor: 'rgba(0,0,0,0.8)',
                textSize: 24
            };
        }

        function createEvent() {
            return {
                id: 'event_' + Date.now(),
                trigger: { type: 'onLoad', delay: 0, sourceElement: '' },
                condition: null,
                actions: []
            };
        }

        function StoryBuilder() {
            const [steps, setSteps] = useState([]);
            const [currentStepId, setCurrentStepId] = useState(null);
            const [selectedElementId, setSelectedElementId] = useState(null);
            const [activeTab, setActiveTab] = useState('elements');
            const [dragging, setDragging] = useState(null);
            const [playMode, setPlayMode] = useState(false);
            const [playStartStep, setPlayStartStep] = useState(null);
            const [draggedStepId, setDraggedStepId] = useState(null);
            const [dragOverStepId, setDragOverStepId] = useState(null);
            const [scale, setScale] = useState(1);
            const [inventory, setInventory] = useState([]);
            const [draggedInPlay, setDraggedInPlay] = useState(null);
            const canvasRef = useRef(null);

            useEffect(() => {
                const updateScale = () => {
                    if (canvasRef.current) {
                        const container = canvasRef.current.parentElement;
                        const scaleX = (container.clientWidth - 40) / 1024;
                        const scaleY = (container.clientHeight - 40) / 576;
                        setScale(Math.min(scaleX, scaleY, 1));
                    }
                };
                updateScale();
                window.addEventListener('resize', updateScale);
                return () => window.removeEventListener('resize', updateScale);
            }, []);

            const getCurrentStep = () => steps.find(s => s.id === currentStepId);
            const getSelectedElement = () => {
                const step = getCurrentStep();
                return step?.elements.find(el => el.id === selectedElementId);
            };

            const updateStep = (updates) => {
                setSteps(steps.map(s => {
                    if (s.id === currentStepId) {
                        const updated = { ...s, ...updates };
                        if (updates.title && updates.title !== s.title) {
                            const newId = generateUniqueStepId(updates.title, steps.filter(st => st.id !== s.id));
                            if (newId !== s.id) {
                                updated.id = newId;
                                setCurrentStepId(newId);
                            }
                        }
                        return updated;
                    }
                    return s;
                }));
            };

            const updateElement = (elemId, updates) => {
                const step = getCurrentStep();
                if (step) {
                    const elements = step.elements.map(el => {
                        if (el.id === elemId) {
                            const updated = { ...el, ...updates };
                            if (updates.label) {
                                const sameType = step.elements.filter(e => e.type === el.type && e.id !== el.id);
                                const match = updates.label.match(/^(.*?)(\d+)$/);
                                if (match) {
                                    const base = match[1];
                                    let num = parseInt(match[2]);
                                    while (sameType.some(e => e.label === base + num)) {
                                        num++;
                                    }
                                    updated.label = base + num;
                                }
                            }
                            return updated;
                        }
                        return el;
                    });
                    updateStep({ elements });
                }
            };

            const createNewStep = () => {
                const title = prompt('Step name:', 'Step ' + (steps.length + 1));
                if (!title) return;
                const step = createStep(title, steps);
                setSteps([...steps, step]);
                setCurrentStepId(step.id);
            };

            const handleStepDragStart = (e, stepId) => {
                setDraggedStepId(stepId);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleStepDragOver = (e, stepId) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                if (stepId !== draggedStepId) {
                    setDragOverStepId(stepId);
                }
            };

            const handleStepDrop = (e, targetStepId) => {
                e.preventDefault();
                if (!draggedStepId || draggedStepId === targetStepId) {
                    setDraggedStepId(null);
                    setDragOverStepId(null);
                    return;
                }

                const draggedIndex = steps.findIndex(s => s.id === draggedStepId);
                const targetIndex = steps.findIndex(s => s.id === targetStepId);
                
                const newSteps = [...steps];
                const [draggedStep] = newSteps.splice(draggedIndex, 1);
                newSteps.splice(targetIndex, 0, draggedStep);
                
                setSteps(newSteps);
                setDraggedStepId(null);
                setDragOverStepId(null);
            };

            const handleStepDragEnd = () => {
                setDraggedStepId(null);
                setDragOverStepId(null);
            };

            const addElement = (type) => {
                const step = getCurrentStep();
                if (step) {
                    const elem = createElement2(type);
                    const sameType = step.elements.filter(e => e.type === type);
                    elem.label = type + (sameType.length + 1);
                    updateStep({ elements: [...step.elements, elem] });
                    setSelectedElementId(elem.id);
                }
            };

            const deleteElement = (elemId) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ elements: step.elements.filter(el => el.id !== elemId) });
                    if (selectedElementId === elemId) setSelectedElementId(null);
                }
            };

            const addInventoryItem = () => {
                const name = prompt('Inventory item name:');
                if (name && !inventory.find(i => i.name === name)) {
                    setInventory([...inventory, { name: name, visible: true }]);
                }
            };

            const deleteInventoryItem = (item) => {
                setInventory(inventory.filter(i => i.name !== item.name));
            };

            const addEvent = () => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ events: [...step.events, createEvent()] });
                }
            };

            const updateEvent = (eventId, updates) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({
                        events: step.events.map(ev => ev.id === eventId ? { ...ev, ...updates } : ev)
                    });
                }
            };

            const deleteEvent = (eventId) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ events: step.events.filter(ev => ev.id !== eventId) });
                }
            };

            const addEventAction = (eventId) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: [...event.actions, { id: 'action_' + Date.now(), type: 'show', target: '', value: '' }]
                    });
                }
            };

            const updateEventAction = (eventId, actionId, updates) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: event.actions.map(a => a.id === actionId ? { ...a, ...updates } : a)
                    });
                }
            };

            const deleteEventAction = (eventId, actionId) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: event.actions.filter(a => a.id !== actionId)
                    });
                }
            };

            const handleMouseDown = (ev, elemId) => {
                if (ev.target.classList.contains('resize-handle')) {
                    setDragging({ type: 'resize', elemId });
                } else {
                    setDragging({ type: 'move', elemId, startX: ev.clientX, startY: ev.clientY });
                }
                setSelectedElementId(elemId);
            };

            const handleMouseMove = (ev) => {
                if (!dragging) return;
                const elem = getSelectedElement();
                if (!elem) return;

                if (dragging.type === 'move') {
                    const dx = (ev.clientX - dragging.startX) / scale;
                    const dy = (ev.clientY - dragging.startY) / scale;
                    updateElement(elem.id, {
                        x: Math.max(0, Math.min(1024 - elem.width, elem.x + dx)),
                        y: Math.max(0, Math.min(576 - elem.height, elem.y + dy))
                    });
                    setDragging({ ...dragging, startX: ev.clientX, startY: ev.clientY });
                } else if (dragging.type === 'resize') {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    const newWidth = Math.max(50, Math.min(1024 - elem.x, (ev.clientX - rect.left) / scale - elem.x));
                    const newHeight = Math.max(50, Math.min(576 - elem.y, (ev.clientY - rect.top) / scale - elem.y));
                    updateElement(elem.id, { width: newWidth, height: newHeight });
                }
            };

            const handleMouseUp = () => setDragging(null);

            useEffect(() => {
                if (dragging) {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [dragging, scale]);

            const saveProject = () => {
                const data = JSON.stringify({ steps, inventory }, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'story.json';
                a.click();
            };

            const loadProject = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (ev) => {
                    const file = ev.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            setSteps(data.steps);
                            setInventory(data.inventory || []);
                            setCurrentStepId(data.steps[0]?.id);
                            alert('Loaded!');
                        } catch (err) {
                            alert('Error: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const exportHTML = () => {
                const html = generateHTML(steps, inventory);
                navigator.clipboard.writeText(html).then(() => {
                    alert('âœ… HTML copied!');
                }).catch(() => {
                    const textarea = document.createElement('textarea');
                    textarea.value = html;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('âœ… HTML copied!');
                });
            };

            if (playMode) {
                return e(PlayMode, { steps, inventory, onExit: () => setPlayMode(false), startStepId: playStartStep || currentStepId });
            }

            const currentStep = getCurrentStep();
            const selectedElement = getSelectedElement();

            return e('div', { className: 'app' },
                e('header', { className: 'header' },
                    e('div', { className: 'logo' }, 'Builder'),
                    e('div', { className: 'header-buttons' },
                        e('button', { className: 'btn btn-primary', onClick: () => { setPlayStartStep(steps[0]?.id); setPlayMode(true); }, title: 'Test All Steps' }, 'â–¶ All'),
                        e('button', { className: 'btn btn-primary', onClick: () => { setPlayStartStep(currentStepId); setPlayMode(true); }, title: 'Preview Current Step', style: { background: '#10b981' } }, 'â–¶ Step'),
                        e('button', { className: 'btn btn-secondary', onClick: saveProject }, 'ðŸ’¾'),
                        e('button', { className: 'btn btn-secondary', onClick: loadProject }, 'ðŸ“‚'),
                        e('button', { className: 'btn btn-success', onClick: exportHTML }, 'âš¡')
                    )
                ),
                
                e('aside', { className: 'sidebar' },
                    e('div', { className: 'section-title' }, 'Steps'),
                    e('button', { className: 'btn btn-primary btn-small', style: { width: '100%', marginBottom: '6px' }, onClick: createNewStep }, '+ Step'),
                    steps.map(step =>
                        e('div', {
                            key: step.id,
                            className: 'step-item' + (step.id === currentStepId ? ' active' : '') + (step.id === dragOverStepId ? ' drag-over' : ''),
                            draggable: true,
                            onDragStart: (ev) => handleStepDragStart(ev, step.id),
                            onDragOver: (ev) => handleStepDragOver(ev, step.id),
                            onDrop: (ev) => handleStepDrop(ev, step.id),
                            onDragEnd: handleStepDragEnd,
                            style: { opacity: step.id === draggedStepId ? 0.5 : 1 }
                        },
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', flex: 1 } },
                                    e('div', { style: { cursor: 'grab', fontSize: '12px', opacity: 0.5 } }, 'â˜°'),
                                    e('div', { className: 'step-title', onClick: () => setCurrentStepId(step.id), style: { flex: 1, cursor: 'pointer' } }, step.title)
                                ),
                                e('div', { style: { display: 'flex', gap: '3px' } },
                                    e('button', { 
                                        className: 'btn btn-secondary btn-small', 
                                        onClick: (ev) => {
                                            ev.stopPropagation();
                                            const newTitle = prompt('Rename step:', step.title);
                                            if (newTitle && newTitle !== step.title) {
                                                setSteps(steps.map(s => s.id === step.id ? { ...s, title: newTitle } : s));
                                            }
                                        },
                                        style: { padding: '2px 4px', fontSize: '10px' }
                                    }, 'âœï¸'),
                                    e('button', { 
                                        className: 'btn btn-success btn-small', 
                                        onClick: (ev) => {
                                            ev.stopPropagation();
                                            const clonedStep = JSON.parse(JSON.stringify(step));
                                            clonedStep.id = step.id + '_2';
                                            clonedStep.title = step.title + ' 2';
                                            const insertIndex = steps.findIndex(s => s.id === step.id) + 1;
                                            setSteps([...steps.slice(0, insertIndex), clonedStep, ...steps.slice(insertIndex)]);
                                        },
                                        style: { padding: '2px 4px', fontSize: '10px' }
                                    }, 'ðŸ“‹'),
                                    e('button', { 
                                        className: 'btn btn-danger btn-small', 
                                        onClick: (ev) => {
                                            ev.stopPropagation();
                                            if (steps.length === 1) {
                                                alert('Cannot delete the last step!');
                                                return;
                                            }
                                            if (confirm('Delete "' + step.title + '"?')) {
                                                const newSteps = steps.filter(s => s.id !== step.id);
                                                setSteps(newSteps);
                                                if (currentStepId === step.id) {
                                                    setCurrentStepId(newSteps[0].id);
                                                }
                                            }
                                        },
                                        style: { padding: '2px 4px', fontSize: '10px' }
                                    }, 'Ã—')
                                )
                            )
                        )
                    )
                ),

                e('main', { className: 'canvas' },
                    e('div', { ref: canvasRef, className: 'preview-container', style: { transform: 'scale(' + scale + ')' } },
                        e('div', { className: 'preview', style: { background: currentStep ? (currentStep.bgColor || '#000') : '#000' } },
                            currentStep && currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                                e('div', {
                                    key: shape.id,
                                    style: {
                                        position: 'absolute',
                                        left: shape.x + 'px',
                                        top: shape.y + 'px',
                                        width: shape.width + 'px',
                                        height: shape.height + 'px',
                                        background: shape.color,
                                        borderRadius: shape.type === 'circle' ? '50%' : '0',
                                        zIndex: 0
                                    }
                                })
                            ),
                            currentStep ? 
                                currentStep.elements
                                    .sort((a, b) => a.layer - b.layer)
                                    .filter(elem => elem.visible)
                                    .map(elem =>
                                        e('div', {
                                            key: elem.id,
                                            className: 'element' + (elem.id === selectedElementId ? ' selected' : '') + 
                                                      (elem.type === 'hotspot' ? ' element-hotspot' : ''),
                                            style: {
                                                left: elem.x + 'px',
                                                top: elem.y + 'px',
                                                width: elem.width + 'px',
                                                height: elem.height + 'px',
                                                zIndex: elem.layer,
                                                borderRadius: elem.shape === 'circle' ? '50%' : '0'
                                            },
                                            onMouseDown: (ev) => handleMouseDown(ev, elem.id)
                                        },
                                            e('div', { className: 'element-label' }, elem.label),
                                            elem.type === 'image' && elem.content && e('img', { src: elem.content }),
                                            elem.type === 'video' && elem.content && e('video', { src: elem.content, autoPlay: true, loop: elem.loop, muted: true }),
                                            elem.type === 'text' && e('div', { 
                                    className: 'element-text',
                                    style: { 
                                        fontSize: (elem.textSize || 24) + 'px',
                                        color: elem.textColor || '#ffffff',
                                        background: elem.textBgColor ? 
                                            (elem.textBgColor.startsWith('#') ? 
                                                elem.textBgColor + Math.round((elem.textBgOpacity || 0.8) * 255).toString(16).padStart(2, '0') : 
                                                elem.textBgColor) : 
                                            'rgba(0,0,0,0.8)'
                                    }
                                }, elem.content),
                                            elem.type === 'button' && e('div', { className: 'element-button', style: { background: elem.color } }, elem.content || 'Button'),
                                            elem.type === 'audio' && e('div', { className: 'element-audio' }, 'ðŸ”Š'),
                                            elem.type === 'timer' && e('div', { className: 'element-timer' }, elem.countdown),
                                            elem.type === 'draggable' && e('div', { className: 'element-draggable' },
                                                elem.contentType === 'image' && elem.content ? e('img', { src: elem.content }) :
                                                e('div', { style: { fontSize: elem.fontSize + 'px', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%' } }, elem.content || 'ðŸ“¦')
                                            ),
                                            elem.type === 'hotspot' && e('div', { style: { width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.8rem' } }, elem.label),
                                            e('div', { className: 'resize-handle' })
                                        )
                                    ) :
                                e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', color: '#6b7280', fontSize: '1.2rem' } }, 'Create a step')
                        )
                    )
                ),

                e('aside', { className: 'sidebar sidebar-right' },
                    currentStep ? e('div', null,
                        e('div', { className: 'form-group' },
                            e('input', {
                                className: 'form-input',
                                value: currentStep.title,
                                placeholder: 'Step Name',
                                onChange: (ev) => updateStep({ title: ev.target.value })
                            })
                        ),
                        currentStep.password && e('div', { style: { fontSize: '0.6rem', color: '#f7931a', marginBottom: '8px' } }, 'ðŸ”’ Password: ' + currentStep.password),
                        
                        e('div', { className: 'tabs' },
                            e('button', { className: 'tab' + (activeTab === 'elements' ? ' active' : ''), onClick: () => setActiveTab('elements') }, 'Elements'),
                            e('button', { className: 'tab' + (activeTab === 'events' ? ' active' : ''), onClick: () => setActiveTab('events') }, 'Events'),
                            e('button', { className: 'tab' + (activeTab === 'inventory' ? ' active' : ''), onClick: () => setActiveTab('inventory') }, 'Inventory'),
                            e('button', { className: 'tab' + (activeTab === 'settings' ? ' active' : ''), onClick: () => setActiveTab('settings') }, 'Settings')
                        ),

                        activeTab === 'elements' && e('div', null,
                            e('div', { className: 'section-title' }, 'Add'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('image') }, 'ðŸ–¼ï¸ Image'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('video') }, 'ðŸŽ¥ Video'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('text') }, 'ðŸ“ Text'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('button') }, 'ðŸ”˜ Button'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('audio') }, 'ðŸ”Š Audio'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('timer') }, 'â±ï¸ Timer'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('draggable') }, 'ðŸŽ¯ Draggable'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '8px' }, onClick: () => addElement('hotspot') }, 'ðŸ“ Hotspot'),
                            
                            selectedElement && e('div', null,
                                e('div', { className: 'section-title' }, selectedElement.label),
                                e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Label'),
                                    e('input', { className: 'form-input', value: selectedElement.label, onChange: (ev) => updateElement(selectedElement.id, { label: ev.target.value }) })
                                ),
                                
                                selectedElement.type === 'draggable' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Content Type'),
                                    e('select', { className: 'form-select', value: selectedElement.contentType || 'text', onChange: (ev) => updateElement(selectedElement.id, { contentType: ev.target.value }) },
                                        e('option', { value: 'text' }, 'Text/Emoji'),
                                        e('option', { value: 'image' }, 'Image URL')
                                    )
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'text' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text/Emoji'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'ðŸª³ or text', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }) })
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'text' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Font Size'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.fontSize, onChange: (ev) => updateElement(selectedElement.id, { fontSize: parseInt(ev.target.value) || 24 }) })
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'image' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Image URL or Upload'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                    e('input', { 
                                        type: 'file', 
                                        className: 'form-input',
                                        accept: 'image/*',
                                        onChange: (ev) => {
                                            const file = ev.target.files[0];
                                            if (file) {
                                                const url = URL.createObjectURL(file);
                                                updateElement(selectedElement.id, { content: url });
                                            }
                                        }
                                    })
                                ),

                                (selectedElement.type !== 'hotspot' && selectedElement.type !== 'audio' && selectedElement.type !== 'timer' && selectedElement.type !== 'draggable') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, selectedElement.type === 'text' || selectedElement.type === 'button' ? 'Text' : 'URL or Upload'),
                                    selectedElement.type === 'text' || selectedElement.type === 'button' ?
                                        e('textarea', { className: 'form-textarea', value: selectedElement.content, onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }) }) :
                                        e('div', null,
                                            e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                            e('input', { 
                                                type: 'file', 
                                                className: 'form-input',
                                                accept: selectedElement.type === 'image' ? 'image/*' : 'video/*',
                                                onChange: (ev) => {
                                                    const file = ev.target.files[0];
                                                    if (file) {
                                                        const url = URL.createObjectURL(file);
                                                        updateElement(selectedElement.id, { content: url });
                                                    }
                                                }
                                            })
                                        )
                                ),
                                selectedElement.type === 'audio' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Audio URL or Upload'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                    e('input', { 
                                        type: 'file', 
                                        className: 'form-input',
                                        accept: 'audio/*',
                                        onChange: (ev) => {
                                            const file = ev.target.files[0];
                                            if (file) {
                                                const url = URL.createObjectURL(file);
                                                updateElement(selectedElement.id, { content: url });
                                            }
                                        }
                                    })
                                ),
                                selectedElement.type === 'timer' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Countdown (seconds)'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.countdown, onChange: (ev) => updateElement(selectedElement.id, { countdown: parseInt(ev.target.value) || 10 }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Button Color'),
                                    e('input', { type: 'color', className: 'form-input', value: selectedElement.color, onChange: (ev) => updateElement(selectedElement.id, { color: ev.target.value }) })
                                ),
                                selectedElement.type === 'hotspot' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Interaction Mode'),
                                    e('select', { className: 'form-select', value: selectedElement.hotspotMode || 'both', onChange: (ev) => updateElement(selectedElement.id, { hotspotMode: ev.target.value }) },
                                        e('option', { value: 'both' }, 'Click & Drop'),
                                        e('option', { value: 'click' }, 'Click Only'),
                                        e('option', { value: 'drop' }, 'Drop Only')
                                    )
                                ),
                                selectedElement.type === 'hotspot' && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '0.65rem' } },
                                        e('input', { type: 'checkbox', className: 'form-checkbox', checked: selectedElement.showInGame, onChange: (ev) => updateElement(selectedElement.id, { showInGame: ev.target.checked }) }),
                                        'Visible in Game'
                                    )
                                ),
                                e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Layer'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.layer, onChange: (ev) => updateElement(selectedElement.id, { layer: parseInt(ev.target.value) || 0 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'video' || selectedElement.type === 'text') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Duration (0=forever)'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.duration, onChange: (ev) => updateElement(selectedElement.id, { duration: parseFloat(ev.target.value) || 0 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Transition'),
                                    e('select', { className: 'form-select', value: selectedElement.transition || 'none', onChange: (ev) => updateElement(selectedElement.id, { transition: ev.target.value }) },
                                        e('option', { value: 'none' }, 'None'),
                                        e('option', { value: 'fade' }, 'Fade In/Out'),
                                        e('option', { value: 'slideLeft' }, 'Slide from Left'),
                                        e('option', { value: 'slideRight' }, 'Slide from Right'),
                                        e('option', { value: 'slideUp' }, 'Slide from Top'),
                                        e('option', { value: 'slideDown' }, 'Slide from Bottom'),
                                        e('option', { value: 'zoom' }, 'Zoom In/Out')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text') && selectedElement.transition && selectedElement.transition !== 'none' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Transition Speed (seconds)'),
                                    e('input', { type: 'number', step: '0.1', className: 'form-input', value: selectedElement.transitionDuration || 0.5, onChange: (ev) => updateElement(selectedElement.id, { transitionDuration: parseFloat(ev.target.value) || 0.5 }) })
                                ),
                                selectedElement.type === 'text' && e('div', null,
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Font Size'),
                                        e('input', { type: 'number', className: 'form-input', value: selectedElement.textSize || 24, onChange: (ev) => updateElement(selectedElement.id, { textSize: parseInt(ev.target.value) || 24 }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Text Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.textColor || '#ffffff', onChange: (ev) => updateElement(selectedElement.id, { textColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Background Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.textBgColor ? selectedElement.textBgColor.replace('rgba(0,0,0,0.8)', '#000000') : '#000000', onChange: (ev) => updateElement(selectedElement.id, { textBgColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Background Opacity'),
                                        e('input', { type: 'range', min: '0', max: '1', step: '0.1', className: 'form-input', value: selectedElement.textBgOpacity || 0.8, onChange: (ev) => updateElement(selectedElement.id, { textBgOpacity: parseFloat(ev.target.value) }) })
                                    )
                                ),
                                (selectedElement.type === 'audio' || selectedElement.type === 'video') && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '0.65rem' } },
                                        e('input', { type: 'checkbox', className: 'form-checkbox', checked: selectedElement.loop, onChange: (ev) => updateElement(selectedElement.id, { loop: ev.target.checked }) }),
                                        'Loop'
                                    )
                                ),
                                (selectedElement.type === 'hotspot' || selectedElement.type === 'draggable') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Shape'),
                                    e('select', { className: 'form-select', value: selectedElement.shape, onChange: (ev) => updateElement(selectedElement.id, { shape: ev.target.value }) },
                                        e('option', { value: 'rect' }, 'Rectangle'),
                                        e('option', { value: 'circle' }, 'Circle')
                                    )
                                ),
                                e('button', { className: 'btn btn-danger btn-small', style: { width: '100%' }, onClick: () => deleteElement(selectedElement.id) }, 'Delete')
                            )
                        ),

                        activeTab === 'events' && e('div', null,
                            e('div', { className: 'info-box' }, 'Events trigger actions. Add conditions to check inventory.'),
                            currentStep.events.map(event =>
                                e('div', { key: event.id, className: 'event-item' },
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '5px' } },
                                        e('select', { className: 'form-select', style: { flex: 1, marginRight: '4px', fontSize: '0.6rem' }, value: event.trigger.type, onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, type: ev.target.value } }) },
                                            e('option', { value: 'onLoad' }, 'On Load'),
                                            e('option', { value: 'afterDelay' }, 'After Delay'),
                                            e('option', { value: 'afterElement' }, 'After Element'),
                                            e('option', { value: 'onClick' }, 'On Click'),
                                            e('option', { value: 'onDrop' }, 'On Drop')
                                        ),
                                        e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteEvent(event.id) }, 'Ã—')
                                    ),
                                    event.trigger.type === 'afterDelay' && e('input', { type: 'number', className: 'form-input', placeholder: 'Seconds', value: event.trigger.delay || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, delay: parseFloat(ev.target.value) || 0 } }), style: { marginBottom: '5px' } }),
                                    event.trigger.type === 'afterElement' && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                        e('option', { value: '' }, '-- Select Element --'),
                                        currentStep.elements.map(el => e('option', { key: el.id, value: el.id }, el.label))
                                    ),
                                    (event.trigger.type === 'onClick' || event.trigger.type === 'onDrop') && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                        e('option', { value: '' }, event.trigger.type === 'onClick' ? '-- Click Target --' : '-- Drop Zone --'),
                                        currentStep.elements.filter(el => el.type === 'button' || el.type === 'hotspot').map(el => e('option', { key: el.id, value: el.id }, el.label))
                                    ),
                                    
                                    event.condition && e('div', { className: 'condition-box' },
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '3px' } },
                                            e('span', { style: { fontSize: '0.6rem', fontWeight: 700 } }, 'CONDITION'),
                                            e('button', { className: 'btn btn-danger btn-small', onClick: () => updateEvent(event.id, { condition: null }) }, 'Ã—')
                                        ),
                                        e('select', { className: 'form-select', value: event.condition.type, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, type: ev.target.value } }), style: { marginBottom: '3px', fontSize: '0.6rem' } },
                                            e('option', { value: 'hasItem' }, 'Has Item'),
                                            e('option', { value: 'notHasItem' }, 'Does NOT Have Item')
                                        ),
                                        e('select', { className: 'form-select', value: event.condition.item, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, item: ev.target.value } }) },
                                            e('option', { value: '' }, '-- Item --'),
                                            inventory.map(item => e('option', { key: item.name || item, value: item.name || item }, item.name || item))
                                        )
                                    ),
                                    !event.condition && e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '5px' }, onClick: () => updateEvent(event.id, { condition: { type: 'hasItem', item: '' } }) }, '+ Add Condition'),
                                    
                                    event.actions.map(action =>
                                        e('div', { key: action.id, className: 'action-item' },
                                            e('select', { className: 'form-select', value: action.type, onChange: (ev) => updateEventAction(event.id, action.id, { type: ev.target.value }), style: { marginBottom: '3px', fontSize: '0.6rem' } },
                                                e('option', { value: 'show' }, 'Show'),
                                                e('option', { value: 'hide' }, 'Hide'),
                                                e('option', { value: 'showDelay' }, 'Show (Delayed)'),
                                                e('option', { value: 'hideDelay' }, 'Hide (Delayed)'),
                                                e('option', { value: 'goto' }, 'Go To Step'),
                                                e('option', { value: 'addItem' }, 'Add Inventory'),
                                                e('option', { value: 'removeItem' }, 'Remove Inventory')
                                            ),
                                            action.type === 'goto' ?
                                                e('div', null,
                                                    e('div', { style: { fontSize: '0.6rem', color: '#f7931a', marginBottom: '3px' } }, 'Select one or more (random if multiple):'),
                                                    steps.map(s =>
                                                        e('label', { key: s.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', marginBottom: '2px', cursor: 'pointer' } },
                                                            e('input', { 
                                                                type: 'checkbox', 
                                                                className: 'form-checkbox',
                                                                checked: action.targets ? action.targets.includes(s.id) : action.target === s.id,
                                                                onChange: (ev) => {
                                                                    if (ev.target.checked) {
                                                                        const newTargets = action.targets ? [...action.targets, s.id] : [action.target, s.id].filter(Boolean);
                                                                        updateEventAction(event.id, action.id, { targets: newTargets, target: '' });
                                                                    } else {
                                                                        const newTargets = action.targets ? action.targets.filter(t => t !== s.id) : [];
                                                                        updateEventAction(event.id, action.id, { targets: newTargets.length > 0 ? newTargets : undefined, target: newTargets.length === 0 ? '' : action.target });
                                                                    }
                                                                }
                                                            }),
                                                            s.title
                                                        )
                                                    )
                                                ) :
                                            action.type === 'addItem' || action.type === 'removeItem' ?
                                                e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Item --'),
                                                    inventory.map(item => e('option', { key: item.name || item, value: item.name || item }, item.name || item))
                                                ) :
                                            (action.type === 'show' || action.type === 'hide' || action.type === 'showDelay' || action.type === 'hideDelay') ?
                                                e('div', null,
                                                    (action.type === 'showDelay' || action.type === 'hideDelay') && e('div', { className: 'form-group', style: { marginBottom: '5px' } },
                                                        e('label', { className: 'form-label' }, 'Delay (seconds)'),
                                                        e('input', { type: 'number', step: '0.1', className: 'form-input', value: action.delay || 0, onChange: (ev) => updateEventAction(event.id, action.id, { delay: parseFloat(ev.target.value) || 0 }) })
                                                    ),
                                                    e('div', { style: { fontSize: '0.6rem', color: '#10b981', marginBottom: '3px' } }, 'Select multiple:'),
                                                    currentStep.elements.map(el =>
                                                        e('label', { key: el.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', marginBottom: '2px', cursor: 'pointer' } },
                                                            e('input', { 
                                                                type: 'checkbox', 
                                                                className: 'form-checkbox',
                                                                checked: action.targets ? action.targets.includes(el.id) : action.target === el.id,
                                                                onChange: (ev) => {
                                                                    if (ev.target.checked) {
                                                                        const newTargets = action.targets ? [...action.targets, el.id] : [action.target, el.id].filter(Boolean);
                                                                        updateEventAction(event.id, action.id, { targets: newTargets, target: '' });
                                                                    } else {
                                                                        const newTargets = action.targets ? action.targets.filter(t => t !== el.id) : [];
                                                                        updateEventAction(event.id, action.id, { targets: newTargets.length > 0 ? newTargets : undefined, target: newTargets.length === 0 ? '' : action.target });
                                                                    }
                                                                }
                                                            }),
                                                            el.label
                                                        )
                                                    )
                                                ) :
                                                e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Element --'),
                                                    currentStep.elements.map(el => e('option', { key: el.id, value: el.id }, el.label))
                                                ),
                                            e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteEventAction(event.id, action.id), style: { marginTop: '3px', width: '100%' } }, 'Remove')
                                        )
                                    ),
                                    e('button', { className: 'add-btn', onClick: () => addEventAction(event.id) }, '+ Action')
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: addEvent }, '+ Event')
                        ),

                        activeTab === 'inventory' && e('div', null,
                            e('div', { className: 'info-box' }, 'Global inventory items. Visible items show at bottom-left in game.'),
                            inventory.map(item =>
                                e('div', { key: item.name || item, style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '5px', background: '#1a1f3a', marginBottom: '4px', borderRadius: '4px' } },
                                    e('span', { style: { fontSize: '0.75rem', flex: 1 } }, item.name || item),
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', marginRight: '8px', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: typeof item === 'string' ? true : item.visible,
                                            onChange: (ev) => {
                                                if (typeof item === 'string') {
                                                    setInventory(inventory.map(i => i === item ? { name: item, visible: ev.target.checked } : i));
                                                } else {
                                                    setInventory(inventory.map(i => i.name === item.name ? { ...i, visible: ev.target.checked } : i));
                                                }
                                            }
                                        }),
                                        'Visible'
                                    ),
                                    e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteInventoryItem(item) }, 'Ã—')
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: addInventoryItem }, '+ Item')
                        ),

                        activeTab === 'settings' && e('div', null,
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Background Color'),
                                e('input', { type: 'color', className: 'form-input', value: currentStep.bgColor || '#000000', onChange: (ev) => updateStep({ bgColor: ev.target.value }) })
                            ),
                            e('div', { className: 'section-title' }, 'Background Shapes'),
                            currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                                e('div', { key: shape.id, style: { background: '#1a1f3a', padding: '8px', marginBottom: '5px', borderRadius: '4px' } },
                                    e('div', { style: { display: 'flex', gap: '5px', marginBottom: '5px' } },
                                        e('select', { className: 'form-select', style: { flex: 1 }, value: shape.type, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, type: ev.target.value } : s) }) },
                                            e('option', { value: 'rect' }, 'Rectangle'),
                                            e('option', { value: 'circle' }, 'Circle')
                                        ),
                                        e('input', { type: 'color', className: 'form-input', style: { width: '60px' }, value: shape.color, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, color: ev.target.value } : s) }) }),
                                        e('button', { className: 'btn btn-danger btn-small', onClick: () => updateStep({ bgShapes: currentStep.bgShapes.filter(s => s.id !== shape.id) }) }, 'Ã—')
                                    ),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px', fontSize: '0.6rem' } },
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'X', value: shape.x, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, x: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Y', value: shape.y, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, y: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Width', value: shape.width, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, width: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Height', value: shape.height, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, height: parseInt(ev.target.value) || 0 } : s) }) })
                                    )
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: () => updateStep({ bgShapes: [...(currentStep.bgShapes || []), { id: 'shape_' + Date.now(), type: 'rect', color: '#ffffff', x: 100, y: 100, width: 200, height: 200 }] }) }, '+ Shape'),
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Password'),
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Password Lock'),
                                e('input', { className: 'form-input', value: currentStep.password, placeholder: 'Optional', onChange: (ev) => updateStep({ password: ev.target.value }) })
                            ),
                            currentStep.password && e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Wrong Password â†’ Go To'),
                                e('select', { className: 'form-select', value: currentStep.wrongPasswordStep, onChange: (ev) => updateStep({ wrongPasswordStep: ev.target.value }) },
                                    e('option', { value: '' }, '-- Exit Game --'),
                                    steps.map(s => e('option', { key: s.id, value: s.id }, s.title))
                                )
                            ),
                            e('div', { className: 'info-box' }, 'Background shapes appear behind all elements')
                        )
                    ) : e('div', { className: 'info-box' }, 'â† Create a step')
                )
            );
        }

        function PlayMode({ steps, inventory, onExit, startStepId }) {
            const [currentStepId, setCurrentStepId] = useState(startStepId || steps[0]?.id);
            const [visibleElements, setVisibleElements] = useState({});
            const [playerInventory, setPlayerInventory] = useState([]);
            const [activeTimers, setActiveTimers] = useState({});
            const [eventTimers, setEventTimers] = useState([]);
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
            const [hidingElements, setHidingElements] = useState({});

            const currentStep = steps.find(s => s.id === currentStepId);

            useEffect(() => {
                eventTimers.forEach(timer => clearTimeout(timer));
                setEventTimers([]);
                setActiveTimers({});  // Clear all active timers when step changes
                setHidingElements({}); // Clear hiding state
                
                if (!currentStep) return;

                if (currentStep.password) {
                    const pwd = prompt('Enter password:');
                    if (pwd !== currentStep.password) {
                        if (currentStep.wrongPasswordStep) {
                            setCurrentStepId(currentStep.wrongPasswordStep);
                        } else {
                            alert('Wrong password!');
                            onExit();
                        }
                        return;
                    }
                }

                const visible = {};
                const newTimers = [];
                currentStep.elements.forEach(elem => {
                    visible[elem.id] = elem.visible;
                    // Set duration timers for elements with duration > 0
                    if (elem.visible && elem.duration && elem.duration > 0) {
                        const timer = setTimeout(() => {
                            setVisibleElements(prev => ({ ...prev, [elem.id]: false }));
                        }, elem.duration * 1000);
                        newTimers.push(timer);
                    }
                });
                setVisibleElements(visible);
                
                // Process onLoad and afterDelay events
                currentStep.events.forEach(event => {
                    if (checkCondition(event.condition)) {
                        if (event.trigger.type === 'onLoad') {
                            processActions(event.actions);
                        } else if (event.trigger.type === 'afterDelay') {
                            const timer = setTimeout(() => processActions(event.actions), (event.trigger.delay || 0) * 1000);
                            newTimers.push(timer);
                        }
                    }
                });
                
                // Start timers AFTER onLoad events (so hidden timers don't start)
                setTimeout(() => {
                    const currentVisibility = visibleElements;
                    currentStep.elements.forEach(elem => {
                        if (elem.type === 'timer' && currentVisibility[elem.id] !== false && visible[elem.id]) {
                            let remaining = elem.countdown;
                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                            const interval = setInterval(() => {
                                remaining--;
                                setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                if (remaining <= 0) {
                                    clearInterval(interval);
                                    currentStep.events.forEach(event => {
                                        if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                            if (checkCondition(event.condition)) {
                                                processActions(event.actions);
                                            }
                                        }
                                    });
                                }
                            }, 1000);
                            newTimers.push(interval);
                        }
                    });
                    setEventTimers(newTimers);
                }, 100);
                
                setEventTimers(newTimers);

                setTimeout(() => {
                    const videos = document.querySelectorAll('video');
                    videos.forEach(video => {
                        const elem = currentStep.elements.find(e => e.content && video.src.includes(e.content));
                        if (elem) {
                            video.onended = () => {
                                currentStep.events.forEach(event => {
                                    if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                        if (checkCondition(event.condition)) {
                                            processActions(event.actions);
                                        }
                                    }
                                });
                            };
                        }
                    });
                }, 100);

                return () => {
                    newTimers.forEach(timer => clearTimeout(timer));
                };
            }, [currentStepId]);

            const checkCondition = (condition) => {
                if (!condition) return true;
                if (condition.type === 'hasItem') {
                    return playerInventory.includes(condition.item);
                } else if (condition.type === 'notHasItem') {
                    return !playerInventory.includes(condition.item);
                }
                return true;
            };

            const processActions = (actions) => {
                actions.forEach(action => {
                    if (action.type === 'show' || action.type === 'showDelay') {
                        const showAction = () => {
                            if (action.targets && action.targets.length > 0) {
                                action.targets.forEach(targetId => {
                                    setVisibleElements(prev => ({ ...prev, [targetId]: true }));
                                    const elem = currentStep.elements.find(e => e.id === targetId);
                                    if (elem) {
                                        // Start timer if it's a timer element
                                        if (elem.type === 'timer') {
                                            let remaining = elem.countdown;
                                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                            const interval = setInterval(() => {
                                                remaining--;
                                                setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                                if (remaining <= 0) {
                                                    clearInterval(interval);
                                                    currentStep.events.forEach(event => {
                                                        if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                                            if (checkCondition(event.condition)) {
                                                                processActions(event.actions);
                                                            }
                                                        }
                                                    });
                                                }
                                            }, 1000);
                                            setEventTimers(prev => [...prev, interval]);
                                        }
                                        // Handle duration
                                        if (elem.duration && elem.duration > 0) {
                                            const timer = setTimeout(() => {
                                                setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                            }, elem.duration * 1000);
                                            setEventTimers(prev => [...prev, timer]);
                                        }
                                    }
                                });
                            } else if (action.target) {
                                setVisibleElements(prev => ({ ...prev, [action.target]: true }));
                                const elem = currentStep.elements.find(e => e.id === action.target);
                                if (elem) {
                                    // Start timer if it's a timer element
                                    if (elem.type === 'timer') {
                                        let remaining = elem.countdown;
                                        setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                        const interval = setInterval(() => {
                                            remaining--;
                                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                            if (remaining <= 0) {
                                                clearInterval(interval);
                                                currentStep.events.forEach(event => {
                                                    if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                                        if (checkCondition(event.condition)) {
                                                            processActions(event.actions);
                                                        }
                                                    }
                                                });
                                            }
                                        }, 1000);
                                        setEventTimers(prev => [...prev, interval]);
                                    }
                                    // Handle duration
                                    if (elem.duration && elem.duration > 0) {
                                        const timer = setTimeout(() => {
                                            setVisibleElements(prev => ({ ...prev, [action.target]: false }));
                                        }, elem.duration * 1000);
                                        setEventTimers(prev => [...prev, timer]);
                                    }
                                }
                            }
                        };
                        if (action.type === 'showDelay' && action.delay) {
                            const timer = setTimeout(showAction, action.delay * 1000);
                            setEventTimers(prev => [...prev, timer]);
                        } else {
                            showAction();
                        }
                    } else if (action.type === 'hide' || action.type === 'hideDelay') {
                        const hideAction = () => {
                            const elementsToHide = action.targets && action.targets.length > 0 ? action.targets : [action.target];
                            elementsToHide.forEach(targetId => {
                                if (!targetId) return;
                                const elem = currentStep.elements.find(e => e.id === targetId);
                                if (elem && elem.transition && elem.transition !== 'none') {
                                    // Mark as hiding to show out-transition
                                    setHidingElements(prev => ({ ...prev, [targetId]: true }));
                                    // Actually hide after transition duration
                                    const duration = (elem.transitionDuration || 0.5) * 1000;
                                    const timer = setTimeout(() => {
                                        setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                        setHidingElements(prev => ({ ...prev, [targetId]: false }));
                                    }, duration);
                                    setEventTimers(prev => [...prev, timer]);
                                } else {
                                    // No transition, hide immediately
                                    setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                }
                            });
                        };
                        if (action.type === 'hideDelay' && action.delay) {
                            const timer = setTimeout(hideAction, action.delay * 1000);
                            setEventTimers(prev => [...prev, timer]);
                        } else {
                            hideAction();
                        }
                    } else if (action.type === 'goto') {
                        if (action.targets && action.targets.length > 0) {
                            // Random selection from multiple steps
                            const randomStep = action.targets[Math.floor(Math.random() * action.targets.length)];
                            setCurrentStepId(randomStep);
                        } else if (action.target) {
                            setCurrentStepId(action.target);
                        }
                    } else if (action.type === 'addItem') {
                        setPlayerInventory(prev => prev.includes(action.target) ? prev : [...prev, action.target]);
                    } else if (action.type === 'removeItem') {
                        setPlayerInventory(prev => prev.filter(item => item !== action.target));
                    }
                });
            };

            const handleClick = (elem) => {
                if (!currentStep) return;
                if (elem.type === 'hotspot' && (elem.hotspotMode === 'drop')) return;
                
                currentStep.events.forEach(event => {
                    if (event.trigger.type === 'onClick' && event.trigger.sourceElement === elem.id) {
                        if (checkCondition(event.condition)) {
                            processActions(event.actions);
                        }
                    }
                });
            };

            const handleDragStart = (ev, elem) => {
                ev.preventDefault();
                const rect = ev.currentTarget.getBoundingClientRect();
                const canvas = document.querySelector('.play-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                setDragOffset({
                    x: ev.clientX - rect.left,
                    y: ev.clientY - rect.top
                });
                setDraggedItem(elem);
                setDragPos({ x: ev.clientX - canvasRect.left, y: ev.clientY - canvasRect.top });
            };

            const handleDragMove = (ev) => {
                if (!draggedItem) return;
                ev.preventDefault();
                const canvas = document.querySelector('.play-canvas');
                const rect = canvas.getBoundingClientRect();
                setDragPos({ x: ev.clientX - rect.left, y: ev.clientY - rect.top });
            };

            const handleDragEnd = (ev) => {
                if (!draggedItem) return;
                
                const canvas = document.querySelector('.play-canvas');
                const rect = canvas.getBoundingClientRect();
                const dropX = ev.clientX - rect.left;
                const dropY = ev.clientY - rect.top;

                currentStep.elements.filter(e => e.type === 'hotspot' && visibleElements[e.id] && (e.hotspotMode !== 'click')).forEach(hotspot => {
                    if (dropX >= hotspot.x && dropX <= hotspot.x + hotspot.width && 
                        dropY >= hotspot.y && dropY <= hotspot.y + hotspot.height) {
                        currentStep.events.forEach(event => {
                            if (event.trigger.type === 'onDrop' && event.trigger.sourceElement === hotspot.id) {
                                if (checkCondition(event.condition)) {
                                    processActions(event.actions);
                                }
                            }
                        });
                    }
                });

                setDraggedItem(null);
            };

            useEffect(() => {
                if (draggedItem) {
                    document.addEventListener('mousemove', handleDragMove);
                    document.addEventListener('mouseup', handleDragEnd);
                    return () => {
                        document.removeEventListener('mousemove', handleDragMove);
                        document.removeEventListener('mouseup', handleDragEnd);
                    };
                }
            }, [draggedItem]);

            if (!currentStep) {
                return e('div', { className: 'play-overlay' },
                    e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', color: '#fff', fontSize: '1.5rem' } }, 'Story ended')
                );
            }

            return e('div', { className: 'play-overlay' },
                e('button', { className: 'btn btn-danger play-exit', onClick: onExit }, 'âœ• Exit'),
                e('div', { className: 'play-canvas', style: { background: currentStep.bgColor || '#000' } },
                    currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                        e('div', {
                            key: shape.id,
                            style: {
                                position: 'absolute',
                                left: shape.x + 'px',
                                top: shape.y + 'px',
                                width: shape.width + 'px',
                                height: shape.height + 'px',
                                background: shape.color,
                                borderRadius: shape.type === 'circle' ? '50%' : '0',
                                zIndex: 0
                            }
                        })
                    ),
                    currentStep.elements
                        .filter(elem => visibleElements[elem.id] || hidingElements[elem.id])
                        .sort((a, b) => a.layer - b.layer)
                        .map(elem => {
                            const isHiding = hidingElements[elem.id];
                            const transClass = elem.transition && elem.transition !== 'none' ? 
                                (isHiding ? 'trans-' + elem.transition + '-out' : 'trans-' + elem.transition) : 
                                '';
                            return e('div', {
                                key: elem.id,
                                className: transClass,
                                onMouseDown: elem.type === 'draggable' ? (ev) => handleDragStart(ev, elem) : undefined,
                                style: {
                                    position: 'absolute',
                                    left: (draggedItem?.id === elem.id ? dragPos.x - dragOffset.x : elem.x) + 'px',
                                    top: (draggedItem?.id === elem.id ? dragPos.y - dragOffset.y : elem.y) + 'px',
                                    width: elem.width + 'px',
                                    height: elem.height + 'px',
                                    zIndex: draggedItem?.id === elem.id ? 9999 : elem.layer,
                                    cursor: elem.type === 'draggable' ? (draggedItem?.id === elem.id ? 'grabbing' : 'grab') : (elem.type === 'button' || (elem.type === 'hotspot' && elem.hotspotMode !== 'drop')) ? 'pointer' : 'default',
                                    borderRadius: elem.shape === 'circle' ? '50%' : '0',
                                    opacity: draggedItem?.id === elem.id ? 0.7 : 1,
                                    animationDuration: (elem.transitionDuration || 0.5) + 's'
                                },
                                onClick: () => handleClick(elem)
                            },
                                elem.type === 'image' && elem.content && e('img', { src: elem.content, style: { width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none' } }),
                                elem.type === 'video' && elem.content && e('video', { src: elem.content, autoPlay: elem.autoplay, loop: elem.loop, style: { width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none' } }),
                                elem.type === 'text' && e('div', { 
                                    className: 'element-text', 
                                    style: { 
                                        fontSize: (elem.textSize || 24) + 'px',
                                        color: elem.textColor || '#ffffff',
                                        background: elem.textBgColor ? 
                                            (elem.textBgColor.startsWith('#') ? 
                                                elem.textBgColor + Math.round((elem.textBgOpacity || 0.8) * 255).toString(16).padStart(2, '0') : 
                                                elem.textBgColor) : 
                                            'rgba(0,0,0,0.8)'
                                    } 
                                }, elem.content),
                                elem.type === 'button' && e('div', { className: 'element-button', style: { background: elem.color } }, elem.content || 'Button'),
                                elem.type === 'audio' && elem.content && e('audio', { src: elem.content, autoPlay: elem.autoplay, loop: elem.loop }),
                                elem.type === 'timer' && e('div', { className: 'element-timer' }, activeTimers[elem.id] !== undefined ? activeTimers[elem.id] : elem.countdown),
                                elem.type === 'draggable' && (
                                    elem.contentType === 'image' && elem.content ? 
                                        e('img', { src: elem.content, style: { width: '100%', height: '100%', objectFit: 'contain', pointerEvents: 'none' } }) :
                                        e('div', { style: { fontSize: elem.fontSize + 'px', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', pointerEvents: 'none' } }, elem.content || 'ðŸ“¦')
                                ),
                                elem.type === 'hotspot' && elem.showInGame && e('div', { style: { width: '100%', height: '100%', border: '3px dashed rgba(255,0,0,0.5)', background: 'rgba(255,0,0,0.05)' } })
                            );
                        })
                ),
                playerInventory.filter(itemName => {
                    const invItem = inventory.find(i => (i.name || i) === itemName);
                    return !invItem || (typeof invItem === 'string') || invItem.visible;
                }).length > 0 && e('div', { className: 'inventory-display' },
                    playerInventory.filter(itemName => {
                        const invItem = inventory.find(i => (i.name || i) === itemName);
                        return !invItem || (typeof invItem === 'string') || invItem.visible;
                    }).map(item => e('div', { key: item, className: 'inventory-item-icon' }, item[0]))
                )
            );
        }

        function generateHTML(steps, inventory) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Story</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        .canvas { width: 1024px; height: 576px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .elem { position: absolute; }
        .elem img, .elem video { width: 100%; height: 100%; object-fit: cover; }
        .elem-text { padding: 15px; border-radius: 6px; text-align: center; }
        .elem-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .elem-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .elem-draggable { cursor: grab; display: flex; align-items: center; justify-content: center; user-select: none; }
        .elem-draggable:active { cursor: grabbing; }
        .elem-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .elem-hotspot-visible { border: 3px dashed rgba(255,0,0,0.5); background: rgba(255,0,0,0.05); }
        .inventory-display { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; display: flex; gap: 10px; }
        .trans-fade { animation: fadeIn 0.5s ease-in forwards; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out forwards; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out forwards; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out forwards; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out forwards; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out forwards; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
    </style>
</head>
<body>
    <div id="game" class="canvas"></div>
    <div id="inventory" class="inventory-display" style="display:none"></div>
    <script>
const STEPS = ${JSON.stringify(steps)};
const INVENTORY_ITEMS = ${JSON.stringify(inventory)};
let current = STEPS[0].id;
let visible = {};
let inventory = [];
let timers = [];
let timerCountdowns = {};
let hiding = {};
let rendered = {};
let draggedElem = null;
let dragOffset = { x: 0, y: 0 };
let dragPos = { x: 0, y: 0 };

function render() {
    timers.forEach(t => clearTimeout(t));
    timers = [];
    timerCountdowns = {};
    hiding = {};
    rendered = {};
    draggedElem = null;
    
    const s = STEPS.find(x => x.id === current);
    if (!s) return;
    
    if (s.password) {
        const pwd = prompt("Password:");
        if (pwd !== s.password) {
            if (s.wrongPasswordStep) { current = s.wrongPasswordStep; render(); return; }
            else { alert("Wrong!"); return; }
        }
    }
    
    visible = {};
    s.elements.forEach(e => {
        visible[e.id] = e.visible;
        if (e.visible && e.duration && e.duration > 0) {
            const t = setTimeout(() => hideElem(e.id), e.duration * 1000);
            timers.push(t);
        }
        if (e.type === "timer" && e.visible) startTimer(e.id, e.countdown);
    });
    
    s.events.forEach(ev => {
        if (checkCond(ev.condition)) {
            if (ev.trigger.type === "onLoad") exec(ev.actions);
            else if (ev.trigger.type === "afterDelay") {
                const t = setTimeout(() => exec(ev.actions), (ev.trigger.delay || 0) * 1000);
                timers.push(t);
            }
        }
    });
    
    fullDraw();
    
    setTimeout(() => {
        const vids = document.querySelectorAll("video");
        vids.forEach(v => {
            const elem = s.elements.find(e => e.content && v.src.includes(e.content));
            if (elem) {
                v.onended = () => {
                    s.events.forEach(ev => {
                        if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === elem.id && checkCond(ev.condition)) exec(ev.actions);
                    });
                };
            }
        });
    }, 100);
}

function startTimer(id, countdown) {
    let rem = countdown;
    timerCountdowns[id] = rem;
    const int = setInterval(() => {
        rem--;
        timerCountdowns[id] = rem;
        const timerDiv = document.querySelector('[data-elem-id="' + id + '"] .elem-timer');
        if (timerDiv) timerDiv.textContent = rem;
        if (rem <= 0) {
            clearInterval(int);
            const s = STEPS.find(x => x.id === current);
            s.events.forEach(ev => {
                if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    }, 1000);
    timers.push(int);
}

function hideElem(id) {
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    const elemDiv = document.querySelector('[data-elem-id="' + id + '"]');
    
    if (!elemDiv) {
        visible[id] = false;
        delete rendered[id];
        return;
    }
    
    const audio = elemDiv.querySelector('audio');
    const video = elemDiv.querySelector('video');
    if (audio) { audio.pause(); audio.currentTime = 0; }
    if (video) { video.pause(); video.currentTime = 0; }
    
    if (elem && elem.transition && elem.transition !== "none") {
        hiding[id] = true;
        elemDiv.className = elemDiv.className.replace(/\\btrans-[\\w-]+\\b/g, '').trim() + ' trans-' + elem.transition + '-out';
        elemDiv.style.animationDuration = (elem.transitionDuration || 0.5) + 's';
        setTimeout(() => {
            visible[id] = false;
            hiding[id] = false;
            delete rendered[id];
            if (elemDiv.parentNode) elemDiv.remove();
        }, (elem.transitionDuration || 0.5) * 1000);
    } else {
        visible[id] = false;
        delete rendered[id];
        elemDiv.remove();
    }
}

function showElem(id) {
    if (visible[id] && rendered[id]) return;
    visible[id] = true;
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    if (elem) {
        if (elem.type === "timer") startTimer(id, elem.countdown);
        if (elem.duration && elem.duration > 0) {
            const t = setTimeout(() => hideElem(id), elem.duration * 1000);
            timers.push(t);
        }
        addElement(elem, true);
    }
}

function checkCond(c) {
    if (!c) return true;
    if (c.type === "hasItem") return inventory.includes(c.item);
    if (c.type === "notHasItem") return !inventory.includes(c.item);
    return true;
}

function exec(acts) {
    acts.forEach(a => {
        if (a.type === "show" || a.type === "showDelay") {
            const delay = (a.type === "showDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => showElem(t), delay); });
        } else if (a.type === "hide" || a.type === "hideDelay") {
            const delay = (a.type === "hideDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => hideElem(t), delay); });
        } else if (a.type === "goto") {
            if (a.targets && a.targets.length > 0) current = a.targets[Math.floor(Math.random() * a.targets.length)];
            else if (a.target) current = a.target;
            render();
            return;
        } else if (a.type === "addItem" && !inventory.includes(a.target)) inventory.push(a.target);
        else if (a.type === "removeItem") inventory = inventory.filter(x => x !== a.target);
    });
    updateInventory();
}

function createElemHTML(e, withTransition) {
    const isHiding = hiding[e.id];
    const transClass = withTransition && e.transition && e.transition !== "none" && !isHiding ? " trans-" + e.transition : (isHiding ? " trans-" + e.transition + "-out" : "");
    const transDur = e.transitionDuration || 0.5;
    const style = "left:" + e.x + "px;top:" + e.y + "px;width:" + e.width + "px;height:" + e.height + "px;z-index:" + e.layer + (e.shape === "circle" ? ";border-radius:50%" : "") + ";animation-duration:" + transDur + "s";
    const mousedown = e.type === "draggable" ? ' onmousedown="handleDragStart(event, \\'' + e.id + '\\')"' : "";
    const click = (e.type === "button" || (e.type === "hotspot" && e.hotspotMode !== "drop")) ? ' onclick="handleClick(\\'' + e.id + '\\')"' : "";
    const hotspotClass = (e.type === "hotspot" && e.showInGame) ? " elem-hotspot-visible" : "";
    
    let h = '<div class="elem' + (e.type === "draggable" ? " elem-draggable" : "") + hotspotClass + transClass + '" data-elem-id="' + e.id + '" style="' + style + '"' + mousedown + click + '>';
    if (e.type === "image" && e.content) h += '<img src="' + e.content + '">';
    if (e.type === "video" && e.content) h += '<video ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop' : '') + '><source src="' + e.content + '"></video>';
    if (e.type === "text") h += '<div class="elem-text" style="font-size:' + (e.textSize || 24) + 'px;color:' + (e.textColor || "#ffffff") + ';background:' + (e.textBgColor || "rgba(0,0,0,0.8)") + '">' + e.content + '</div>';
    if (e.type === "button") h += '<div class="elem-button" style="background:' + e.color + '">' + (e.content || "Button") + '</div>';
    if (e.type === "audio" && e.content) h += '<audio ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop' : '') + '><source src="' + e.content + '"></audio>';
    if (e.type === "timer") h += '<div class="elem-timer">' + (timerCountdowns[e.id] !== undefined ? timerCountdowns[e.id] : e.countdown) + '</div>';
    if (e.type === "draggable") {
        if (e.contentType === "image" && e.content) h += '<img src="' + e.content + '">';
        else h += '<div style="font-size:' + e.fontSize + 'px;color:#fff;pointer-events:none">' + (e.content || "ðŸ“¦") + '</div>';
    }
    h += '</div>';
    return h;
}

function addElement(e, withTransition) {
    if (!e || rendered[e.id]) return;
    const game = document.getElementById("game");
    const s = STEPS.find(x => x.id === current);
    const temp = document.createElement('div');
    temp.innerHTML = createElemHTML(e, withTransition);
    const newElem = temp.firstChild;
    
    const existingElems = Array.from(game.querySelectorAll('[data-elem-id]'));
    let inserted = false;
    for (const existing of existingElems) {
        const existingE = s.elements.find(el => el.id === existing.getAttribute('data-elem-id'));
        if (existingE && existingE.layer > e.layer) {
            game.insertBefore(newElem, existing);
            inserted = true;
            break;
        }
    }
    if (!inserted) game.appendChild(newElem);
    rendered[e.id] = true;
}

function fullDraw() {
    const s = STEPS.find(x => x.id === current);
    const game = document.getElementById("game");
    game.style.background = s.bgColor || "#000";
    let h = "";
    
    if (s.bgShapes) {
        s.bgShapes.forEach(sh => {
            h += '<div style="position:absolute;left:' + sh.x + 'px;top:' + sh.y + 'px;width:' + sh.width + 'px;height:' + sh.height + 'px;background:' + sh.color + ';border-radius:' + (sh.type === "circle" ? "50%" : "0") + ';z-index:0"></div>';
        });
    }
    
    s.elements.filter(e => visible[e.id] || hiding[e.id]).sort((a, b) => a.layer - b.layer).forEach(e => {
        h += createElemHTML(e, true);
        rendered[e.id] = true;
    });
    
    game.innerHTML = h;
    updateInventory();
}

function updateInventory() {
    const inv = document.getElementById("inventory");
    const visInv = inventory.filter(item => {
        const invItem = INVENTORY_ITEMS.find(i => (i.name || i) === item);
        return !invItem || (typeof invItem === "string") || invItem.visible;
    });
    if (visInv.length > 0) {
        inv.style.display = "flex";
        inv.innerHTML = visInv.map(x => '<div style="width:40px;height:40px;background:#f7931a;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px">' + x[0] + '</div>').join("");
    } else {
        inv.style.display = "none";
    }
}

function handleDragStart(ev, elemId) {
    ev.preventDefault();
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === elemId);
    if (!elem) return;
    draggedElem = elem;
    const rect = ev.target.getBoundingClientRect();
    const canvas = document.getElementById("game");
    const canvasRect = canvas.getBoundingClientRect();
    dragOffset.x = ev.clientX - rect.left;
    dragOffset.y = ev.clientY - rect.top;
    dragPos.x = ev.clientX - canvasRect.left;
    dragPos.y = ev.clientY - canvasRect.top;
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
}

function handleDragMove(ev) {
    if (!draggedElem) return;
    ev.preventDefault();
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    dragPos.x = ev.clientX - rect.left;
    dragPos.y = ev.clientY - rect.top;
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = (dragPos.x - dragOffset.x) + 'px';
        draggedDiv.style.top = (dragPos.y - dragOffset.y) + 'px';
    }
}

function handleDragEnd(ev) {
    if (!draggedElem) return;
    const s = STEPS.find(x => x.id === current);
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    const dropX = ev.clientX - rect.left;
    const dropY = ev.clientY - rect.top;
    s.elements.filter(e => e.type === "hotspot" && visible[e.id] && e.hotspotMode !== "click").forEach(h => {
        if (dropX >= h.x && dropX <= h.x + h.width && dropY >= h.y && dropY <= h.y + h.height) {
            s.events.forEach(ev => {
                if (ev.trigger.type === "onDrop" && ev.trigger.sourceElement === h.id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    });
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = draggedElem.x + 'px';
        draggedDiv.style.top = draggedElem.y + 'px';
    }
    draggedElem = null;
}

function handleClick(id) {
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "onClick" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
    });
}

render();
    <\/script>
</body>
</html>`;
        }

        ReactDOM.render(React.createElement(StoryBuilder), document.getElementById('root'));
    </script>
</body>
</html>
