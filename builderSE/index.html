<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Builder Final</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: #0a0e27; color: #fff; overflow: hidden; }
        .app { display: grid; grid-template-columns: 200px 1fr 340px; grid-template-rows: 55px 1fr; height: 100vh; }
        .header { grid-column: 1/-1; background: #1a1f3a; border-bottom: 2px solid #f7931a; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; }
        .logo { font-size: 1.2rem; font-weight: 900; color: #f7931a; }
        .header-buttons { display: flex; gap: 6px; }
        .btn { padding: 6px 12px; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 11px; white-space: nowrap; }
        .btn-primary { background: #f7931a; color: #000; }
        .btn-secondary { background: #2d3748; color: #fff; }
        .btn-success { background: #10b981; color: #fff; }
        .btn-danger { background: #ef4444; color: #fff; }
        .btn-small { padding: 4px 8px; font-size: 10px; }
        .sidebar { background: #141829; border-right: 1px solid #2d3748; overflow-y: auto; padding: 10px; }
        .sidebar-right { border-left: 1px solid #2d3748; border-right: none; }
        .section-title { font-size: 0.65rem; font-weight: 700; text-transform: uppercase; color: #f7931a; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 2px solid #f7931a; }
        .step-item { background: #1a1f3a; border: 2px solid #2d3748; border-radius: 4px; padding: 6px; margin-bottom: 5px; cursor: move; font-size: 0.8rem; transition: all 0.2s; }
        .step-item:hover { border-color: #f7931a; }
        .step-item.active { border-color: #f7931a; background: #1f2541; }
        .step-item.drag-over { border: 2px dashed #10b981; background: #1e3a32; }
        .step-title { font-weight: 600; }
        .canvas { background: #0a0e27; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .preview-container { transform-origin: center center; }
        .preview { background: #000; position: relative; border: 2px solid #f7931a; }
        .element { position: absolute; cursor: move; border: 2px dashed transparent; }
        .element:hover { border-color: #f7931a; }
        .element.selected { border-color: #10b981; border-style: solid; }
        .element img, .element video { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .element-text { background: rgba(0,0,0,0.8); padding: 15px; border-radius: 6px; color: white; font-size: 1.5rem; text-align: center; word-wrap: break-word; overflow: hidden; white-space: pre-wrap; }
        .element-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; text-align: center; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .element-hotspot { border: 2px solid red; background: rgba(255,0,0,0.1); }
        .element-audio { background: rgba(0,100,200,0.3); border: 2px dashed #00aaff; display: flex; align-items: center; justify-content: center; font-size: 2rem; }
        .element-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .element-draggable { border: 2px dashed #00ff64; display: flex; align-items: center; justify-content: center; cursor: grab; overflow: hidden; }
        .element-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .resize-handle { position: absolute; width: 10px; height: 10px; background: #f7931a; right: -5px; bottom: -5px; cursor: se-resize; }
        .element-label { position: absolute; top: -20px; left: 0; background: #f7931a; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 700; }
        .form-group { margin-bottom: 10px; }
        .form-label { display: block; font-size: 0.65rem; font-weight: 600; text-transform: uppercase; color: #f7931a; margin-bottom: 4px; }
        .form-input, .form-textarea, .form-select { width: 100%; padding: 6px; background: #1a1f3a; border: 2px solid #2d3748; border-radius: 4px; color: #fff; font-size: 11px; }
        .form-textarea { resize: vertical; min-height: 50px; font-family: inherit; }
        .form-checkbox { margin-right: 6px; }
        .tabs { display: flex; gap: 3px; margin-bottom: 10px; border-bottom: 2px solid #2d3748; flex-wrap: wrap; }
        .tab { padding: 6px 8px; background: transparent; border: none; color: #6b7280; cursor: pointer; font-weight: 600; font-size: 0.65rem; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab.active { color: #f7931a; border-bottom-color: #f7931a; }
        .event-item { background: #1a1f3a; border: 1px solid #2d3748; border-radius: 4px; padding: 6px; margin-bottom: 5px; }
        .action-item { background: #0a0e27; padding: 5px; margin-top: 3px; border-radius: 4px; border: 1px solid #2d3748; }
        .condition-box { background: rgba(16, 185, 129, 0.1); border: 1px solid #10b981; padding: 5px; margin-bottom: 5px; border-radius: 4px; }
        .add-btn { width: 100%; padding: 6px; background: #2d3748; border: 1px dashed #6b7280; color: #6b7280; border-radius: 4px; cursor: pointer; font-size: 0.65rem; margin-top: 5px; }
        .add-btn:hover { background: #3d4758; border-color: #f7931a; color: #f7931a; }
        .info-box { background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; padding: 6px; margin-bottom: 10px; font-size: 0.65rem; line-height: 1.3; }
        .play-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 1000; }
        .play-exit { position: absolute; top: 20px; right: 20px; z-index: 1001; }
        .play-canvas { 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .inventory-display { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; display: flex; gap: 10px; z-index: 100; }
        .inventory-item-icon { width: 40px; height: 40px; background: #f7931a; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .trans-fade { animation: fadeIn 0.5s ease-in; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
        .draggable-active { cursor: grabbing !important; opacity: 0.7; z-index: 9999 !important; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0e27; }
        ::-webkit-scrollbar-thumb { background: #2d3748; border-radius: 3px; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 4px; background: #1a1f3a; border-radius: 3px; margin-bottom: 3px; }
        .collapsible-header:hover { background: #252b45; }
        .collapsible-arrow { transition: transform 0.2s; font-size: 10px; }
        .collapsible-arrow.open { transform: rotate(90deg); }
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .collapsible-content.open { max-height: 500px; overflow-y: auto; }
        .element-list-item { padding: 5px 8px; background: #1a1f3a; border: 1px solid #2d3748; border-radius: 3px; margin-bottom: 3px; cursor: pointer; font-size: 0.7rem; display: flex; justify-content: space-between; align-items: center; }
        .element-list-item:hover { border-color: #f7931a; background: #1f2541; }
        .element-list-item.selected { border-color: #10b981; background: #1a3a2e; }
        .element-type-badge { font-size: 0.55rem; padding: 2px 5px; border-radius: 3px; background: #2d3748; color: #9ca3af; }
        .btn-add-event { background: #10b981 !important; color: #fff !important; }
        .btn-add-action { background: #f59e0b !important; color: #000 !important; }
        .event-item { background: #1a1f3a; border: 2px solid #f7931a; border-radius: 6px; padding: 8px; margin-bottom: 8px; }
        .event-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 4px; background: #252b45; border-radius: 4px; margin-bottom: 5px; }
        .event-header:hover { background: #2d3450; }
        .event-drag-handle { cursor: grab; padding: 0 5px; color: #f7931a; }
        .event-drag-handle:active { cursor: grabbing; }
        .event-item.drag-over { border: 2px dashed #10b981; background: #1e3a32; }
        .canvas-grid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .element-object { display: flex; align-items: center; justify-content: center; }
        .snap-indicator { position: absolute; background: rgba(16, 185, 129, 0.3); pointer-events: none; z-index: 9998; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes wobble { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); } 20%, 40%, 60%, 80% { transform: translateX(2px); } }
        @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        .anim-pulse { animation: pulse 1s ease-in-out infinite; }
        .anim-spin { animation: spin 2s linear infinite; }
        .anim-bounce { animation: bounce 0.5s ease-in-out infinite; }
        .anim-wobble { animation: wobble 0.5s ease-in-out infinite; }
        .anim-shake { animation: shake 0.5s ease-in-out infinite; }
        .anim-glow { animation: glow 1.5s ease-in-out infinite; }
        .anim-float { animation: float 2s ease-in-out infinite; }
        @keyframes buttonPulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(247,147,26,0.4); } 50% { transform: scale(1.02); box-shadow: 0 0 10px 3px rgba(247,147,26,0.3); } }
        .anim-buttonPulse { animation: buttonPulse 1.5s ease-in-out infinite; }
        .element-embed { background: rgba(128,0,255,0.2); border: 2px dashed #8800ff; display: flex; align-items: center; justify-content: center; font-size: 1rem; color: #8800ff; flex-direction: column; }
        .folder-item { background: #1a2040; border: 2px solid #4a5568; border-radius: 6px; margin-bottom: 5px; }
        .folder-header { display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; font-size: 0.75rem; }
        .folder-header:hover { background: #252b55; border-radius: 4px; }
        .folder-content { padding-left: 10px; border-left: 2px solid #4a5568; margin-left: 10px; }
        .folder-content.collapsed { display: none; }
        .folder-color-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
        .embed-close-btn { position: absolute; bottom: 10px; right: 10px; width: 30px; height: 30px; background: #ef4444; border: none; border-radius: 50%; color: white; font-size: 16px; cursor: pointer; z-index: 10001; display: flex; align-items: center; justify-content: center; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        const { createElement: e, useState, useEffect, useRef } = React;

        function sanitizeStepName(name) {
            return name.replace(/[^a-zA-Z0-9_-]/g, '_');
        }

        // Generate a stable unique ID that never changes even when title changes
        function generateStableId() {
            return 'step_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function createStep(title, existingSteps) {
            const id = generateStableId();
            return { id, title, elements: [], events: [], password: '', wrongPasswordStep: '', bgColor: '#000000', bgShapes: [], folderId: null };
        }

        function createFolder(name) {
            return {
                id: 'folder_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: name,
                color: '#4a5568',
                parentId: null,
                collapsed: false
            };
        }

        // Stable ID generation system
        function getNextElementId(type, existingElements = []) {
            // Find highest existing number for this type
            let maxNum = 0;
            existingElements.forEach(el => {
                if (el.id && el.id.startsWith(type + '_')) {
                    const num = parseInt(el.id.split('_')[1]);
                    if (!isNaN(num) && num > maxNum) maxNum = num;
                }
            });
            // Return next sequential number
            return type + '_' + (maxNum + 1);
        }

        function createElement2(type, existingElements = []) {
            const baseId = getNextElementId(type, existingElements);
            return {
                id: baseId,
                type: type,
                label: type + '1',
                x: 100,
                y: 100,
                width: type === 'text' || type === 'button' ? 300 : type === 'audio' ? 200 : type === 'timer' ? 150 : type === 'draggable' ? 100 : type === 'object' ? 100 : type === 'embed' ? 400 : 400,
                height: type === 'text' ? 100 : type === 'button' ? 60 : type === 'audio' ? 60 : type === 'timer' ? 150 : type === 'draggable' ? 100 : type === 'object' ? 100 : type === 'embed' ? 300 : 300,
                content: '',
                visible: true,
                layer: 0,
                duration: 0,
                loop: false,
                autoplay: type === 'audio' || type === 'video',
                shape: type === 'object' ? 'rect' : 'rect',
                color: '#f7931a',
                countdown: 10,
                fontSize: 24,
                contentType: 'text',
                hotspotMode: 'both',
                transition: 'none',
                transitionDuration: 0.5,
                transitionOut: 'none',
                transitionOutDuration: 0.5,
                animationDuring: 'none',
                textColor: '#ffffff',
                textBgColor: 'rgba(0,0,0,0.8)',
                textSize: 24,
                buttonTextColor: '#ffffff',
                buttonTextSize: 20,
                buttonShadow: false,
                buttonPulse: false,
                objectShape: 'rect',
                objectColor: '#f7931a',
                scaleX: 1,
                scaleY: 1,
                rotation: 0,
                flipH: false,
                flipV: false,
                opacity: 100,
                textBgOpacity: 80,
                embedUrl: '',
                embedAllowNavigation: false,
                embedThumbnail: '',
                embedCloseDelay: 0,
                // Image crop properties (percentage-based: 0-100)
                cropEnabled: false,
                cropX: 0,
                cropY: 0,
                cropW: 100,
                cropH: 100
            };
        }

        function createEvent() {
            return {
                id: 'event_' + Date.now(),
                trigger: { type: 'onLoad', delay: 0, sourceElement: '' },
                condition: null,
                actions: []
            };
        }

        function StoryBuilder() {
            // Try to load from localStorage on init
            const savedData = localStorage.getItem('storyBuilderAutosave');
            const initialData = savedData ? JSON.parse(savedData) : null;
            
            // Migration: ensure steps have stable IDs
            const migrateSteps = (steps) => {
                if (!steps) return [];
                return steps.map(step => {
                    if (!step.id || !step.id.startsWith('step_')) {
                        return { ...step, id: generateStableId(), folderId: step.folderId || null };
                    }
                    return { ...step, folderId: step.folderId || null };
                });
            };
            
            const [steps, setSteps] = useState(migrateSteps(initialData?.steps) || []);
            const [currentStepId, setCurrentStepId] = useState(initialData?.currentStepId || null);
            const [selectedElementId, setSelectedElementId] = useState(null);
            const [activeTab, setActiveTab] = useState('elements');
            const [collapsedActions, setCollapsedActions] = useState({});
            const [collapsedEvents, setCollapsedEvents] = useState({});
            const [varyingItems, setVaryingItems] = useState(initialData?.varyingItems || []);
            const [snapEnabled, setSnapEnabled] = useState(false);
            const [showGrid, setShowGrid] = useState(true);
            const [clipboard, setClipboard] = useState(null);
            const [draggedEventId, setDraggedEventId] = useState(null);
            const [dragging, setDragging] = useState(null);
            const [playMode, setPlayMode] = useState(false);
            const [playStartStep, setPlayStartStep] = useState(null);
            const [draggedStepId, setDraggedStepId] = useState(null);
            const [dragOverStepId, setDragOverStepId] = useState(null);
            const [scale, setScale] = useState(1);
            const [inventory, setInventory] = useState(initialData?.inventory || []);
            const [draggedInPlay, setDraggedInPlay] = useState(null);
            const [lastSaved, setLastSaved] = useState(null);
            const [folders, setFolders] = useState(initialData?.folders || []);
            const [collapsedFolders, setCollapsedFolders] = useState({});
            const [dragOverFolderId, setDragOverFolderId] = useState(null);
            const [bgmTracks, setBgmTracks] = useState(initialData?.bgmTracks || (initialData?.bgmSettings?.url ? [{ id: 'bgm_1', name: 'BGM 1', url: initialData.bgmSettings.url, loop: initialData.bgmSettings.loop !== false, volume: initialData.bgmSettings.volume || 100 }] : []));
            const [inventorySettings, setInventorySettings] = useState(initialData?.inventorySettings || { 
                position: 'bottom-left', 
                x: 20, 
                y: 20,
                showInventory: true,
                showVarying: true
            });
            const [exportOptions, setExportOptions] = useState({
                includeRefreshButton: false,
                optimizeVideoLoading: false,
                compactLandscape: false,
                fitToViewport: false
            });
            const [previewOnTop, setPreviewOnTop] = useState(false);
            const [savedUrls, setSavedUrls] = useState(initialData?.savedUrls || []);
            const [canvasMode, setCanvasMode] = useState(initialData?.canvasMode || 'landscape');
            const [saveKey, setSaveKey] = useState(initialData?.saveKey || '');
            const canvasRef = useRef(null);
            
            // Canvas dimensions based on mode
            const canvasWidth = canvasMode === 'portrait' ? 576 : 1024;
            const canvasHeight = canvasMode === 'portrait' ? 1024 : 576;

            useEffect(() => {
                const updateScale = () => {
                    if (canvasRef.current) {
                        const container = canvasRef.current.parentElement;
                        const scaleX = (container.clientWidth - 40) / canvasWidth;
                        const scaleY = (container.clientHeight - 40) / canvasHeight;
                        setScale(Math.min(scaleX, scaleY, 1));
                    }
                };
                updateScale();
                window.addEventListener('resize', updateScale);
                return () => window.removeEventListener('resize', updateScale);
            }, [canvasMode]);

            // Autosave to localStorage every 5 seconds when there are changes
            useEffect(() => {
                if (steps.length === 0 && inventory.length === 0 && varyingItems.length === 0) return;
                
                const autosaveTimer = setTimeout(() => {
                    const data = { steps, inventory, varyingItems, currentStepId, folders, bgmTracks, inventorySettings, savedUrls, canvasMode, saveKey };
                    localStorage.setItem('storyBuilderAutosave', JSON.stringify(data));
                    setLastSaved(new Date().toLocaleTimeString());
                }, 2000);
                
                return () => clearTimeout(autosaveTimer);
            }, [steps, inventory, varyingItems, currentStepId, folders, bgmTracks, inventorySettings]);

            const getCurrentStep = () => steps.find(s => s.id === currentStepId);
            const getSelectedElement = () => {
                const step = getCurrentStep();
                return step?.elements.find(el => el.id === selectedElementId);
            };

            const updateStep = (updates) => {
                setSteps(steps.map(s => {
                    if (s.id === currentStepId) {
                        // ID never changes - title is just a display name
                        return { ...s, ...updates };
                    }
                    return s;
                }));
            };

            const updateElement = (elemId, updates) => {
                const step = getCurrentStep();
                if (step) {
                    const elements = step.elements.map(el => {
                        if (el.id === elemId) {
                            const updated = { ...el, ...updates };
                            if (updates.label) {
                                const sameType = step.elements.filter(e => e.type === el.type && e.id !== el.id);
                                const match = updates.label.match(/^(.*?)(\d+)$/);
                                if (match) {
                                    const base = match[1];
                                    let num = parseInt(match[2]);
                                    while (sameType.some(e => e.label === base + num)) {
                                        num++;
                                    }
                                    updated.label = base + num;
                                }
                            }
                            return updated;
                        }
                        return el;
                    });
                    updateStep({ elements });
                }
            };

            const createNewStep = () => {
                const title = prompt('Step name:', 'Step ' + (steps.length + 1));
                if (!title) return;
                const step = createStep(title, steps);
                setSteps([...steps, step]);
                setCurrentStepId(step.id);
            };

            const createNewFolder = () => {
                const name = prompt('Folder name:');
                if (!name) return;
                const folder = createFolder(name);
                setFolders([...folders, folder]);
            };

            const deleteFolder = (folderId) => {
                const folder = folders.find(f => f.id === folderId);
                const stepsInFolder = steps.filter(s => s.folderId === folderId);
                const subFolders = folders.filter(f => f.parentId === folderId);
                
                if (stepsInFolder.length > 0 || subFolders.length > 0) {
                    const choice = prompt('Folder "' + folder.name + '" contains ' + stepsInFolder.length + ' step(s) and ' + subFolders.length + ' subfolder(s).\n\nType:\n  "keep" - delete folder, keep contents\n  "delete" - delete folder and all contents\n  Or press Cancel to abort');
                    
                    if (choice === null) return; // User pressed Cancel
                    
                    if (choice.toLowerCase() === 'keep') {
                        setSteps(steps.map(s => s.folderId === folderId ? { ...s, folderId: folder.parentId } : s));
                        setFolders(folders.filter(f => f.id !== folderId).map(f => f.parentId === folderId ? { ...f, parentId: folder.parentId } : f));
                    } else if (choice.toLowerCase() === 'delete') {
                        const getAllSubFolderIds = (parentId) => {
                            const subIds = folders.filter(f => f.parentId === parentId).map(f => f.id);
                            return subIds.concat(subIds.flatMap(id => getAllSubFolderIds(id)));
                        };
                        const allFolderIds = [folderId, ...getAllSubFolderIds(folderId)];
                        
                        setSteps(steps.filter(s => !allFolderIds.includes(s.folderId)));
                        setFolders(folders.filter(f => !allFolderIds.includes(f.id)));
                    }
                    // Any other input = do nothing (abort)
                } else {
                    if (confirm('Delete empty folder "' + folder.name + '"?')) {
                        setFolders(folders.filter(f => f.id !== folderId));
                    }
                }
            };

            const renameFolder = (folderId) => {
                const folder = folders.find(f => f.id === folderId);
                const newName = prompt('Rename folder:', folder.name);
                if (newName && newName !== folder.name) {
                    setFolders(folders.map(f => f.id === folderId ? { ...f, name: newName } : f));
                }
            };

            const handleFolderDrop = (e, folderId) => {
                e.preventDefault();
                e.stopPropagation();
                if (draggedStepId) {
                    // Don't allow first step to be in folder
                    if (steps[0]?.id === draggedStepId && folderId !== null) {
                        alert('The first step must remain at the top level and cannot be moved to a folder.');
                        setDraggedStepId(null);
                        setDragOverFolderId(null);
                        return;
                    }
                    setSteps(steps.map(s => s.id === draggedStepId ? { ...s, folderId } : s));
                }
                setDraggedStepId(null);
                setDragOverFolderId(null);
            };

            const handleStepDragStart = (e, stepId) => {
                setDraggedStepId(stepId);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleStepDragOver = (e, stepId) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                if (stepId !== draggedStepId) {
                    setDragOverStepId(stepId);
                }
            };

            const handleStepDrop = (e, targetStepId) => {
                e.preventDefault();
                if (!draggedStepId || draggedStepId === targetStepId) {
                    setDraggedStepId(null);
                    setDragOverStepId(null);
                    return;
                }

                const draggedIndex = steps.findIndex(s => s.id === draggedStepId);
                const targetIndex = steps.findIndex(s => s.id === targetStepId);
                
                const newSteps = [...steps];
                const [draggedStep] = newSteps.splice(draggedIndex, 1);
                newSteps.splice(targetIndex, 0, draggedStep);
                
                setSteps(newSteps);
                setDraggedStepId(null);
                setDragOverStepId(null);
            };

            const handleStepDragEnd = () => {
                setDraggedStepId(null);
                setDragOverStepId(null);
            };

            const addElement = (type) => {
                const step = getCurrentStep();
                if (step) {
                    const elem = createElement2(type, step.elements);
                    const sameType = step.elements.filter(e => e.type === type);
                    elem.label = type + (sameType.length + 1);
                    updateStep({ elements: [...step.elements, elem] });
                    setSelectedElementId(elem.id);
                }
            };

            const deleteElement = (elemId) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ elements: step.elements.filter(el => el.id !== elemId) });
                    if (selectedElementId === elemId) setSelectedElementId(null);
                }
            };

            const addInventoryItem = () => {
                const name = prompt('Inventory item name:');
                if (name && !inventory.find(i => (i.name || i) === name)) {
                    setInventory([...inventory, { name: name, visible: true, displayName: name }]);
                }
            };

            const deleteInventoryItem = (item) => {
                const itemName = item.name || item;
                setInventory(inventory.filter(i => (i.name || i) !== itemName));
            };

            const addVaryingItem = () => {
                const name = prompt('Varying item name (e.g., dollars, points, friends):');
                if (name && !varyingItems.find(i => i.name === name)) {
                    setVaryingItems([...varyingItems, { name: name, visible: true }]);
                }
            };

            const deleteVaryingItem = (item) => {
                setVaryingItems(varyingItems.filter(i => i.name !== item.name));
            };

            const toggleActionCollapse = (actionKey) => {
                setCollapsedActions(prev => ({ ...prev, [actionKey]: !prev[actionKey] }));
                
                // Auto-clean phantom targets when opening the menu
                const [eventId, actionId] = actionKey.split('_');
                const step = getCurrentStep();
                if (!step) return;
                
                const event = step.events.find(ev => ev.id === eventId);
                if (!event) return;
                
                const action = event.actions.find(a => a.id === actionId);
                if (!action || !action.targets) return;
                
                // For goto actions, validate against step IDs
                // For other actions, validate against element IDs
                let validIds;
                if (action.type === 'goto') {
                    validIds = steps.map(s => s.id);
                } else {
                    validIds = step.elements.map(el => el.id);
                }
                
                // Filter out phantom IDs (deleted elements/steps)
                const cleanedTargets = action.targets.filter(t => validIds.includes(t));
                
                // If we removed phantom targets, update the action
                if (cleanedTargets.length !== action.targets.length) {
                    updateEventAction(eventId, actionId, { 
                        targets: cleanedTargets.length > 0 ? cleanedTargets : undefined,
                        target: cleanedTargets.length === 0 ? '' : action.target
                    });
                }
            };

            const toggleEventCollapse = (eventId) => {
                setCollapsedEvents(prev => ({ ...prev, [eventId]: !prev[eventId] }));
            };

            const copyElement = (elem) => {
                setClipboard({ ...elem, id: null });
            };

            const pasteElement = () => {
                if (!clipboard) return;
                const step = getCurrentStep();
                if (!step) return;
                const newElem = {
                    ...clipboard,
                    id: getNextElementId(clipboard.type, step.elements),
                    label: clipboard.label + '_copy',
                    x: clipboard.x + 20,
                    y: clipboard.y + 20
                };
                setSteps(steps.map(s => s.id === currentStepId ? { ...s, elements: [...s.elements, newElem] } : s));
                setSelectedElementId(newElem.id);
            };

            const snapToGrid = (value, gridSize = 51.2) => {
                return Math.round(value / gridSize) * gridSize;
            };

            const handleEventDragStart = (ev, eventId) => {
                setDraggedEventId(eventId);
                ev.dataTransfer.effectAllowed = 'move';
            };

            const handleEventDragOver = (ev, eventId) => {
                ev.preventDefault();
                ev.dataTransfer.dropEffect = 'move';
            };

            const handleEventDrop = (ev, targetEventId) => {
                ev.preventDefault();
                if (!draggedEventId || draggedEventId === targetEventId) return;
                
                const events = [...currentStep.events];
                const dragIdx = events.findIndex(e => e.id === draggedEventId);
                const dropIdx = events.findIndex(e => e.id === targetEventId);
                
                if (dragIdx === -1 || dropIdx === -1) return;
                
                const [draggedEvent] = events.splice(dragIdx, 1);
                events.splice(dropIdx, 0, draggedEvent);
                
                setSteps(steps.map(s => s.id === currentStepId ? { ...s, events } : s));
                setDraggedEventId(null);
            };

            const handleEventDragEnd = () => {
                setDraggedEventId(null);
            };

            const addEvent = () => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ events: [...step.events, createEvent()] });
                }
            };

            const updateEvent = (eventId, updates) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({
                        events: step.events.map(ev => ev.id === eventId ? { ...ev, ...updates } : ev)
                    });
                }
            };

            const deleteEvent = (eventId) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ events: step.events.filter(ev => ev.id !== eventId) });
                }
            };

            const addEventAction = (eventId) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: [...event.actions, { id: 'action_' + Date.now(), type: 'show', target: '', value: '' }]
                    });
                }
            };

            const updateEventAction = (eventId, actionId, updates) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: event.actions.map(a => a.id === actionId ? { ...a, ...updates } : a)
                    });
                }
            };

            const deleteEventAction = (eventId, actionId) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: event.actions.filter(a => a.id !== actionId)
                    });
                }
            };

            const handleMouseDown = (ev, elemId) => {
                const elem = currentStep?.elements.find(e => e.id === elemId);
                if (ev.target.classList.contains('resize-handle')) {
                    setDragging({ type: 'resize', elemId });
                } else {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = (ev.clientX - rect.left) / scale;
                    const mouseY = (ev.clientY - rect.top) / scale;
                    setDragging({ 
                        type: 'move', 
                        elemId, 
                        offsetX: mouseX - (elem?.x || 0),
                        offsetY: mouseY - (elem?.y || 0)
                    });
                }
                setSelectedElementId(elemId);
            };

            const handleMouseMove = (ev) => {
                if (!dragging) return;
                const elem = getSelectedElement();
                if (!elem) return;

                if (dragging.type === 'move') {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    // Calculate absolute position from mouse
                    let newX = (ev.clientX - rect.left) / scale - dragging.offsetX;
                    let newY = (ev.clientY - rect.top) / scale - dragging.offsetY;
                    // Clamp to canvas bounds (use canvasWidth/canvasHeight for portrait support)
                    newX = Math.max(0, Math.min(canvasWidth - elem.width, newX));
                    newY = Math.max(0, Math.min(canvasHeight - elem.height, newY));
                    if (snapEnabled) {
                        newX = snapToGrid(newX);
                        newY = snapToGrid(newY);
                    }
                    updateElement(elem.id, { x: newX, y: newY });
                } else if (dragging.type === 'resize') {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    let newWidth = Math.max(50, Math.min(canvasWidth - elem.x, (ev.clientX - rect.left) / scale - elem.x));
                    let newHeight = Math.max(50, Math.min(canvasHeight - elem.y, (ev.clientY - rect.top) / scale - elem.y));
                    if (snapEnabled) {
                        newWidth = snapToGrid(newWidth);
                        newHeight = snapToGrid(newHeight);
                    }
                    updateElement(elem.id, { width: newWidth, height: newHeight });
                }
            };

            const handleMouseUp = () => setDragging(null);

            useEffect(() => {
                if (dragging) {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [dragging, scale]);

            const newProject = () => {
                if (steps.length > 0 && !confirm('Start a new project? This will clear current work.\n\n(Your work is autosaved, but starting new will clear it)')) {
                    return;
                }
                setSteps([]);
                setCurrentStepId(null);
                setSelectedElementId(null);
                setInventory([]);
                setVaryingItems([]);
                setFolders([]);
                setBgmSettings({ url: '', loop: true, volume: 100 });
                setInventorySettings({ position: 'bottom-left', x: 20, y: 20, showInventory: true, showVarying: true });
                localStorage.removeItem('storyBuilderAutosave');
                setLastSaved(null);
            };

            const saveProject = () => {
                const data = JSON.stringify({ steps, inventory, varyingItems, folders, bgmTracks, inventorySettings, savedUrls, canvasMode, saveKey }, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'story.json';
                a.click();
            };

            const loadProject = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (ev) => {
                    const file = ev.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            
                            // Migration: add stable IDs to old steps and ensure folderId exists
                            const migratedSteps = data.steps.map(step => {
                                const migrated = { ...step };
                                if (!step.id || !step.id.startsWith('step_')) {
                                    migrated.id = generateStableId();
                                }
                                if (migrated.folderId === undefined) {
                                    migrated.folderId = null;
                                }
                                return migrated;
                            });
                            
                            // Validate: Find broken event references
                            const brokenRefs = [];
                            migratedSteps.forEach(step => {
                                const elementIds = step.elements.map(el => el.id);
                                step.events.forEach(ev => {
                                    // Check trigger source element
                                    if (ev.trigger.sourceElement && !elementIds.includes(ev.trigger.sourceElement)) {
                                        brokenRefs.push({
                                            step: step.title,
                                            issue: 'Event trigger references missing element: ' + ev.trigger.sourceElement
                                        });
                                    }
                                    // Check action targets
                                    ev.actions.forEach(action => {
                                        if (action.target && !elementIds.includes(action.target) && action.type !== 'goto' && action.type !== 'inventory' && action.type !== 'password' && action.type !== 'addItem' && action.type !== 'removeItem' && action.type !== 'bgmPlay' && action.type !== 'bgmStop' && action.type !== 'showInventory' && action.type !== 'hideInventory' && action.type !== 'showInvItem' && action.type !== 'hideInvItem' && action.type !== 'showVarying' && action.type !== 'hideVarying' && action.type !== 'showVaryItem' && action.type !== 'hideVaryItem') {
                                            brokenRefs.push({
                                                step: step.title,
                                                issue: 'Event action references missing element: ' + action.target
                                            });
                                        }
                                    });
                                });
                            });
                            
                            // If broken references found, warn user
                            if (brokenRefs.length > 0) {
                                const msg = 'WARNING: Found events referencing missing elements:\n\n' + 
                                    brokenRefs.slice(0, 10).map(r => 'â€¢ ' + r.step + ': ' + r.issue).join('\n') +
                                    (brokenRefs.length > 10 ? '\n\n...and ' + (brokenRefs.length - 10) + ' more issues' : '') +
                                    '\n\nThese broken events may cause buttons to not work.\n\nOptions:\n' +
                                    '- Click OK to load anyway (you can manually fix broken events)\n' +
                                    '- Click Cancel to abort import';
                                    
                                if (!confirm(msg)) {
                                    return;
                                }
                            }
                            
                            // Migrate inventory items to new format with displayName
                            const migratedInventory = (data.inventory || []).map(item => {
                                if (typeof item === 'string') {
                                    return { name: item, visible: true, displayName: item };
                                }
                                return { ...item, displayName: item.displayName || item.name };
                            });
                            
                            // Migrate varying items
                            const migratedVarying = (data.varyingItems || []).map(item => ({
                                ...item,
                                displayName: item.displayName || item.name
                            }));
                            
                            setSteps(migratedSteps);
                            setInventory(migratedInventory);
                            setVaryingItems(migratedVarying);
                            setFolders(data.folders || []);
                            // Migrate old bgmSettings to new bgmTracks format
                            if (data.bgmTracks) {
                                setBgmTracks(data.bgmTracks);
                            } else if (data.bgmSettings && data.bgmSettings.url) {
                                setBgmTracks([{ id: 'bgm_1', name: 'BGM 1', url: data.bgmSettings.url, loop: data.bgmSettings.loop !== false, volume: data.bgmSettings.volume || 100 }]);
                            } else {
                                setBgmTracks([]);
                            }
                            setInventorySettings(data.inventorySettings || { position: 'bottom-left', x: 20, y: 20, showInventory: true, showVarying: true });
                            setSavedUrls(data.savedUrls || []);
                            setCanvasMode(data.canvasMode || 'landscape');
                            setSaveKey(data.saveKey || '');
                            setCurrentStepId(migratedSteps[0]?.id);
                            alert(brokenRefs.length > 0 ? 'Loaded with warnings! Check events on steps with issues.' : 'Loaded successfully!');
                        } catch (err) {
                            alert('Error: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const cleanPhantomReferences = () => {
                if (!confirm('This will scan all events and remove references to deleted elements and steps. Continue?')) {
                    return;
                }
                
                let totalCleaned = 0;
                const validStepIds = steps.map(s => s.id);
                
                const newSteps = steps.map(step => {
                    const validElementIds = step.elements.map(el => el.id);
                    const cleanedEvents = step.events.map(event => {
                        const cleanedActions = event.actions.map(action => {
                            if (!action.targets && !action.target) return action;
                            
                            // For goto actions, validate against step IDs
                            // For other actions, validate against element IDs
                            const validIds = action.type === 'goto' ? validStepIds : validElementIds;
                            
                            // Clean targets array
                            if (action.targets) {
                                const originalLength = action.targets.length;
                                const cleanedTargets = action.targets.filter(t => validIds.includes(t));
                                totalCleaned += originalLength - cleanedTargets.length;
                                
                                return {
                                    ...action,
                                    targets: cleanedTargets.length > 0 ? cleanedTargets : undefined,
                                    target: cleanedTargets.length === 0 ? '' : action.target
                                };
                            }
                            
                            // Clean single target
                            if (action.target && !validIds.includes(action.target)) {
                                totalCleaned += 1;
                                return { ...action, target: '' };
                            }
                            
                            return action;
                        });
                        
                        // Also clean trigger sourceElement if it's invalid
                        let cleanedTrigger = event.trigger;
                        if (event.trigger.sourceElement && !validElementIds.includes(event.trigger.sourceElement)) {
                            totalCleaned += 1;
                            cleanedTrigger = { ...event.trigger, sourceElement: '' };
                        }
                        
                        return { ...event, actions: cleanedActions, trigger: cleanedTrigger };
                    });
                    
                    return { ...step, events: cleanedEvents };
                });
                
                setSteps(newSteps);
                alert(`âœ… Cleaned ${totalCleaned} phantom reference(s)!`);
            };


            const exportHTML = () => {
                const html = generateHTML(steps, inventory, varyingItems, exportOptions, bgmTracks, inventorySettings, canvasMode, saveKey);
                navigator.clipboard.writeText(html).then(() => {
                    alert('âœ… HTML copied!');
                }).catch(() => {
                    const textarea = document.createElement('textarea');
                    textarea.value = html;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('âœ… HTML copied!');
                });
            };

            if (playMode) {
                return e(PlayMode, { steps, inventory, varyingItems, onExit: () => setPlayMode(false), startStepId: playStartStep || currentStepId, bgmTracks, inventorySettings, canvasMode });
            }

            const currentStep = getCurrentStep();
            const selectedElement = getSelectedElement();

            // Helper function to render a step item
            const renderStepItem = (step, isFirst = false) => {
                const actualFirst = steps[0]?.id === step.id;
                return e('div', {
                    key: step.id,
                    className: 'step-item' + (step.id === currentStepId ? ' active' : '') + (step.id === dragOverStepId ? ' drag-over' : ''),
                    draggable: !actualFirst,
                    onDragStart: actualFirst ? undefined : (ev) => handleStepDragStart(ev, step.id),
                    onDragOver: (ev) => handleStepDragOver(ev, step.id),
                    onDrop: (ev) => handleStepDrop(ev, step.id),
                    onDragEnd: handleStepDragEnd,
                    style: { opacity: step.id === draggedStepId ? 0.5 : 1 }
                },
                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', flex: 1 } },
                            !actualFirst && e('div', { style: { cursor: 'grab', fontSize: '12px', opacity: 0.5 } }, 'â˜°'),
                            actualFirst && e('div', { style: { fontSize: '12px' } }, 'ðŸ '),
                            e('div', { className: 'step-title', onClick: () => { setCurrentStepId(step.id); setSelectedElementId(null); }, style: { flex: 1, cursor: 'pointer' } }, step.title)
                        ),
                        e('div', { style: { display: 'flex', gap: '3px' } },
                            e('button', { 
                                className: 'btn btn-secondary btn-small', 
                                onClick: (ev) => {
                                    ev.stopPropagation();
                                    setPlayStartStep(step.id);
                                    setPlayMode(true);
                                },
                                style: { padding: '2px 4px', fontSize: '10px' },
                                title: 'Play from here'
                            }, 'â–¶'),
                            e('button', { 
                                className: 'btn btn-success btn-small', 
                                onClick: (ev) => {
                                    ev.stopPropagation();
                                    const clonedStep = JSON.parse(JSON.stringify(step));
                                    clonedStep.id = generateStableId();
                                    clonedStep.title = step.title + ' 2';
                                    clonedStep.folderId = step.folderId;
                                    const insertIndex = steps.findIndex(s => s.id === step.id) + 1;
                                    setSteps([...steps.slice(0, insertIndex), clonedStep, ...steps.slice(insertIndex)]);
                                },
                                style: { padding: '2px 4px', fontSize: '10px' },
                                title: 'Duplicate'
                            }, 'ðŸ“‹'),
                            !actualFirst && e('button', { 
                                className: 'btn btn-danger btn-small', 
                                onClick: (ev) => {
                                    ev.stopPropagation();
                                    if (confirm('Delete "' + step.title + '"?')) {
                                        const newSteps = steps.filter(s => s.id !== step.id);
                                        setSteps(newSteps);
                                        if (currentStepId === step.id) {
                                            setCurrentStepId(newSteps[0]?.id);
                                        }
                                    }
                                },
                                style: { padding: '2px 4px', fontSize: '10px' },
                                title: 'Delete'
                            }, 'Ã—')
                        )
                    )
                );
            };

            return e('div', { className: 'app' },
                e('header', { className: 'header' },
                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '15px' } },
                        e('div', { className: 'logo' }, 'Builder'),
                        lastSaved && e('div', { style: { fontSize: '0.6rem', color: '#10b981' } }, 'âœ“ Saved ' + lastSaved)
                    ),
                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '10px', fontSize: '11px' } },
                        e('label', { style: { display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', whiteSpace: 'nowrap' } },
                            e('input', { 
                                type: 'checkbox', 
                                checked: exportOptions.includeRefreshButton,
                                onChange: (ev) => setExportOptions({ ...exportOptions, includeRefreshButton: ev.target.checked })
                            }),
                            'ðŸ”„ Refresh Button'
                        ),
                        e('label', { style: { display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', whiteSpace: 'nowrap' } },
                            e('input', { 
                                type: 'checkbox', 
                                checked: exportOptions.optimizeVideoLoading,
                                onChange: (ev) => setExportOptions({ ...exportOptions, optimizeVideoLoading: ev.target.checked })
                            }),
                            'ðŸ“¦ Compress'
                        ),
                        e('label', { style: { display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', whiteSpace: 'nowrap' } },
                            e('input', { 
                                type: 'checkbox', 
                                checked: exportOptions.compactLandscape,
                                onChange: (ev) => setExportOptions({ ...exportOptions, compactLandscape: ev.target.checked })
                            }),
                            'ðŸ“± 85% Landscape'
                        ),
                        e('label', { style: { display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer', whiteSpace: 'nowrap' } },
                            e('input', { 
                                type: 'checkbox', 
                                checked: exportOptions.fitToViewport,
                                onChange: (ev) => setExportOptions({ ...exportOptions, fitToViewport: ev.target.checked })
                            }),
                            'ðŸ–¥ï¸ Fit Viewport'
                        )
                    ),
                    e('div', { className: 'header-buttons' },
                        e('button', { 
                            className: 'btn ' + (showGrid ? 'btn-primary' : 'btn-secondary'), 
                            onClick: () => setShowGrid(!showGrid), 
                            title: 'Toggle Grid',
                            style: { fontSize: '10px' }
                        }, 'âŠž'),
                        e('button', { 
                            className: 'btn ' + (snapEnabled ? 'btn-success' : 'btn-secondary'), 
                            onClick: () => setSnapEnabled(!snapEnabled), 
                            title: 'Toggle Snap to Grid',
                            style: { fontSize: '10px' }
                        }, 'ðŸ§²'),
                        e('button', { className: 'btn btn-primary', onClick: () => { setPlayStartStep(steps[0]?.id); setPlayMode(true); }, title: 'Test All Steps' }, 'â–¶ All'),
                        e('button', { className: 'btn btn-primary', onClick: () => { setPlayStartStep(currentStepId); setPlayMode(true); }, title: 'Preview Current Step', style: { background: '#10b981' } }, 'â–¶ Step'),
                        e('button', { className: 'btn btn-danger', onClick: newProject, title: 'New Project' }, 'ðŸ—‘ï¸'),
                        e('button', { className: 'btn btn-secondary', onClick: cleanPhantomReferences, title: 'Clean Phantom References', style: { fontSize: '10px' } }, 'ðŸ§¹'),
                        e('button', { className: 'btn btn-secondary', onClick: saveProject, title: 'Save to File' }, 'ðŸ’¾'),
                        e('button', { className: 'btn btn-secondary', onClick: loadProject, title: 'Load from File' }, 'ðŸ“‚'),
                        e('button', { className: 'btn btn-success', onClick: exportHTML, title: 'Export HTML' }, 'âš¡')
                    )
                ),
                
                e('aside', { className: 'sidebar' },
                    e('div', { className: 'section-title' }, 'Steps'),
                    e('div', { style: { display: 'flex', gap: '3px', marginBottom: '6px' } },
                        e('button', { className: 'btn btn-primary btn-small', style: { flex: 1 }, onClick: createNewStep }, '+ Step'),
                        e('button', { className: 'btn btn-secondary btn-small', onClick: createNewFolder, title: 'New Folder' }, 'ðŸ“')
                    ),
                    // Root drop area (drag steps here to remove from folder)
                    e('div', {
                        style: { 
                            minHeight: draggedStepId ? '30px' : '10px',
                            background: dragOverFolderId === 'root' ? 'rgba(16, 185, 129, 0.3)' : (draggedStepId ? 'rgba(255,255,255,0.05)' : 'transparent'),
                            borderRadius: '4px',
                            marginBottom: '5px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '0.6rem',
                            color: '#6b7280',
                            border: draggedStepId ? '1px dashed #4a5568' : 'none'
                        },
                        onDragOver: (ev) => { ev.preventDefault(); setDragOverFolderId('root'); },
                        onDragLeave: () => setDragOverFolderId(null),
                        onDrop: (ev) => handleFolderDrop(ev, null)
                    }, draggedStepId ? 'â†‘ Drop here to remove from folder' : null),
                    // Render folders
                    folders.filter(f => !f.parentId).map(folder => {
                        const stepsInFolder = steps.filter(s => s.folderId === folder.id);
                        const isCollapsed = collapsedFolders[folder.id];
                        return e('div', { 
                            key: folder.id, 
                            className: 'folder-item',
                            style: { borderColor: folder.color }
                        },
                            e('div', { 
                                className: 'folder-header',
                                style: { background: dragOverFolderId === folder.id ? 'rgba(16, 185, 129, 0.2)' : 'transparent' },
                                onDragOver: (ev) => { ev.preventDefault(); setDragOverFolderId(folder.id); },
                                onDragLeave: () => setDragOverFolderId(null),
                                onDrop: (ev) => handleFolderDrop(ev, folder.id)
                            },
                                e('span', { 
                                    className: 'folder-color-dot',
                                    style: { background: folder.color }
                                }),
                                e('span', { 
                                    style: { flex: 1, cursor: 'pointer' },
                                    onClick: () => setCollapsedFolders({ ...collapsedFolders, [folder.id]: !isCollapsed })
                                }, 
                                    (isCollapsed ? 'â–¶ ' : 'â–¼ ') + folder.name + ' (' + stepsInFolder.length + ')'
                                ),
                                e('input', {
                                    type: 'color',
                                    value: folder.color,
                                    onChange: (ev) => setFolders(folders.map(f => f.id === folder.id ? { ...f, color: ev.target.value } : f)),
                                    style: { width: '18px', height: '18px', padding: 0, border: 'none', cursor: 'pointer' },
                                    onClick: (ev) => ev.stopPropagation()
                                }),
                                e('button', { 
                                    className: 'btn btn-secondary btn-small',
                                    style: { padding: '2px 4px', fontSize: '10px' },
                                    onClick: (ev) => { ev.stopPropagation(); renameFolder(folder.id); },
                                    title: 'Rename folder'
                                }, 'âœï¸'),
                                e('button', { 
                                    className: 'btn btn-danger btn-small',
                                    style: { padding: '2px 4px', fontSize: '10px' },
                                    onClick: (ev) => { ev.stopPropagation(); deleteFolder(folder.id); },
                                    title: 'Delete folder'
                                }, 'Ã—')
                            ),
                            !isCollapsed && e('div', { className: 'folder-content' },
                                stepsInFolder.map(step => renderStepItem(step))
                            )
                        );
                    }),
                    // Steps without folder (except first step which is handled specially)
                    steps.filter(s => !s.folderId).map((step, idx) => renderStepItem(step, idx === 0))
                ),

                e('main', { className: 'canvas' },
                    e('div', { ref: canvasRef, className: 'preview-container', style: { transform: 'scale(' + scale + ')' } },
                        e('div', { className: 'preview', style: { width: canvasWidth + 'px', height: canvasHeight + 'px', background: currentStep ? (currentStep.bgColor || '#000') : '#000' } },
                            showGrid && e('svg', { className: 'canvas-grid', width: canvasWidth, height: canvasHeight },
                                // Vertical lines (10 divisions)
                                Array.from({ length: 11 }, (_, i) => i * canvasWidth / 10).map((x, i) =>
                                    e('line', { key: 'v' + i, x1: x, y1: 0, x2: x, y2: canvasHeight, stroke: i === 5 ? 'rgba(247,147,26,0.4)' : (i === 0 || i === 10 || i === 2 || i === 8) ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.1)', strokeWidth: i === 5 ? 2 : 1 })
                                ),
                                // Horizontal lines (10 divisions)
                                Array.from({ length: 11 }, (_, i) => i * canvasHeight / 10).map((y, i) =>
                                    e('line', { key: 'h' + i, x1: 0, y1: y, x2: canvasWidth, y2: y, stroke: i === 5 ? 'rgba(247,147,26,0.4)' : (i === 0 || i === 10 || i === 2 || i === 8) ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.1)', strokeWidth: i === 5 ? 2 : 1 })
                                )
                            ),
                            currentStep && currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                                e('div', {
                                    key: shape.id,
                                    style: {
                                        position: 'absolute',
                                        left: shape.x + 'px',
                                        top: shape.y + 'px',
                                        width: shape.width + 'px',
                                        height: shape.height + 'px',
                                        background: shape.color,
                                        borderRadius: shape.type === 'circle' ? '50%' : '0',
                                        zIndex: 0
                                    }
                                })
                            ),
                            currentStep ? 
                                currentStep.elements
                                    .sort((a, b) => a.layer - b.layer)
                                    .filter(elem => elem.visible)
                                    .map(elem =>
                                        e('div', {
                                            key: elem.id,
                                            className: 'element' + (elem.id === selectedElementId ? ' selected' : '') + 
                                                      (elem.type === 'hotspot' ? ' element-hotspot' : ''),
                                            style: {
                                                left: elem.x + 'px',
                                                top: elem.y + 'px',
                                                width: elem.width + 'px',
                                                height: elem.height + 'px',
                                                zIndex: (previewOnTop && elem.id === selectedElementId) ? 9999 : elem.layer,
                                                borderRadius: elem.shape === 'circle' ? '50%' : '0'
                                            },
                                            onMouseDown: (ev) => handleMouseDown(ev, elem.id)
                                        },
                                            e('div', { className: 'element-label' }, elem.label),
                                            elem.type === 'image' && elem.content && (elem.cropEnabled ? 
                                                e('div', { style: { width: '100%', height: '100%', overflow: 'hidden', position: 'relative' } },
                                                    e('img', { 
                                                        src: elem.content, 
                                                        style: { 
                                                            position: 'absolute',
                                                            width: (100 / (elem.cropW || 100)) * 100 + '%',
                                                            height: (100 / (elem.cropH || 100)) * 100 + '%',
                                                            left: -(elem.cropX || 0) / (elem.cropW || 100) * 100 + '%',
                                                            top: -(elem.cropY || 0) / (elem.cropH || 100) * 100 + '%',
                                                            objectFit: 'cover',
                                                            transform: 'scale(' + (elem.flipH ? -1 : 1) + ', ' + (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)', 
                                                            opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100 
                                                        } 
                                                    })
                                                ) :
                                                e('img', { src: elem.content, style: { transform: 'scale(' + (elem.flipH ? -1 : 1) + ', ' + (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)', opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100 } })
                                            ),
                                            elem.type === 'video' && elem.content && e('video', { src: elem.content, autoPlay: true, loop: elem.loop, playsInline: true }),
                                            elem.type === 'text' && e('div', { 
                                    className: 'element-text',
                                    style: { 
                                        fontSize: (elem.textSize || 24) + 'px',
                                        color: elem.textColor || '#ffffff',
                                        fontWeight: elem.textBold ? 'bold' : 'normal',
                                        fontStyle: elem.textItalic ? 'italic' : 'normal',
                                        textDecoration: elem.textUnderline ? 'underline' : 'none',
                                        border: elem.textBorder ? ((elem.textBorderWidth || 2) + 'px solid ' + (elem.textBorderColor || '#ffffff')) : 'none',
                                        background: elem.textBgColor ? 
                                            (elem.textBgColor.startsWith('#') ? 
                                                elem.textBgColor + Math.round((elem.textBgOpacity !== undefined ? elem.textBgOpacity : 0.8) * 255).toString(16).padStart(2, '0') : 
                                                elem.textBgColor) : 
                                            ('rgba(0,0,0,' + (elem.textBgOpacity !== undefined ? elem.textBgOpacity : 0.8) + ')')
                                    }
                                }, elem.content),
                                            elem.type === 'button' && e('div', { className: 'element-button' + (elem.buttonPulse ? ' anim-buttonPulse' : ''), style: { background: elem.color, color: elem.buttonTextColor || '#ffffff', fontSize: (elem.buttonTextSize || 20) + 'px', boxShadow: elem.buttonShadow ? '0 4px 15px rgba(0,0,0,0.4)' : 'none' } }, elem.content || 'Button'),
                                            elem.type === 'audio' && e('div', { className: 'element-audio' }, 'ðŸ”Š'),
                                            elem.type === 'timer' && e('div', { className: 'element-timer' }, elem.countdown),
                                            elem.type === 'draggable' && e('div', { className: 'element-draggable' },
                                                elem.contentType === 'image' && elem.content ? e('img', { src: elem.content }) :
                                                e('div', { style: { fontSize: elem.fontSize + 'px', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%' } }, elem.content || 'ðŸ“¦')
                                            ),
                                            elem.type === 'hotspot' && e('div', { style: { width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.8rem' } }, elem.label),
                                            elem.type === 'object' && e('div', { 
                                                className: 'element-object',
                                                style: { 
                                                    width: '100%', 
                                                    height: '100%', 
                                                    background: elem.objectColor || elem.color || '#f7931a',
                                                    borderRadius: elem.objectShape === 'circle' ? '50%' : '0',
                                                    clipPath: elem.objectShape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none',
                                                    transform: 'scale(' + (elem.scaleX || 1) * (elem.flipH ? -1 : 1) + ', ' + (elem.scaleY || 1) * (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)',
                                                    opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100
                                                }
                                            }),
                                            elem.type === 'embed' && e('div', { className: 'element-embed' }, 
                                                elem.embedThumbnail ? 
                                                    e('img', { src: elem.embedThumbnail, style: { width: '100%', height: '100%', objectFit: 'cover' } }) :
                                                    e('div', null,
                                                        e('div', null, 'ðŸŒ Embed'),
                                                        e('div', { style: { fontSize: '0.7rem', marginTop: '5px' } }, elem.embedUrl ? elem.embedUrl.substring(0, 25) + '...' : 'No URL set')
                                                    )
                                            ),
                                            e('div', { className: 'resize-handle' })
                                        )
                                    ) :
                                e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', color: '#6b7280', fontSize: '1.2rem' } }, 'Create a step')
                        )
                    )
                ),

                e('aside', { className: 'sidebar sidebar-right' },
                    currentStep ? e('div', null,
                        e('div', { className: 'form-group' },
                            e('input', {
                                className: 'form-input',
                                value: currentStep.title,
                                placeholder: 'Step Name',
                                onChange: (ev) => updateStep({ title: ev.target.value })
                            })
                        ),
                        currentStep.password && e('div', { style: { fontSize: '0.6rem', color: '#f7931a', marginBottom: '8px' } }, 'ðŸ”’ Password: ' + currentStep.password),
                        
                        e('div', { className: 'tabs' },
                            e('button', { className: 'tab' + (activeTab === 'elements' ? ' active' : ''), onClick: () => setActiveTab('elements') }, 'Elements'),
                            e('button', { className: 'tab' + (activeTab === 'events' ? ' active' : ''), onClick: () => setActiveTab('events') }, 'Events'),
                            e('button', { className: 'tab' + (activeTab === 'inventory' ? ' active' : ''), onClick: () => setActiveTab('inventory') }, 'Inventory'),
                            e('button', { className: 'tab' + (activeTab === 'settings' ? ' active' : ''), onClick: () => setActiveTab('settings') }, 'Settings'),
                            e('button', { className: 'tab' + (activeTab === 'bgm' ? ' active' : ''), onClick: () => setActiveTab('bgm') }, 'BGM')
                        ),

                        activeTab === 'elements' && e('div', null,
                            e('div', { className: 'section-title' }, 'Add'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('image') }, 'ðŸ–¼ï¸ Image'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('video') }, 'ðŸŽ¥ Video'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('text') }, 'ðŸ“ Text'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('button') }, 'ðŸ”˜ Button'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('audio') }, 'ðŸ”Š Audio'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('timer') }, 'â±ï¸ Timer'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('draggable') }, 'ðŸŽ¯ Draggable'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('hotspot') }, 'ðŸ“ Hotspot'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('object') }, 'â¬œ Object'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '8px' }, onClick: () => addElement('embed') }, 'ðŸŒ Embed'),
                            
                            selectedElement && e('div', null,
                                e('div', { className: 'section-title' }, selectedElement.label),
                                e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Label'),
                                    e('input', { className: 'form-input', value: selectedElement.label, onChange: (ev) => updateElement(selectedElement.id, { label: ev.target.value }) })
                                ),
                                
                                selectedElement.type === 'draggable' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Content Type'),
                                    e('select', { className: 'form-select', value: selectedElement.contentType || 'text', onChange: (ev) => updateElement(selectedElement.id, { contentType: ev.target.value }) },
                                        e('option', { value: 'text' }, 'Text/Emoji'),
                                        e('option', { value: 'image' }, 'Image URL')
                                    )
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'text' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text/Emoji'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'ðŸª³ or text', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }) })
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'text' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Font Size'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.fontSize, onChange: (ev) => updateElement(selectedElement.id, { fontSize: parseInt(ev.target.value) || 24 }) })
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'image' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Image URL or Upload'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                    e('input', { 
                                        type: 'file', 
                                        className: 'form-input',
                                        accept: 'image/*',
                                        onChange: (ev) => {
                                            const file = ev.target.files[0];
                                            if (file) {
                                                const url = URL.createObjectURL(file);
                                                updateElement(selectedElement.id, { content: url });
                                            }
                                        }
                                    })
                                ),

                                (selectedElement.type !== 'hotspot' && selectedElement.type !== 'audio' && selectedElement.type !== 'timer' && selectedElement.type !== 'draggable' && selectedElement.type !== 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, selectedElement.type === 'text' || selectedElement.type === 'button' ? 'Text' : 'URL or Upload'),
                                    selectedElement.type === 'text' || selectedElement.type === 'button' ?
                                        e('textarea', { className: 'form-textarea', value: selectedElement.content, onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }) }) :
                                        e('div', null,
                                            e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                            e('div', { style: { display: 'flex', gap: '5px' } },
                                                e('input', { 
                                                    type: 'file', 
                                                    className: 'form-input',
                                                    style: { flex: 1 },
                                                    accept: selectedElement.type === 'image' ? 'image/*' : 'video/*',
                                                    onChange: (ev) => {
                                                        const file = ev.target.files[0];
                                                        if (file) {
                                                            const url = URL.createObjectURL(file);
                                                            updateElement(selectedElement.id, { content: url });
                                                        }
                                                    }
                                                }),
                                                savedUrls.length > 0 && e('select', {
                                                    className: 'form-select',
                                                    style: { width: '80px', fontSize: '0.6rem' },
                                                    value: '',
                                                    onChange: (ev) => {
                                                        if (ev.target.value) updateElement(selectedElement.id, { content: ev.target.value });
                                                        ev.target.value = '';
                                                    }
                                                },
                                                    e('option', { value: '' }, 'ðŸ“ Saved'),
                                                    savedUrls.filter(u => u).map((url, i) => e('option', { key: i, value: url }, '...' + url.slice(-25)))
                                                )
                                            )
                                        )
                                ),
                                selectedElement.type === 'audio' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Audio URL or Upload'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                    e('input', { 
                                        type: 'file', 
                                        className: 'form-input',
                                        accept: 'audio/*',
                                        onChange: (ev) => {
                                            const file = ev.target.files[0];
                                            if (file) {
                                                const url = URL.createObjectURL(file);
                                                updateElement(selectedElement.id, { content: url });
                                            }
                                        }
                                    })
                                ),
                                selectedElement.type === 'timer' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Countdown (seconds)'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.countdown, onChange: (ev) => updateElement(selectedElement.id, { countdown: parseInt(ev.target.value) || 10 }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Button Color'),
                                    e('input', { type: 'color', className: 'form-input', value: selectedElement.color, onChange: (ev) => updateElement(selectedElement.id, { color: ev.target.value }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text Color'),
                                    e('input', { type: 'color', className: 'form-input', value: selectedElement.buttonTextColor || '#ffffff', onChange: (ev) => updateElement(selectedElement.id, { buttonTextColor: ev.target.value }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text Size'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.buttonTextSize || 20, onChange: (ev) => updateElement(selectedElement.id, { buttonTextSize: parseInt(ev.target.value) || 20 }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: selectedElement.buttonShadow || false,
                                            onChange: (ev) => updateElement(selectedElement.id, { buttonShadow: ev.target.checked })
                                        }),
                                        'ðŸŒ‘ Add Shadow'
                                    )
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: selectedElement.buttonPulse || false,
                                            onChange: (ev) => updateElement(selectedElement.id, { buttonPulse: ev.target.checked })
                                        }),
                                        'ðŸ’« Pulse Animation'
                                    )
                                ),
                                // Embed element properties
                                selectedElement.type === 'embed' && e('div', null,
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Embed URL'),
                                        e('input', { className: 'form-input', value: selectedElement.embedUrl || '', placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { embedUrl: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Thumbnail Image (optional)'),
                                        e('input', { className: 'form-input', value: selectedElement.embedThumbnail || '', placeholder: 'https://... or upload below', onChange: (ev) => updateElement(selectedElement.id, { embedThumbnail: ev.target.value }), style: { marginBottom: '5px' } }),
                                        e('input', { 
                                            type: 'file', 
                                            className: 'form-input',
                                            accept: 'image/*',
                                            onChange: (ev) => {
                                                const file = ev.target.files[0];
                                                if (file) {
                                                    const reader = new FileReader();
                                                    reader.onload = (e) => updateElement(selectedElement.id, { embedThumbnail: e.target.result });
                                                    reader.readAsDataURL(file);
                                                }
                                            }
                                        })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                            e('input', { 
                                                type: 'checkbox', 
                                                className: 'form-checkbox',
                                                checked: selectedElement.embedAllowNavigation || false,
                                                onChange: (ev) => updateElement(selectedElement.id, { embedAllowNavigation: ev.target.checked })
                                            }),
                                            'Allow navigation outside canvas'
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Close Button Delay (seconds)'),
                                        e('input', { 
                                            type: 'number', 
                                            className: 'form-input', 
                                            min: '0',
                                            value: selectedElement.embedCloseDelay || 0, 
                                            placeholder: '0 = always visible',
                                            onChange: (ev) => updateElement(selectedElement.id, { embedCloseDelay: parseInt(ev.target.value) || 0 }) 
                                        })
                                    ),
                                    e('div', { className: 'info-box' }, 'Thumbnail replaces the default purple play button. Close delay hides X button for set seconds (0 = always visible).')
                                ),
                                selectedElement.type === 'hotspot' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Interaction Mode'),
                                    e('select', { className: 'form-select', value: selectedElement.hotspotMode || 'both', onChange: (ev) => updateElement(selectedElement.id, { hotspotMode: ev.target.value }) },
                                        e('option', { value: 'both' }, 'Click & Drop'),
                                        e('option', { value: 'click' }, 'Click Only'),
                                        e('option', { value: 'drop' }, 'Drop Only')
                                    )
                                ),
                                selectedElement.type === 'hotspot' && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '0.65rem' } },
                                        e('input', { type: 'checkbox', className: 'form-checkbox', checked: selectedElement.showInGame, onChange: (ev) => updateElement(selectedElement.id, { showInGame: ev.target.checked }) }),
                                        'Visible in Game'
                                    )
                                ),
                                e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Layer'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.layer, onChange: (ev) => updateElement(selectedElement.id, { layer: parseInt(ev.target.value) || 0 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'video' || selectedElement.type === 'text') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Duration (0=forever)'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.duration, onChange: (ev) => updateElement(selectedElement.id, { duration: parseFloat(ev.target.value) || 0 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'â–¶ Intro Animation'),
                                    e('select', { className: 'form-select', value: selectedElement.transition || 'none', onChange: (ev) => updateElement(selectedElement.id, { transition: ev.target.value }) },
                                        e('option', { value: 'none' }, 'None'),
                                        e('option', { value: 'fade' }, 'Fade In'),
                                        e('option', { value: 'slideLeft' }, 'Slide from Left'),
                                        e('option', { value: 'slideRight' }, 'Slide from Right'),
                                        e('option', { value: 'slideUp' }, 'Slide from Top'),
                                        e('option', { value: 'slideDown' }, 'Slide from Bottom'),
                                        e('option', { value: 'zoom' }, 'Zoom In')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && selectedElement.transition && selectedElement.transition !== 'none' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Intro Duration (sec)'),
                                    e('input', { type: 'number', step: '0.1', className: 'form-input', value: selectedElement.transitionDuration || 0.5, onChange: (ev) => updateElement(selectedElement.id, { transitionDuration: parseFloat(ev.target.value) || 0.5 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'ðŸ”„ During Animation'),
                                    e('select', { className: 'form-select', value: selectedElement.animationDuring || 'none', onChange: (ev) => updateElement(selectedElement.id, { animationDuring: ev.target.value }) },
                                        e('option', { value: 'none' }, 'None'),
                                        e('option', { value: 'pulse' }, 'Pulse'),
                                        e('option', { value: 'spin' }, 'Spin'),
                                        e('option', { value: 'bounce' }, 'Bounce'),
                                        e('option', { value: 'wobble' }, 'Wobble'),
                                        e('option', { value: 'shake' }, 'Shake'),
                                        e('option', { value: 'glow' }, 'Glow'),
                                        e('option', { value: 'float' }, 'Float')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'â—€ Outro Animation'),
                                    e('select', { className: 'form-select', value: selectedElement.transitionOut || 'matchIntro', onChange: (ev) => updateElement(selectedElement.id, { transitionOut: ev.target.value }) },
                                        e('option', { value: 'matchIntro' }, 'Match Intro (reverse)'),
                                        e('option', { value: 'none' }, 'None (instant disappear)'),
                                        e('option', { value: 'fade' }, 'Fade Out'),
                                        e('option', { value: 'slideLeft' }, 'Slide to Left'),
                                        e('option', { value: 'slideRight' }, 'Slide to Right'),
                                        e('option', { value: 'slideUp' }, 'Slide to Top'),
                                        e('option', { value: 'slideDown' }, 'Slide to Bottom'),
                                        e('option', { value: 'zoom' }, 'Zoom Out')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && selectedElement.transitionOut && selectedElement.transitionOut !== 'none' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Outro Duration (sec)'),
                                    e('input', { type: 'number', step: '0.1', className: 'form-input', value: selectedElement.transitionOutDuration || 0.5, onChange: (ev) => updateElement(selectedElement.id, { transitionOutDuration: parseFloat(ev.target.value) || 0.5 }) })
                                ),
                                selectedElement.type === 'text' && e('div', null,
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Font Size'),
                                        e('input', { type: 'number', className: 'form-input', value: selectedElement.textSize || 24, onChange: (ev) => updateElement(selectedElement.id, { textSize: parseInt(ev.target.value) || 24 }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Text Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.textColor || '#ffffff', onChange: (ev) => updateElement(selectedElement.id, { textColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Background Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.textBgColor ? selectedElement.textBgColor.replace('rgba(0,0,0,0.8)', '#000000') : '#000000', onChange: (ev) => updateElement(selectedElement.id, { textBgColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Background Opacity (0-100)'),
                                        e('input', { type: 'number', min: '0', max: '100', className: 'form-input', value: selectedElement.textBgOpacity !== undefined ? Math.round(selectedElement.textBgOpacity * 100) : 80, onChange: (ev) => updateElement(selectedElement.id, { textBgOpacity: Math.max(0, Math.min(100, parseInt(ev.target.value) || 0)) / 100 }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Text Style'),
                                        e('div', { style: { display: 'flex', gap: '5px' } },
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.textBold ? 'btn-primary' : 'btn-secondary'),
                                                style: { fontWeight: 'bold' },
                                                onClick: () => updateElement(selectedElement.id, { textBold: !selectedElement.textBold })
                                            }, 'B'),
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.textItalic ? 'btn-primary' : 'btn-secondary'),
                                                style: { fontStyle: 'italic' },
                                                onClick: () => updateElement(selectedElement.id, { textItalic: !selectedElement.textItalic })
                                            }, 'I'),
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.textUnderline ? 'btn-primary' : 'btn-secondary'),
                                                style: { textDecoration: 'underline' },
                                                onClick: () => updateElement(selectedElement.id, { textUnderline: !selectedElement.textUnderline })
                                            }, 'U')
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                            e('input', { 
                                                type: 'checkbox', 
                                                className: 'form-checkbox',
                                                checked: selectedElement.textBorder || false,
                                                onChange: (ev) => updateElement(selectedElement.id, { textBorder: ev.target.checked })
                                            }),
                                            'Border'
                                        )
                                    ),
                                    selectedElement.textBorder && e('div', { style: { display: 'flex', gap: '5px' } },
                                        e('div', { className: 'form-group', style: { flex: 1, marginBottom: 0 } },
                                            e('label', { className: 'form-label' }, 'Width'),
                                            e('input', { type: 'number', min: '1', max: '10', className: 'form-input', value: selectedElement.textBorderWidth || 2, onChange: (ev) => updateElement(selectedElement.id, { textBorderWidth: parseInt(ev.target.value) || 2 }) })
                                        ),
                                        e('div', { className: 'form-group', style: { flex: 1, marginBottom: 0 } },
                                            e('label', { className: 'form-label' }, 'Color'),
                                            e('input', { type: 'color', className: 'form-input', value: selectedElement.textBorderColor || '#ffffff', onChange: (ev) => updateElement(selectedElement.id, { textBorderColor: ev.target.value }) })
                                        )
                                    )
                                ),
                                (selectedElement.type === 'audio' || selectedElement.type === 'video') && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '0.65rem' } },
                                        e('input', { type: 'checkbox', className: 'form-checkbox', checked: selectedElement.loop, onChange: (ev) => updateElement(selectedElement.id, { loop: ev.target.checked }) }),
                                        'Loop'
                                    )
                                ),
                                (selectedElement.type === 'hotspot' || selectedElement.type === 'draggable') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Shape'),
                                    e('select', { className: 'form-select', value: selectedElement.shape, onChange: (ev) => updateElement(selectedElement.id, { shape: ev.target.value }) },
                                        e('option', { value: 'rect' }, 'Rectangle'),
                                        e('option', { value: 'circle' }, 'Circle')
                                    )
                                ),
                                selectedElement.type === 'object' && e('div', null,
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Object Shape'),
                                        e('select', { className: 'form-select', value: selectedElement.objectShape || 'rect', onChange: (ev) => updateElement(selectedElement.id, { objectShape: ev.target.value }) },
                                            e('option', { value: 'rect' }, 'Rectangle'),
                                            e('option', { value: 'circle' }, 'Circle/Oval'),
                                            e('option', { value: 'triangle' }, 'Triangle')
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Object Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.objectColor || '#f7931a', onChange: (ev) => updateElement(selectedElement.id, { objectColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Opacity (0-100)'),
                                        e('input', { type: 'number', min: '0', max: '100', className: 'form-input', value: selectedElement.opacity !== undefined ? selectedElement.opacity : 100, onChange: (ev) => updateElement(selectedElement.id, { opacity: Math.max(0, Math.min(100, parseInt(ev.target.value) || 0)) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Scale X (stretch)'),
                                        e('input', { type: 'range', min: '0.2', max: '3', step: '0.1', className: 'form-input', value: selectedElement.scaleX || 1, onChange: (ev) => updateElement(selectedElement.id, { scaleX: parseFloat(ev.target.value) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Scale Y (stretch)'),
                                        e('input', { type: 'range', min: '0.2', max: '3', step: '0.1', className: 'form-input', value: selectedElement.scaleY || 1, onChange: (ev) => updateElement(selectedElement.id, { scaleY: parseFloat(ev.target.value) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Rotation'),
                                        e('div', { style: { display: 'flex', gap: '3px', flexWrap: 'wrap' } },
                                            [0, 45, 90, 135, 180, 225, 270, 315].map(deg =>
                                                e('button', { 
                                                    key: deg,
                                                    className: 'btn btn-small ' + ((selectedElement.rotation || 0) === deg ? 'btn-primary' : 'btn-secondary'),
                                                    style: { padding: '3px 6px', fontSize: '0.6rem' },
                                                    onClick: () => updateElement(selectedElement.id, { rotation: deg })
                                                }, deg + 'Â°')
                                            )
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Flip'),
                                        e('div', { style: { display: 'flex', gap: '5px' } },
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipH ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipH: !selectedElement.flipH })
                                            }, 'â†” Horizontal'),
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipV ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipV: !selectedElement.flipV })
                                            }, 'â†• Vertical')
                                        )
                                    )
                                ),
                                selectedElement.type === 'image' && e('div', null,
                                    e('div', { className: 'section-title', style: { marginTop: '10px' } }, 'Transform'),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Opacity (0-100)'),
                                        e('input', { type: 'number', min: '0', max: '100', className: 'form-input', value: selectedElement.opacity !== undefined ? selectedElement.opacity : 100, onChange: (ev) => updateElement(selectedElement.id, { opacity: Math.max(0, Math.min(100, parseInt(ev.target.value) || 0)) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Rotation'),
                                        e('div', { style: { display: 'flex', gap: '3px', flexWrap: 'wrap' } },
                                            [0, 45, 90, 135, 180, 225, 270, 315].map(deg =>
                                                e('button', { 
                                                    key: deg,
                                                    className: 'btn btn-small ' + ((selectedElement.rotation || 0) === deg ? 'btn-primary' : 'btn-secondary'),
                                                    style: { padding: '3px 6px', fontSize: '0.6rem' },
                                                    onClick: () => updateElement(selectedElement.id, { rotation: deg })
                                                }, deg + 'Â°')
                                            )
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Flip'),
                                        e('div', { style: { display: 'flex', gap: '5px' } },
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipH ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipH: !selectedElement.flipH })
                                            }, 'â†” Horizontal'),
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipV ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipV: !selectedElement.flipV })
                                            }, 'â†• Vertical')
                                        )
                                    ),
                                    e('div', { className: 'section-title', style: { marginTop: '10px' } }, 'Crop'),
                                    e('div', { className: 'form-group' },
                                        e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                            e('input', { 
                                                type: 'checkbox', 
                                                className: 'form-checkbox',
                                                checked: selectedElement.cropEnabled || false,
                                                onChange: (ev) => updateElement(selectedElement.id, { 
                                                    cropEnabled: ev.target.checked,
                                                    cropX: ev.target.checked ? (selectedElement.cropX || 0) : 0,
                                                    cropY: ev.target.checked ? (selectedElement.cropY || 0) : 0,
                                                    cropW: ev.target.checked ? (selectedElement.cropW || 100) : 100,
                                                    cropH: ev.target.checked ? (selectedElement.cropH || 100) : 100
                                                })
                                            }),
                                            'âœ‚ï¸ Enable Crop'
                                        )
                                    ),
                                    selectedElement.cropEnabled && e('div', null,
                                        e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px', marginBottom: '5px' } },
                                            e('div', { className: 'form-group', style: { marginBottom: 0 } },
                                                e('label', { className: 'form-label' }, 'Left %'),
                                                e('input', { type: 'number', min: '0', max: '99', className: 'form-input', value: selectedElement.cropX || 0, onChange: (ev) => updateElement(selectedElement.id, { cropX: Math.max(0, Math.min(99, parseInt(ev.target.value) || 0)) }) })
                                            ),
                                            e('div', { className: 'form-group', style: { marginBottom: 0 } },
                                                e('label', { className: 'form-label' }, 'Top %'),
                                                e('input', { type: 'number', min: '0', max: '99', className: 'form-input', value: selectedElement.cropY || 0, onChange: (ev) => updateElement(selectedElement.id, { cropY: Math.max(0, Math.min(99, parseInt(ev.target.value) || 0)) }) })
                                            ),
                                            e('div', { className: 'form-group', style: { marginBottom: 0 } },
                                                e('label', { className: 'form-label' }, 'Width %'),
                                                e('input', { type: 'number', min: '1', max: '100', className: 'form-input', value: selectedElement.cropW || 100, onChange: (ev) => updateElement(selectedElement.id, { cropW: Math.max(1, Math.min(100, parseInt(ev.target.value) || 100)) }) })
                                            ),
                                            e('div', { className: 'form-group', style: { marginBottom: 0 } },
                                                e('label', { className: 'form-label' }, 'Height %'),
                                                e('input', { type: 'number', min: '1', max: '100', className: 'form-input', value: selectedElement.cropH || 100, onChange: (ev) => updateElement(selectedElement.id, { cropH: Math.max(1, Math.min(100, parseInt(ev.target.value) || 100)) }) })
                                            )
                                        ),
                                        e('div', { style: { fontSize: '0.6rem', color: '#6b7280' } }, 'Crop shows portion of image starting at Left/Top position')
                                    )
                                ),
                                e('div', { style: { display: 'flex', gap: '5px', marginTop: '10px' } },
                                    e('button', { className: 'btn btn-secondary btn-small', style: { flex: 1 }, onClick: () => copyElement(selectedElement) }, 'ðŸ“‹ Copy'),
                                    e('button', { className: 'btn btn-danger btn-small', style: { flex: 1 }, onClick: () => deleteElement(selectedElement.id) }, 'ðŸ—‘ï¸ Delete')
                                ),
                                e('div', { style: { marginTop: '8px' } },
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: previewOnTop,
                                            onChange: (ev) => setPreviewOnTop(ev.target.checked)
                                        }),
                                        'ðŸ‘ï¸ Preview selected on top'
                                    )
                                )
                            ),

                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'All Elements'),
                            clipboard && e('button', { className: 'btn btn-success btn-small', style: { width: '100%', marginBottom: '5px' }, onClick: pasteElement }, 'ðŸ“‹ Paste: ' + clipboard.label),
                            e('div', { style: { maxHeight: '200px', overflowY: 'auto' } },
                                currentStep.elements.length === 0 ? 
                                    e('div', { style: { fontSize: '0.7rem', color: '#6b7280', padding: '10px', textAlign: 'center' } }, 'No elements yet') :
                                    currentStep.elements.map(el =>
                                        e('div', { 
                                            key: el.id, 
                                            className: 'element-list-item' + (selectedElementId === el.id ? ' selected' : ''),
                                            onClick: () => setSelectedElementId(el.id)
                                        },
                                            e('span', null, el.label),
                                            e('span', { className: 'element-type-badge' }, el.type)
                                        )
                                    )
                            )
                        ),

                        activeTab === 'events' && e('div', null,
                            e('div', { className: 'info-box' }, 'Events trigger actions. Drag â‰¡ to reorder. Events run top-to-bottom.'),
                            currentStep.events.map((event, idx) =>
                                e('div', { 
                                    key: event.id, 
                                    className: 'event-item' + (draggedEventId === event.id ? ' drag-over' : ''),
                                    onDragOver: (ev) => handleEventDragOver(ev, event.id),
                                    onDrop: (ev) => handleEventDrop(ev, event.id)
                                },
                                    e('div', { 
                                        className: 'event-header',
                                        onClick: () => toggleEventCollapse(event.id)
                                    },
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                                            e('span', { 
                                                className: 'event-drag-handle',
                                                draggable: true,
                                                onDragStart: (ev) => handleEventDragStart(ev, event.id),
                                                onDragEnd: handleEventDragEnd,
                                                onClick: (ev) => ev.stopPropagation()
                                            }, 'â‰¡'),
                                            e('span', { style: { fontSize: '0.7rem', fontWeight: 600, color: '#f7931a' } }, 'Event ' + (idx + 1)),
                                            e('span', { style: { fontSize: '0.6rem', color: '#9ca3af' } }, ' - ' + event.trigger.type)
                                        ),
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '5px' } },
                                            e('span', { className: 'collapsible-arrow' + (collapsedEvents[event.id] ? '' : ' open') }, 'â–¶'),
                                            e('button', { 
                                                className: 'btn btn-danger btn-small', 
                                                onClick: (ev) => { ev.stopPropagation(); deleteEvent(event.id); },
                                                style: { padding: '2px 6px' }
                                            }, 'Ã—')
                                        )
                                    ),
                                    e('div', { className: 'collapsible-content' + (!collapsedEvents[event.id] ? ' open' : '') },
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '5px', marginTop: '5px' } },
                                            e('select', { className: 'form-select', style: { flex: 1, marginRight: '4px', fontSize: '0.6rem' }, value: event.trigger.type, onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, type: ev.target.value } }) },
                                                e('option', { value: 'onLoad' }, 'On Load'),
                                                e('option', { value: 'afterDelay' }, 'After Delay'),
                                                e('option', { value: 'afterElement' }, 'After Element'),
                                                e('option', { value: 'onClick' }, 'On Click'),
                                                e('option', { value: 'onDrop' }, 'On Drop'),
                                                e('option', { value: 'onEmbedClose' }, 'On Embed Close')
                                            )
                                        ),
                                        event.trigger.type === 'afterDelay' && e('input', { type: 'number', className: 'form-input', placeholder: 'Seconds', value: event.trigger.delay || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, delay: parseFloat(ev.target.value) || 0 } }), style: { marginBottom: '5px' } }),
                                        event.trigger.type === 'afterElement' && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                            e('option', { value: '' }, '-- Select Element --'),
                                            currentStep.elements.map(el => e('option', { key: el.id, value: el.id }, el.label))
                                        ),
                                        event.trigger.type === 'onEmbedClose' && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                            e('option', { value: '' }, '-- Select Embed --'),
                                            currentStep.elements.filter(el => el.type === 'embed').map(el => e('option', { key: el.id, value: el.id }, el.label))
                                        ),
                                        event.trigger.type === 'onDrop' && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                            e('option', { value: '' }, '-- Drop Zone --'),
                                            currentStep.elements.filter(el => el.type === 'button' || el.type === 'hotspot').map(el => e('option', { key: el.id, value: el.id }, el.label))
                                        ),
                                        event.trigger.type === 'onClick' && e('div', null,
                                            e('div', { 
                                                className: 'collapsible-header', 
                                                onClick: () => toggleActionCollapse('trigger_' + event.id),
                                                style: { marginBottom: '5px' }
                                            },
                                                e('span', { style: { fontSize: '0.6rem', color: '#10b981' } }, 
                                                    (() => {
                                                        const sources = event.trigger.sourceElements || (event.trigger.sourceElement ? [event.trigger.sourceElement] : []);
                                                        const validSources = sources.filter(s => currentStep.elements.some(el => el.id === s));
                                                        return validSources.length + ' trigger(s) selected';
                                                    })()
                                                ),
                                                e('span', { className: 'collapsible-arrow' + (collapsedActions['trigger_' + event.id] ? '' : ' open') }, 'â–¶')
                                            ),
                                            e('div', { className: 'collapsible-content' + (!collapsedActions['trigger_' + event.id] ? ' open' : '') },
                                                currentStep.elements.filter(el => el.type === 'button' || el.type === 'hotspot').map(el => 
                                                    e('label', { key: el.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', cursor: 'pointer', marginBottom: '2px' } },
                                                        e('input', { 
                                                            type: 'checkbox', 
                                                            className: 'form-checkbox',
                                                            checked: (event.trigger.sourceElements || (event.trigger.sourceElement ? [event.trigger.sourceElement] : [])).includes(el.id),
                                                            onChange: (ev) => {
                                                                const currentSources = event.trigger.sourceElements || (event.trigger.sourceElement ? [event.trigger.sourceElement] : []);
                                                                let newSources;
                                                                if (ev.target.checked) {
                                                                    newSources = [...currentSources, el.id];
                                                                } else {
                                                                    newSources = currentSources.filter(s => s !== el.id);
                                                                }
                                                                updateEvent(event.id, { trigger: { ...event.trigger, sourceElements: newSources, sourceElement: '' } });
                                                            }
                                                        }),
                                                        el.label
                                                    )
                                                )
                                            )
                                        ),
                                        
                                        event.condition && e('div', { className: 'condition-box' },
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '3px' } },
                                                e('span', { style: { fontSize: '0.6rem', fontWeight: 700 } }, 'CONDITION'),
                                                e('button', { className: 'btn btn-danger btn-small', onClick: () => updateEvent(event.id, { condition: null }) }, 'Ã—')
                                            ),
                                            e('select', { className: 'form-select', value: event.condition.type, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, type: ev.target.value } }), style: { marginBottom: '3px', fontSize: '0.6rem' } },
                                                e('option', { value: 'hasItem' }, 'Has Item'),
                                                e('option', { value: 'notHasItem' }, 'Does NOT Have Item'),
                                                e('option', { value: 'varyingAtLeast' }, 'ðŸ“Š Has At Least'),
                                                e('option', { value: 'varyingAtMost' }, 'ðŸ“Š Has At Most'),
                                            e('option', { value: 'varyingBetween' }, 'ðŸ“Š Has Between')
                                        ),
                                        (event.condition.type === 'hasItem' || event.condition.type === 'notHasItem') ?
                                            e('div', null,
                                                e('div', { style: { display: 'flex', gap: '5px', marginBottom: '5px' } },
                                                    e('button', { 
                                                        className: 'btn btn-small ' + ((event.condition.logic || 'any') === 'any' ? 'btn-primary' : 'btn-secondary'),
                                                        onClick: () => updateEvent(event.id, { condition: { ...event.condition, logic: 'any' } })
                                                    }, 'ANY'),
                                                    e('button', { 
                                                        className: 'btn btn-small ' + ((event.condition.logic || 'any') === 'all' ? 'btn-primary' : 'btn-secondary'),
                                                        onClick: () => updateEvent(event.id, { condition: { ...event.condition, logic: 'all' } })
                                                    }, 'ALL')
                                                ),
                                                e('div', { 
                                                    className: 'collapsible-header', 
                                                    onClick: () => toggleActionCollapse('cond_' + event.id),
                                                    style: { marginBottom: '3px' }
                                                },
                                                    e('span', { style: { fontSize: '0.6rem', color: '#f59e0b' } }, 
                                                        (() => {
                                                            const items = event.condition.items || (event.condition.item ? [event.condition.item] : []);
                                                            return items.length + ' item(s) selected';
                                                        })()
                                                    ),
                                                    e('span', { className: 'collapsible-arrow' + (collapsedActions['cond_' + event.id] ? '' : ' open') }, 'â–¶')
                                                ),
                                                e('div', { className: 'collapsible-content' + (!collapsedActions['cond_' + event.id] ? ' open' : ''), style: { maxHeight: '120px', overflowY: 'auto' } },
                                                    inventory.map(item => {
                                                        const itemName = item.name || item;
                                                        return e('label', { key: itemName, style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', cursor: 'pointer', marginBottom: '2px' } },
                                                            e('input', { 
                                                                type: 'checkbox', 
                                                                className: 'form-checkbox',
                                                                checked: (event.condition.items || (event.condition.item ? [event.condition.item] : [])).includes(itemName),
                                                                onChange: (ev) => {
                                                                    const currentItems = event.condition.items || (event.condition.item ? [event.condition.item] : []);
                                                                    let newItems;
                                                                    if (ev.target.checked) {
                                                                        newItems = [...currentItems, itemName];
                                                                    } else {
                                                                        newItems = currentItems.filter(i => i !== itemName);
                                                                    }
                                                                    updateEvent(event.id, { condition: { ...event.condition, items: newItems, item: '' } });
                                                                }
                                                            }),
                                                            itemName
                                                        );
                                                    })
                                                )
                                            ) :
                                        (event.condition.type === 'varyingAtLeast' || event.condition.type === 'varyingAtMost') ?
                                            e('div', null,
                                                e('select', { className: 'form-select', value: event.condition.item, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, item: ev.target.value } }), style: { marginBottom: '3px' } },
                                                    e('option', { value: '' }, '-- Varying Item --'),
                                                    varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                ),
                                                e('input', { type: 'number', className: 'form-input', placeholder: 'Amount', value: event.condition.amount || 0, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, amount: parseFloat(ev.target.value) || 0 } }) })
                                            ) :
                                        event.condition.type === 'varyingBetween' ?
                                            e('div', null,
                                                e('select', { className: 'form-select', value: event.condition.item, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, item: ev.target.value } }), style: { marginBottom: '3px' } },
                                                    e('option', { value: '' }, '-- Varying Item --'),
                                                    varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                ),
                                                e('div', { style: { display: 'flex', gap: '5px' } },
                                                    e('input', { type: 'number', className: 'form-input', placeholder: 'Min', value: event.condition.min || 0, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, min: parseFloat(ev.target.value) || 0 } }) }),
                                                    e('input', { type: 'number', className: 'form-input', placeholder: 'Max', value: event.condition.max || 0, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, max: parseFloat(ev.target.value) || 0 } }) })
                                                )
                                            ) : null
                                    ),
                                    !event.condition && e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '5px' }, onClick: () => updateEvent(event.id, { condition: { type: 'hasItem', item: '' } }) }, '+ Add Condition'),
                                    
                                    event.actions.map(action =>
                                        e('div', { key: action.id, className: 'action-item' },
                                            e('select', { className: 'form-select', value: action.type, onChange: (ev) => updateEventAction(event.id, action.id, { type: ev.target.value }), style: { marginBottom: '3px', fontSize: '0.6rem' } },
                                                e('option', { value: 'show' }, 'Show'),
                                                e('option', { value: 'hide' }, 'Hide'),
                                                e('option', { value: 'showDelay' }, 'Show (Delayed)'),
                                                e('option', { value: 'hideDelay' }, 'Hide (Delayed)'),
                                                e('option', { value: 'goto' }, 'Go To Step'),
                                                e('option', { value: 'addItem' }, 'Add Inventory'),
                                                e('option', { value: 'removeItem' }, 'Remove Inventory'),
                                                e('option', { value: 'addVarying' }, 'ðŸ“Š Add to Varying'),
                                                e('option', { value: 'subtractVarying' }, 'ðŸ“Š Subtract from Varying'),
                                                e('option', { value: 'setVarying' }, 'ðŸ“Š Set Varying To'),
                                                e('option', { value: 'bgmPlay' }, 'ðŸŽµ BGM Play'),
                                                e('option', { value: 'bgmStop' }, 'ðŸ”‡ BGM Stop'),
                                                e('option', { value: 'showInventory' }, 'ðŸ‘ï¸ Show All Inventory'),
                                                e('option', { value: 'hideInventory' }, 'ðŸš« Hide All Inventory'),
                                                e('option', { value: 'showInvItem' }, 'ðŸ‘ï¸ Show Inventory Item'),
                                                e('option', { value: 'hideInvItem' }, 'ðŸš« Hide Inventory Item'),
                                                e('option', { value: 'showVarying' }, 'ðŸ‘ï¸ Show All Varying'),
                                                e('option', { value: 'hideVarying' }, 'ðŸš« Hide All Varying'),
                                                e('option', { value: 'showVaryItem' }, 'ðŸ‘ï¸ Show Varying Item'),
                                                e('option', { value: 'hideVaryItem' }, 'ðŸš« Hide Varying Item'),
                                                e('option', { value: 'saveState' }, 'ðŸ’¾ Save Game State'),
                                                e('option', { value: 'loadState' }, 'ðŸ“‚ Load Game State'),
                                                e('option', { value: 'clearState' }, 'ðŸ—‘ï¸ Clear Saved State')
                                            ),
                                            // Simple actions that need no additional config
                                            (action.type === 'bgmStop' || action.type === 'showInventory' || action.type === 'hideInventory' || action.type === 'showVarying' || action.type === 'hideVarying' || action.type === 'saveState' || action.type === 'loadState' || action.type === 'clearState') ?
                                                e('div', { style: { fontSize: '0.6rem', color: '#10b981', padding: '5px' } }, 'âœ“ No configuration needed') :
                                            // BGM Play - select which track
                                            action.type === 'bgmPlay' ?
                                                e('select', { className: 'form-select', value: action.target || '', onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Select BGM Track --'),
                                                    bgmTracks.map(track => e('option', { key: track.id, value: track.id }, track.name))
                                                ) :
                                            // Per-item inventory show/hide
                                            (action.type === 'showInvItem' || action.type === 'hideInvItem') ?
                                                e('select', { className: 'form-select', value: action.target || '', onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Select Inventory Item --'),
                                                    inventory.map(item => e('option', { key: item.name || item, value: item.name || item }, item.name || item))
                                                ) :
                                            // Per-item varying show/hide
                                            (action.type === 'showVaryItem' || action.type === 'hideVaryItem') ?
                                                e('select', { className: 'form-select', value: action.target || '', onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Select Varying Item --'),
                                                    varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                ) :
                                            action.type === 'goto' ?
                                                e('div', null,
                                                    e('div', { style: { fontSize: '0.6rem', color: '#f7931a', marginBottom: '3px' } }, 'Select one or more (random if multiple):'),
                                                    steps.map(s =>
                                                        e('label', { key: s.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', marginBottom: '2px', cursor: 'pointer' } },
                                                            e('input', { 
                                                                type: 'checkbox', 
                                                                className: 'form-checkbox',
                                                                checked: action.targets ? action.targets.includes(s.id) : action.target === s.id,
                                                                onChange: (ev) => {
                                                                    // Clean phantom step references (deleted steps)
                                                                    const validStepIds = steps.map(step => step.id);
                                                                    const existingTargets = action.targets ? action.targets.filter(t => validStepIds.includes(t)) : (action.target && validStepIds.includes(action.target) ? [action.target] : []);
                                                                    
                                                                    if (ev.target.checked) {
                                                                        // Add this step
                                                                        const newTargets = [...existingTargets, s.id];
                                                                        updateEventAction(event.id, action.id, { targets: newTargets, target: '' });
                                                                    } else {
                                                                        // Remove this step
                                                                        const newTargets = existingTargets.filter(t => t !== s.id);
                                                                        updateEventAction(event.id, action.id, { targets: newTargets.length > 0 ? newTargets : undefined, target: newTargets.length === 0 ? '' : action.target });
                                                                    }
                                                                }
                                                            }),
                                                            s.title
                                                        )
                                                    )
                                                ) :
                                            action.type === 'addItem' || action.type === 'removeItem' ?
                                                e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Item --'),
                                                    inventory.map(item => e('option', { key: item.name || item, value: item.name || item }, item.name || item))
                                                ) :
                                            action.type === 'addVarying' || action.type === 'subtractVarying' || action.type === 'setVarying' ?
                                                e('div', null,
                                                    e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }), style: { marginBottom: '5px' } },
                                                        e('option', { value: '' }, '-- Varying Item --'),
                                                        varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                    ),
                                                    e('div', { className: 'form-group', style: { marginBottom: '0' } },
                                                        e('label', { className: 'form-label' }, action.type === 'setVarying' ? 'Set To Value' : 'Amount'),
                                                        e('input', { type: 'number', className: 'form-input', value: action.amount || 0, onChange: (ev) => updateEventAction(event.id, action.id, { amount: parseFloat(ev.target.value) || 0 }) })
                                                    )
                                                ) :
                                            (action.type === 'show' || action.type === 'hide' || action.type === 'showDelay' || action.type === 'hideDelay') ?
                                                e('div', null,
                                                    (action.type === 'showDelay' || action.type === 'hideDelay') && e('div', { className: 'form-group', style: { marginBottom: '5px' } },
                                                        e('label', { className: 'form-label' }, 'Delay (seconds)'),
                                                        e('input', { type: 'number', step: '0.1', className: 'form-input', value: action.delay || 0, onChange: (ev) => updateEventAction(event.id, action.id, { delay: parseFloat(ev.target.value) || 0 }) })
                                                    ),
                                                    e('div', { 
                                                        className: 'collapsible-header', 
                                                        onClick: () => toggleActionCollapse(event.id + '_' + action.id)
                                                    },
                                                        e('span', { style: { fontSize: '0.6rem', color: '#10b981' } }, 
                                                            (() => {
                                                                // Filter out phantom references - only count elements that actually exist
                                                                const validElementIds = currentStep.elements.map(el => el.id);
                                                                let validCount = 0;
                                                                
                                                                if (action.targets) {
                                                                    validCount = action.targets.filter(t => validElementIds.includes(t)).length;
                                                                } else if (action.target && validElementIds.includes(action.target)) {
                                                                    validCount = 1;
                                                                }
                                                                
                                                                return 'Elements (' + validCount + ' selected)';
                                                            })()
                                                        ),
                                                        e('span', { className: 'collapsible-arrow' + (collapsedActions[event.id + '_' + action.id] === false || collapsedActions[event.id + '_' + action.id] === undefined ? '' : ' open') }, 'â–¶')
                                                    ),
                                                    e('div', { className: 'collapsible-content' + (collapsedActions[event.id + '_' + action.id] ? ' open' : '') },
                                                        currentStep.elements.map(el =>
                                                            e('label', { key: el.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', marginBottom: '2px', cursor: 'pointer' } },
                                                                e('input', { 
                                                                    type: 'checkbox', 
                                                                    className: 'form-checkbox',
                                                                    checked: action.targets ? action.targets.includes(el.id) : action.target === el.id,
                                                                    onChange: (ev) => {
                                                                        // First, clean out any phantom targets (deleted elements)
                                                                        const validElementIds = currentStep.elements.map(e => e.id);
                                                                        const existingTargets = action.targets ? action.targets.filter(t => validElementIds.includes(t)) : (action.target && validElementIds.includes(action.target) ? [action.target] : []);
                                                                        
                                                                        if (ev.target.checked) {
                                                                            // Add this element
                                                                            const newTargets = [...existingTargets, el.id];
                                                                            updateEventAction(event.id, action.id, { targets: newTargets, target: '' });
                                                                        } else {
                                                                            // Remove this element
                                                                            const newTargets = existingTargets.filter(t => t !== el.id);
                                                                            updateEventAction(event.id, action.id, { targets: newTargets.length > 0 ? newTargets : undefined, target: newTargets.length === 0 ? '' : action.target });
                                                                        }
                                                                    }
                                                                }),
                                                                el.label
                                                            )
                                                        )
                                                    )
                                                ) :
                                                e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Element --'),
                                                    currentStep.elements.map(el => e('option', { key: el.id, value: el.id }, el.label))
                                                ),
                                            e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteEventAction(event.id, action.id), style: { marginTop: '3px', width: '100%' } }, 'Remove')
                                        )
                                    ),
                                    e('button', { className: 'add-btn btn-add-action', onClick: () => addEventAction(event.id) }, '+ Action')
                                    )
                                )
                            ),
                            e('button', { className: 'add-btn btn-add-event', onClick: addEvent }, '+ Event')
                        ),

                        activeTab === 'inventory' && e('div', null,
                            e('div', { className: 'info-box' }, 'Global inventory items. Visible items show at bottom-left in game.'),
                            inventory.map(item =>
                                e('div', { key: item.name || item, style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '5px', background: '#1a1f3a', marginBottom: '4px', borderRadius: '4px' } },
                                    e('span', { style: { fontSize: '0.75rem', flex: 1 } }, item.name || item),
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', marginRight: '8px', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: typeof item === 'string' ? true : item.visible,
                                            onChange: (ev) => {
                                                if (typeof item === 'string') {
                                                    setInventory(inventory.map(i => i === item ? { name: item, visible: ev.target.checked } : i));
                                                } else {
                                                    setInventory(inventory.map(i => i.name === item.name ? { ...i, visible: ev.target.checked } : i));
                                                }
                                            }
                                        }),
                                        'Visible'
                                    ),
                                    e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteInventoryItem(item) }, 'Ã—')
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: addInventoryItem }, '+ Item'),

                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Varying Items'),
                            e('div', { className: 'info-box' }, 'Items with numeric values (money, points, etc). Use actions to add/subtract.'),
                            varyingItems.map(item =>
                                e('div', { key: item.name, style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '5px', background: '#1a1f3a', marginBottom: '4px', borderRadius: '4px', border: '1px solid #f59e0b' } },
                                    e('span', { style: { fontSize: '0.75rem', flex: 1, color: '#f59e0b' } }, 'ðŸ“Š ' + item.name),
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', marginRight: '8px', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: item.visible,
                                            onChange: (ev) => {
                                                setVaryingItems(varyingItems.map(i => i.name === item.name ? { ...i, visible: ev.target.checked } : i));
                                            }
                                        }),
                                        'Visible'
                                    ),
                                    e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteVaryingItem(item) }, 'Ã—')
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: addVaryingItem }, '+ Varying Item')
                        ),

                        activeTab === 'settings' && e('div', null,
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Background Color'),
                                e('input', { type: 'color', className: 'form-input', value: currentStep.bgColor || '#000000', onChange: (ev) => updateStep({ bgColor: ev.target.value }) })
                            ),
                            e('div', { className: 'section-title' }, 'Background Shapes'),
                            currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                                e('div', { key: shape.id, style: { background: '#1a1f3a', padding: '8px', marginBottom: '5px', borderRadius: '4px' } },
                                    e('div', { style: { display: 'flex', gap: '5px', marginBottom: '5px' } },
                                        e('select', { className: 'form-select', style: { flex: 1 }, value: shape.type, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, type: ev.target.value } : s) }) },
                                            e('option', { value: 'rect' }, 'Rectangle'),
                                            e('option', { value: 'circle' }, 'Circle')
                                        ),
                                        e('input', { type: 'color', className: 'form-input', style: { width: '60px' }, value: shape.color, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, color: ev.target.value } : s) }) }),
                                        e('button', { className: 'btn btn-danger btn-small', onClick: () => updateStep({ bgShapes: currentStep.bgShapes.filter(s => s.id !== shape.id) }) }, 'Ã—')
                                    ),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px', fontSize: '0.6rem' } },
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'X', value: shape.x, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, x: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Y', value: shape.y, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, y: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Width', value: shape.width, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, width: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Height', value: shape.height, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, height: parseInt(ev.target.value) || 0 } : s) }) })
                                    )
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: () => updateStep({ bgShapes: [...(currentStep.bgShapes || []), { id: 'shape_' + Date.now(), type: 'rect', color: '#ffffff', x: 100, y: 100, width: 200, height: 200 }] }) }, '+ Shape'),
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Password'),
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Password Lock'),
                                e('input', { className: 'form-input', value: currentStep.password, placeholder: 'Optional', onChange: (ev) => updateStep({ password: ev.target.value }) })
                            ),
                            currentStep.password && e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Wrong Password â†’ Go To'),
                                e('select', { className: 'form-select', value: currentStep.wrongPasswordStep, onChange: (ev) => updateStep({ wrongPasswordStep: ev.target.value }) },
                                    e('option', { value: '' }, '-- Exit Game --'),
                                    steps.map(s => e('option', { key: s.id, value: s.id }, s.title))
                                )
                            ),
                            e('div', { className: 'info-box' }, 'Background shapes appear behind all elements'),
                            
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Canvas Mode'),
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Orientation (set once at start)'),
                                e('select', { 
                                    className: 'form-select', 
                                    value: canvasMode,
                                    onChange: (ev) => {
                                        if (steps.length > 1 || (steps.length === 1 && steps[0].elements.length > 0)) {
                                            if (!confirm('Changing canvas mode may affect element positions. Continue?')) return;
                                        }
                                        setCanvasMode(ev.target.value);
                                    }
                                },
                                    e('option', { value: 'landscape' }, 'ðŸ“º Landscape (1024Ã—576)'),
                                    e('option', { value: 'portrait' }, 'ðŸ“± Portrait (576Ã—1024)')
                                )
                            ),
                            
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Save System Key'),
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Unique Game ID'),
                                e('input', { 
                                    className: 'form-input', 
                                    value: saveKey,
                                    placeholder: 'e.g. my_rpg_game',
                                    onChange: (ev) => setSaveKey(ev.target.value.replace(/[^a-zA-Z0-9_-]/g, ''))
                                })
                            ),
                            e('div', { className: 'info-box' }, 'Each game needs a unique key to prevent save conflicts. Use letters, numbers, underscores. Leave empty for legacy mode.'),
                            
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Saved URLs (for re-use)'),
                            e('div', { className: 'info-box' }, 'Add URLs here to quickly re-use in element URL fields.'),
                            savedUrls.map((url, idx) =>
                                e('div', { key: idx, style: { display: 'flex', gap: '5px', marginBottom: '4px' } },
                                    e('input', { 
                                        className: 'form-input', 
                                        style: { flex: 1, fontSize: '0.6rem' },
                                        value: url, 
                                        placeholder: 'https://...',
                                        onChange: (ev) => setSavedUrls(savedUrls.map((u, i) => i === idx ? ev.target.value : u))
                                    }),
                                    e('button', { 
                                        className: 'btn btn-danger btn-small',
                                        onClick: () => setSavedUrls(savedUrls.filter((_, i) => i !== idx))
                                    }, 'Ã—')
                                )
                            ),
                            e('button', { 
                                className: 'add-btn', 
                                onClick: () => setSavedUrls([...savedUrls, ''])
                            }, '+ Add URL')
                        ),

                        activeTab === 'bgm' && e('div', null,
                            e('div', { className: 'section-title' }, 'Background Music Tracks'),
                            e('div', { className: 'info-box' }, 'Add multiple BGM tracks. Use event actions to play/stop specific tracks.'),
                            bgmTracks.map((track, idx) =>
                                e('div', { key: track.id, style: { background: '#1a1f3a', border: '1px solid #2d3748', borderRadius: '6px', padding: '8px', marginBottom: '8px' } },
                                    e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' } },
                                        e('input', {
                                            className: 'form-input',
                                            style: { width: '120px', fontWeight: 'bold' },
                                            value: track.name,
                                            placeholder: 'Track name',
                                            onChange: (ev) => setBgmTracks(bgmTracks.map(t => t.id === track.id ? { ...t, name: ev.target.value } : t))
                                        }),
                                        e('button', { 
                                            className: 'btn btn-danger btn-small',
                                            onClick: () => setBgmTracks(bgmTracks.filter(t => t.id !== track.id))
                                        }, 'Ã—')
                                    ),
                                    e('div', { className: 'form-group', style: { marginBottom: '5px' } },
                                        e('input', { 
                                            className: 'form-input', 
                                            value: track.url || '', 
                                            placeholder: 'https://... or upload below',
                                            onChange: (ev) => setBgmTracks(bgmTracks.map(t => t.id === track.id ? { ...t, url: ev.target.value } : t))
                                        })
                                    ),
                                    e('div', { className: 'form-group', style: { marginBottom: '5px' } },
                                        e('input', { 
                                            type: 'file', 
                                            className: 'form-input',
                                            accept: 'audio/*',
                                            onChange: (ev) => {
                                                const file = ev.target.files[0];
                                                if (file) {
                                                    const url = URL.createObjectURL(file);
                                                    setBgmTracks(bgmTracks.map(t => t.id === track.id ? { ...t, url: url } : t));
                                                }
                                            }
                                        })
                                    ),
                                    e('div', { style: { display: 'flex', gap: '10px', alignItems: 'center' } },
                                        e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', cursor: 'pointer' } },
                                            e('input', { 
                                                type: 'checkbox', 
                                                className: 'form-checkbox',
                                                checked: track.loop !== false,
                                                onChange: (ev) => setBgmTracks(bgmTracks.map(t => t.id === track.id ? { ...t, loop: ev.target.checked } : t))
                                            }),
                                            'Loop'
                                        ),
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.65rem' } },
                                            'Vol:',
                                            e('input', { 
                                                type: 'number', 
                                                min: '0', 
                                                max: '100', 
                                                className: 'form-input',
                                                style: { width: '50px' },
                                                value: track.volume || 100, 
                                                onChange: (ev) => setBgmTracks(bgmTracks.map(t => t.id === track.id ? { ...t, volume: Math.max(0, Math.min(100, parseInt(ev.target.value) || 100)) } : t))
                                            })
                                        )
                                    )
                                )
                            ),
                            e('button', { 
                                className: 'add-btn',
                                onClick: () => setBgmTracks([...bgmTracks, { id: 'bgm_' + Date.now(), name: 'BGM ' + (bgmTracks.length + 1), url: '', loop: true, volume: 100 }])
                            }, '+ Add BGM Track'),
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Inventory Display Settings'),
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Position'),
                                e('select', { 
                                    className: 'form-select', 
                                    value: inventorySettings.position || 'bottom-left',
                                    onChange: (ev) => setInventorySettings({ ...inventorySettings, position: ev.target.value })
                                },
                                    e('option', { value: 'bottom-left' }, 'Bottom Left'),
                                    e('option', { value: 'bottom-right' }, 'Bottom Right'),
                                    e('option', { value: 'top-left' }, 'Top Left'),
                                    e('option', { value: 'top-right' }, 'Top Right'),
                                    e('option', { value: 'custom' }, 'Custom Position')
                                )
                            ),
                            inventorySettings.position === 'custom' && e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px' } },
                                e('div', { className: 'form-group', style: { marginBottom: 0 } },
                                    e('label', { className: 'form-label' }, 'X'),
                                    e('input', { 
                                        type: 'number', 
                                        className: 'form-input', 
                                        value: inventorySettings.x || 20,
                                        onChange: (ev) => setInventorySettings({ ...inventorySettings, x: parseInt(ev.target.value) || 0 })
                                    })
                                ),
                                e('div', { className: 'form-group', style: { marginBottom: 0 } },
                                    e('label', { className: 'form-label' }, 'Y'),
                                    e('input', { 
                                        type: 'number', 
                                        className: 'form-input', 
                                        value: inventorySettings.y || 20,
                                        onChange: (ev) => setInventorySettings({ ...inventorySettings, y: parseInt(ev.target.value) || 0 })
                                    })
                                )
                            ),
                            e('div', { className: 'info-box', style: { marginTop: '10px' } }, 'Use event actions "BGM Play", "BGM Stop", "Show Inventory", "Hide Inventory" to control during gameplay.'),
                            
                            e('div', { className: 'section-title', style: { marginTop: '20px' } }, 'ðŸ› ï¸ Developer Tools'),
                            
                            // Current Step ID
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Current Step ID'),
                                e('div', { style: { display: 'flex', gap: '5px' } },
                                    e('input', { 
                                        className: 'form-input', 
                                        value: currentStep?.id || '', 
                                        readOnly: true,
                                        style: { flex: 1, fontSize: '0.65rem', background: '#0d1117' }
                                    }),
                                    e('button', { 
                                        className: 'btn btn-secondary btn-small',
                                        onClick: () => {
                                            navigator.clipboard.writeText(currentStep?.id || '');
                                            alert('Step ID copied!');
                                        }
                                    }, 'ðŸ“‹')
                                )
                            ),
                            
                            // Home Step ID
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Home Step ID (Step 1)'),
                                e('div', { style: { display: 'flex', gap: '5px' } },
                                    e('input', { 
                                        className: 'form-input', 
                                        value: steps[0]?.id || '', 
                                        readOnly: true,
                                        style: { flex: 1, fontSize: '0.65rem', background: '#0d1117' }
                                    }),
                                    e('button', { 
                                        className: 'btn btn-secondary btn-small',
                                        onClick: () => {
                                            navigator.clipboard.writeText(steps[0]?.id || '');
                                            alert('Home Step ID copied!');
                                        }
                                    }, 'ðŸ“‹')
                                )
                            ),
                            
                            // LocalStorage Template
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Storage Key: ' + (saveKey ? 'storyGameSave_' + saveKey : 'storyGameSave (legacy)')),
                                e('textarea', { 
                                    className: 'form-textarea', 
                                    readOnly: true,
                                    style: { fontSize: '0.6rem', background: '#0d1117', minHeight: '120px', fontFamily: 'monospace' },
                                    value: JSON.stringify({
                                        stepId: steps[0]?.id || 'step_xxx',
                                        inventory: inventory.map(i => i.name || i),
                                        varying: varyingItems.reduce((acc, vi) => { acc[vi.name] = 0; return acc; }, {})
                                    }, null, 2)
                                }),
                                e('button', { 
                                    className: 'btn btn-secondary btn-small',
                                    style: { marginTop: '5px', width: '100%' },
                                    onClick: () => {
                                        const template = JSON.stringify({
                                            stepId: steps[0]?.id || 'step_xxx',
                                            inventory: inventory.map(i => i.name || i),
                                            varying: varyingItems.reduce((acc, vi) => { acc[vi.name] = 0; return acc; }, {})
                                        }, null, 2);
                                        navigator.clipboard.writeText(template);
                                        alert('Template copied!');
                                    }
                                }, 'ðŸ“‹ Copy Template'),
                                e('button', { 
                                    className: 'btn btn-secondary btn-small',
                                    style: { marginTop: '5px', width: '100%' },
                                    onClick: () => {
                                        navigator.clipboard.writeText(saveKey ? 'storyGameSave_' + saveKey : 'storyGameSave');
                                        alert('Storage key copied!');
                                    }
                                }, 'ðŸ“‹ Copy Storage Key')
                            ),
                            e('div', { className: 'info-box' }, 'Use this key in your minigame: localStorage.getItem("' + (saveKey ? 'storyGameSave_' + saveKey : 'storyGameSave') + '")')
                        )
                    ) : e('div', { className: 'info-box' }, 'â† Create a step')
                )
            );
        }

        function PlayMode({ steps, inventory, varyingItems, onExit, startStepId, bgmTracks, inventorySettings, canvasMode }) {
            const [currentStepId, setCurrentStepId] = useState(startStepId || steps[0]?.id);
            const [visibleElements, setVisibleElements] = useState({});
            const [playerInventory, setPlayerInventory] = useState([]);
            const [playerVaryingValues, setPlayerVaryingValues] = useState({});
            const [activeTimers, setActiveTimers] = useState({});
            const [eventTimers, setEventTimers] = useState([]);
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
            const [hidingElements, setHidingElements] = useState({});
            const [currentBgmId, setCurrentBgmId] = useState(null);
            const [activeEmbed, setActiveEmbed] = useState(null);
            const [embedCloseVisible, setEmbedCloseVisible] = useState(true);
            const [showInventoryDisplay, setShowInventoryDisplay] = useState(inventorySettings?.showInventory !== false);
            const [showVaryingDisplay, setShowVaryingDisplay] = useState(inventorySettings?.showVarying !== false);
            const [hiddenInvItems, setHiddenInvItems] = useState({});
            const [hiddenVaryItems, setHiddenVaryItems] = useState({});
            const [playScale, setPlayScale] = useState(1);
            const bgmRefs = useRef({});
            
            // Canvas dimensions based on mode
            const playCanvasWidth = canvasMode === 'portrait' ? 576 : 1024;
            const playCanvasHeight = canvasMode === 'portrait' ? 1024 : 576;
            
            // Calculate scale to fit viewport
            useEffect(() => {
                const updatePlayScale = () => {
                    const vw = window.innerWidth;
                    const vh = window.innerHeight;
                    const scaleX = vw / playCanvasWidth;
                    const scaleY = vh / playCanvasHeight;
                    setPlayScale(Math.min(scaleX, scaleY, 1));
                };
                updatePlayScale();
                window.addEventListener('resize', updatePlayScale);
                return () => window.removeEventListener('resize', updatePlayScale);
            }, [canvasMode]);

            // Handle embed close button delay
            useEffect(() => {
                if (activeEmbed) {
                    const embedElem = steps.find(s => s.id === currentStepId)?.elements.find(el => el.id === activeEmbed);
                    const delay = embedElem?.embedCloseDelay || 0;
                    if (delay > 0) {
                        setEmbedCloseVisible(false);
                        const timer = setTimeout(() => setEmbedCloseVisible(true), delay * 1000);
                        return () => clearTimeout(timer);
                    } else {
                        setEmbedCloseVisible(true);
                    }
                }
            }, [activeEmbed]);

            const currentStep = steps.find(s => s.id === currentStepId);

            useEffect(() => {
                eventTimers.forEach(timer => clearTimeout(timer));
                setEventTimers([]);
                setActiveTimers({});  // Clear all active timers when step changes
                setHidingElements({}); // Clear hiding state
                
                if (!currentStep) return;

                if (currentStep.password) {
                    const pwd = prompt('Enter password:');
                    if (pwd !== currentStep.password) {
                        if (currentStep.wrongPasswordStep) {
                            setCurrentStepId(currentStep.wrongPasswordStep);
                        } else {
                            alert('Wrong password!');
                            onExit();
                        }
                        return;
                    }
                }

                const visible = {};
                const newTimers = [];
                currentStep.elements.forEach(elem => {
                    visible[elem.id] = elem.visible;
                    // Set duration timers for elements with duration > 0
                    if (elem.visible && elem.duration && elem.duration > 0) {
                        const timer = setTimeout(() => {
                            setVisibleElements(prev => ({ ...prev, [elem.id]: false }));
                        }, elem.duration * 1000);
                        newTimers.push(timer);
                    }
                });
                setVisibleElements(visible);
                
                // Process onLoad and afterDelay events
                currentStep.events.forEach(event => {
                    if (checkCondition(event.condition)) {
                        if (event.trigger.type === 'onLoad') {
                            processActions(event.actions);
                        } else if (event.trigger.type === 'afterDelay') {
                            const timer = setTimeout(() => processActions(event.actions), (event.trigger.delay || 0) * 1000);
                            newTimers.push(timer);
                        }
                    }
                });
                
                // Start timers AFTER onLoad events (so hidden timers don't start)
                setTimeout(() => {
                    const currentVisibility = visibleElements;
                    currentStep.elements.forEach(elem => {
                        if (elem.type === 'timer' && currentVisibility[elem.id] !== false && visible[elem.id]) {
                            let remaining = elem.countdown;
                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                            const interval = setInterval(() => {
                                remaining--;
                                setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                if (remaining <= 0) {
                                    clearInterval(interval);
                                    currentStep.events.forEach(event => {
                                        if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                            if (checkCondition(event.condition)) {
                                                processActions(event.actions);
                                            }
                                        }
                                    });
                                }
                            }, 1000);
                            newTimers.push(interval);
                        }
                    });
                    setEventTimers(newTimers);
                }, 100);
                
                setEventTimers(newTimers);

                return () => {
                    newTimers.forEach(timer => clearTimeout(timer));
                };
            }, [currentStepId]);

            const checkCondition = (condition) => {
                if (!condition) return true;
                if (condition.type === 'hasItem') {
                    // Support both old single item and new items array
                    const items = condition.items || (condition.item ? [condition.item] : []);
                    if (items.length === 0) return true;
                    const logic = condition.logic || 'any';
                    if (logic === 'all') {
                        return items.every(item => playerInventory.includes(item));
                    } else {
                        return items.some(item => playerInventory.includes(item));
                    }
                } else if (condition.type === 'notHasItem') {
                    // Support both old single item and new items array
                    const items = condition.items || (condition.item ? [condition.item] : []);
                    if (items.length === 0) return true;
                    const logic = condition.logic || 'any';
                    if (logic === 'all') {
                        // ALL means: does NOT have ALL of these (missing at least one)
                        return !items.every(item => playerInventory.includes(item));
                    } else {
                        // ANY means: does NOT have ANY of these (missing all)
                        return items.every(item => !playerInventory.includes(item));
                    }
                } else if (condition.type === 'varyingAtLeast') {
                    return (playerVaryingValues[condition.item] || 0) >= (condition.amount || 0);
                } else if (condition.type === 'varyingAtMost') {
                    return (playerVaryingValues[condition.item] || 0) <= (condition.amount || 0);
                } else if (condition.type === 'varyingBetween') {
                    const val = playerVaryingValues[condition.item] || 0;
                    return val >= (condition.min || 0) && val <= (condition.max || 0);
                }
                return true;
            };

            const processActions = (actions) => {
                actions.forEach(action => {
                    if (action.type === 'show' || action.type === 'showDelay') {
                        const showAction = () => {
                            if (action.targets && action.targets.length > 0) {
                                action.targets.forEach(targetId => {
                                    setVisibleElements(prev => ({ ...prev, [targetId]: true }));
                                    const elem = currentStep.elements.find(e => e.id === targetId);
                                    if (elem) {
                                        // Start timer if it's a timer element
                                        if (elem.type === 'timer') {
                                            let remaining = elem.countdown;
                                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                            const interval = setInterval(() => {
                                                remaining--;
                                                setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                                if (remaining <= 0) {
                                                    clearInterval(interval);
                                                    currentStep.events.forEach(event => {
                                                        if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                                            if (checkCondition(event.condition)) {
                                                                processActions(event.actions);
                                                            }
                                                        }
                                                    });
                                                }
                                            }, 1000);
                                            setEventTimers(prev => [...prev, interval]);
                                        }
                                        // Handle duration
                                        if (elem.duration && elem.duration > 0) {
                                            const timer = setTimeout(() => {
                                                setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                            }, elem.duration * 1000);
                                            setEventTimers(prev => [...prev, timer]);
                                        }
                                    }
                                });
                            } else if (action.target) {
                                setVisibleElements(prev => ({ ...prev, [action.target]: true }));
                                const elem = currentStep.elements.find(e => e.id === action.target);
                                if (elem) {
                                    // Start timer if it's a timer element
                                    if (elem.type === 'timer') {
                                        let remaining = elem.countdown;
                                        setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                        const interval = setInterval(() => {
                                            remaining--;
                                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                            if (remaining <= 0) {
                                                clearInterval(interval);
                                                currentStep.events.forEach(event => {
                                                    if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                                        if (checkCondition(event.condition)) {
                                                            processActions(event.actions);
                                                        }
                                                    }
                                                });
                                            }
                                        }, 1000);
                                        setEventTimers(prev => [...prev, interval]);
                                    }
                                    // Handle duration
                                    if (elem.duration && elem.duration > 0) {
                                        const timer = setTimeout(() => {
                                            setVisibleElements(prev => ({ ...prev, [action.target]: false }));
                                        }, elem.duration * 1000);
                                        setEventTimers(prev => [...prev, timer]);
                                    }
                                }
                            }
                        };
                        if (action.type === 'showDelay' && action.delay) {
                            const timer = setTimeout(showAction, action.delay * 1000);
                            setEventTimers(prev => [...prev, timer]);
                        } else {
                            showAction();
                        }
                    } else if (action.type === 'hide' || action.type === 'hideDelay') {
                        const hideAction = () => {
                            const elementsToHide = action.targets && action.targets.length > 0 ? action.targets : [action.target];
                            elementsToHide.forEach(targetId => {
                                if (!targetId) return;
                                const elem = currentStep.elements.find(e => e.id === targetId);
                                const outTrans = elem?.transitionOut && elem.transitionOut !== 'none' ? elem.transitionOut : elem?.transition;
                                const outDur = elem?.transitionOut && elem.transitionOut !== 'none' ? (elem.transitionOutDuration || 0.5) : (elem?.transitionDuration || 0.5);
                                if (outTrans && outTrans !== 'none') {
                                    // Mark as hiding to show out-transition
                                    setHidingElements(prev => ({ ...prev, [targetId]: true }));
                                    // Actually hide after transition duration
                                    const duration = outDur * 1000;
                                    const timer = setTimeout(() => {
                                        setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                        setHidingElements(prev => ({ ...prev, [targetId]: false }));
                                    }, duration);
                                    setEventTimers(prev => [...prev, timer]);
                                } else {
                                    // No transition, hide immediately
                                    setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                }
                            });
                        };
                        if (action.type === 'hideDelay' && action.delay) {
                            const timer = setTimeout(hideAction, action.delay * 1000);
                            setEventTimers(prev => [...prev, timer]);
                        } else {
                            hideAction();
                        }
                    } else if (action.type === 'goto') {
                        if (action.targets && action.targets.length > 0) {
                            // Random selection from multiple steps
                            const randomStep = action.targets[Math.floor(Math.random() * action.targets.length)];
                            setCurrentStepId(randomStep);
                        } else if (action.target) {
                            setCurrentStepId(action.target);
                        }
                    } else if (action.type === 'addItem') {
                        setPlayerInventory(prev => prev.includes(action.target) ? prev : [...prev, action.target]);
                    } else if (action.type === 'removeItem') {
                        setPlayerInventory(prev => prev.filter(item => item !== action.target));
                    } else if (action.type === 'addVarying') {
                        setPlayerVaryingValues(prev => ({ ...prev, [action.target]: (prev[action.target] || 0) + (action.amount || 0) }));
                    } else if (action.type === 'subtractVarying') {
                        setPlayerVaryingValues(prev => ({ ...prev, [action.target]: (prev[action.target] || 0) - (action.amount || 0) }));
                    } else if (action.type === 'setVarying') {
                        setPlayerVaryingValues(prev => ({ ...prev, [action.target]: action.amount || 0 }));
                    } else if (action.type === 'bgmPlay') {
                        // Stop any currently playing BGM first
                        if (currentBgmId && bgmRefs.current[currentBgmId]) {
                            bgmRefs.current[currentBgmId].pause();
                            bgmRefs.current[currentBgmId].currentTime = 0;
                        }
                        // Play the selected track
                        const trackId = action.target;
                        const track = bgmTracks.find(t => t.id === trackId);
                        if (trackId && bgmRefs.current[trackId] && track) {
                            bgmRefs.current[trackId].volume = (track.volume || 100) / 100;
                            bgmRefs.current[trackId].play().catch(() => {});
                            setCurrentBgmId(trackId);
                        }
                    } else if (action.type === 'bgmStop') {
                        // Stop all BGM tracks
                        Object.keys(bgmRefs.current).forEach(id => {
                            if (bgmRefs.current[id]) {
                                bgmRefs.current[id].pause();
                                bgmRefs.current[id].currentTime = 0;
                            }
                        });
                        setCurrentBgmId(null);
                    } else if (action.type === 'showInventory') {
                        setShowInventoryDisplay(true);
                    } else if (action.type === 'hideInventory') {
                        setShowInventoryDisplay(false);
                    } else if (action.type === 'showInvItem') {
                        if (action.target) setHiddenInvItems(prev => ({ ...prev, [action.target]: false }));
                    } else if (action.type === 'hideInvItem') {
                        if (action.target) setHiddenInvItems(prev => ({ ...prev, [action.target]: true }));
                    } else if (action.type === 'showVarying') {
                        setShowVaryingDisplay(true);
                    } else if (action.type === 'hideVarying') {
                        setShowVaryingDisplay(false);
                    } else if (action.type === 'showVaryItem') {
                        if (action.target) setHiddenVaryItems(prev => ({ ...prev, [action.target]: false }));
                    } else if (action.type === 'hideVaryItem') {
                        if (action.target) setHiddenVaryItems(prev => ({ ...prev, [action.target]: true }));
                    } else if (action.type === 'saveState') {
                        const saveData = {
                            stepId: currentStepId,
                            inventory: playerInventory,
                            varying: playerVaryingValues
                        };
                        localStorage.setItem('storyGameSave', JSON.stringify(saveData));
                    } else if (action.type === 'loadState') {
                        const saveData = localStorage.getItem('storyGameSave');
                        if (saveData) {
                            const parsed = JSON.parse(saveData);
                            setPlayerInventory(parsed.inventory || []);
                            setPlayerVaryingValues(parsed.varying || {});
                            if (parsed.stepId) {
                                setCurrentStepId(parsed.stepId);
                            }
                        }
                    } else if (action.type === 'clearState') {
                        localStorage.removeItem('storyGameSave');
                    }
                });
            };

            const handleVideoEnd = (elem) => {
                if (!currentStep) return;
                currentStep.events.forEach(event => {
                    if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                        if (checkCondition(event.condition)) {
                            processActions(event.actions);
                        }
                    }
                });
            };

            const handleClick = (elem) => {
                if (!currentStep) return;
                if (elem.type === 'hotspot' && (elem.hotspotMode === 'drop')) return;
                
                currentStep.events.forEach(event => {
                    if (event.trigger.type === 'onClick') {
                        // Support both old single sourceElement and new sourceElements array
                        const sources = event.trigger.sourceElements || (event.trigger.sourceElement ? [event.trigger.sourceElement] : []);
                        if (sources.includes(elem.id)) {
                            if (checkCondition(event.condition)) {
                                processActions(event.actions);
                            }
                        }
                    }
                });
            };

            const handleDragStart = (ev, elem) => {
                ev.preventDefault();
                const rect = ev.currentTarget.getBoundingClientRect();
                const canvas = document.querySelector('.play-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                setDragOffset({
                    x: ev.clientX - rect.left,
                    y: ev.clientY - rect.top
                });
                setDraggedItem(elem);
                setDragPos({ x: ev.clientX - canvasRect.left, y: ev.clientY - canvasRect.top });
            };

            const handleDragMove = (ev) => {
                if (!draggedItem) return;
                ev.preventDefault();
                const canvas = document.querySelector('.play-canvas');
                const rect = canvas.getBoundingClientRect();
                setDragPos({ x: ev.clientX - rect.left, y: ev.clientY - rect.top });
            };

            const handleDragEnd = (ev) => {
                if (!draggedItem) return;
                
                const canvas = document.querySelector('.play-canvas');
                const rect = canvas.getBoundingClientRect();
                const dropX = ev.clientX - rect.left;
                const dropY = ev.clientY - rect.top;

                currentStep.elements.filter(e => e.type === 'hotspot' && visibleElements[e.id] && (e.hotspotMode !== 'click')).forEach(hotspot => {
                    if (dropX >= hotspot.x && dropX <= hotspot.x + hotspot.width && 
                        dropY >= hotspot.y && dropY <= hotspot.y + hotspot.height) {
                        currentStep.events.forEach(event => {
                            if (event.trigger.type === 'onDrop' && event.trigger.sourceElement === hotspot.id) {
                                if (checkCondition(event.condition)) {
                                    processActions(event.actions);
                                }
                            }
                        });
                    }
                });

                setDraggedItem(null);
            };

            useEffect(() => {
                if (draggedItem) {
                    document.addEventListener('mousemove', handleDragMove);
                    document.addEventListener('mouseup', handleDragEnd);
                    return () => {
                        document.removeEventListener('mousemove', handleDragMove);
                        document.removeEventListener('mouseup', handleDragEnd);
                    };
                }
            }, [draggedItem]);

            if (!currentStep) {
                return e('div', { className: 'play-overlay' },
                    e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', color: '#fff', fontSize: '1.5rem' } }, 'Story ended')
                );
            }

            // Get inventory position
            const getInvStyle = () => {
                const pos = inventorySettings?.position || 'bottom-left';
                if (pos === 'custom') return { left: (inventorySettings?.x || 20) + 'px', top: (inventorySettings?.y || 20) + 'px' };
                if (pos === 'bottom-left') return { bottom: '20px', left: '20px' };
                if (pos === 'bottom-right') return { bottom: '20px', right: '20px' };
                if (pos === 'top-left') return { top: '20px', left: '20px' };
                if (pos === 'top-right') return { top: '20px', right: '20px' };
                return { bottom: '20px', left: '20px' };
            };

            // Get visible inventory items (check both global visibility and per-item runtime visibility)
            const visibleInvItems = playerInventory.filter(itemName => {
                const invItem = inventory.find(i => (i.name || i) === itemName);
                if (!invItem) return false;
                // Check if item is hidden at runtime
                if (hiddenInvItems[itemName]) return false;
                // Check global item visibility setting
                if (typeof invItem === 'string') return true;
                return invItem.visible !== false;
            });

            // Get visible varying items (check both global visibility and per-item runtime visibility)
            const visibleVaryingItems = varyingItems.filter(vi => {
                // Check if item is hidden at runtime
                if (hiddenVaryItems[vi.name]) return false;
                // Check global item visibility setting
                return vi.visible !== false;
            });

            return e('div', { className: 'play-overlay' },
                // BGM Audio element
                // BGM Audio elements for all tracks
                bgmTracks.map(track => 
                    track.url && e('audio', {
                        key: track.id,
                        ref: (el) => { bgmRefs.current[track.id] = el; },
                        loop: track.loop !== false,
                        preload: 'auto',
                        src: track.url
                    })
                ),
                e('button', { className: 'btn btn-danger play-exit', onClick: onExit }, 'âœ• Exit'),
                e('div', { className: 'play-canvas', style: { background: currentStep.bgColor || '#000', width: playCanvasWidth + 'px', height: playCanvasHeight + 'px', transform: 'translate(-50%, -50%) scale(' + playScale + ')' } },
                    currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                        e('div', {
                            key: shape.id,
                            style: {
                                position: 'absolute',
                                left: shape.x + 'px',
                                top: shape.y + 'px',
                                width: shape.width + 'px',
                                height: shape.height + 'px',
                                background: shape.color,
                                borderRadius: shape.type === 'circle' ? '50%' : '0',
                                zIndex: 0
                            }
                        })
                    ),
                    currentStep.elements
                        .filter(elem => visibleElements[elem.id] || hidingElements[elem.id])
                        .sort((a, b) => a.layer - b.layer)
                        .map(elem => {
                            const isHiding = hidingElements[elem.id];
                            // Determine outro transition: 'none' = instant, 'matchIntro' = use intro animation, specific value = use that
                            const outTrans = isHiding ? 
                                (elem.transitionOut === 'none' ? null : 
                                 elem.transitionOut === 'matchIntro' || !elem.transitionOut ? elem.transition : 
                                 elem.transitionOut) : null;
                            const transClass = isHiding ? 
                                (outTrans && outTrans !== 'none' ? 'trans-' + outTrans + '-out' : '') :
                                (elem.transition && elem.transition !== 'none' ? 'trans-' + elem.transition : '');
                            // Duration animation applied independently on inner wrapper
                            const duringClass = elem.animationDuring && elem.animationDuring !== 'none' && !isHiding ? 'anim-' + elem.animationDuring : '';
                            const transDur = isHiding ? (elem.transitionOutDuration || elem.transitionDuration || 0.5) : (elem.transitionDuration || 0.5);
                            // Delay the during animation until intro finishes
                            const duringDelay = (!isHiding && elem.transition && elem.transition !== 'none') ? (elem.transitionDuration || 0.5) : 0;
                            return e('div', {
                                key: elem.id,
                                className: transClass.trim(),
                                onMouseDown: elem.type === 'draggable' ? (ev) => handleDragStart(ev, elem) : undefined,
                                style: {
                                    position: 'absolute',
                                    left: (draggedItem?.id === elem.id ? dragPos.x - dragOffset.x : elem.x) + 'px',
                                    top: (draggedItem?.id === elem.id ? dragPos.y - dragOffset.y : elem.y) + 'px',
                                    width: elem.width + 'px',
                                    height: elem.height + 'px',
                                    zIndex: draggedItem?.id === elem.id ? 9999 : elem.layer,
                                    cursor: elem.type === 'draggable' ? (draggedItem?.id === elem.id ? 'grabbing' : 'grab') : (elem.type === 'button' || (elem.type === 'hotspot' && elem.hotspotMode !== 'drop')) ? 'pointer' : 'default',
                                    borderRadius: elem.shape === 'circle' ? '50%' : '0',
                                    opacity: draggedItem?.id === elem.id ? 0.7 : 1,
                                    animationDuration: transDur + 's'
                                },
                                onClick: () => handleClick(elem)
                            },
                                // Wrapper for during animation (applied after intro)
                                e('div', {
                                    className: duringClass,
                                    style: {
                                        width: '100%',
                                        height: '100%',
                                        animationDelay: duringDelay + 's'
                                    }
                                },
                                elem.type === 'image' && elem.content && (elem.cropEnabled ? 
                                    e('div', { style: { width: '100%', height: '100%', overflow: 'hidden', position: 'relative' } },
                                        e('img', { 
                                            src: elem.content, 
                                            style: { 
                                                position: 'absolute',
                                                width: (100 / (elem.cropW || 100)) * 100 + '%',
                                                height: (100 / (elem.cropH || 100)) * 100 + '%',
                                                left: -(elem.cropX || 0) / (elem.cropW || 100) * 100 + '%',
                                                top: -(elem.cropY || 0) / (elem.cropH || 100) * 100 + '%',
                                                objectFit: 'cover',
                                                pointerEvents: 'none',
                                                transform: 'scale(' + (elem.flipH ? -1 : 1) + ', ' + (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)', 
                                                opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100 
                                            } 
                                        })
                                    ) :
                                    e('img', { src: elem.content, style: { width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none', transform: 'scale(' + (elem.flipH ? -1 : 1) + ', ' + (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)', opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100 } })
                                ),
                                elem.type === 'video' && elem.content && e('video', { 
                                    src: elem.content, 
                                    autoPlay: elem.autoplay, 
                                    loop: elem.loop, 
                                    playsInline: true, 
                                    onEnded: () => !elem.loop && handleVideoEnd(elem),
                                    style: { width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none' } 
                                }),
                                elem.type === 'text' && e('div', { 
                                    className: 'element-text', 
                                    style: { 
                                        fontSize: (elem.textSize || 24) + 'px',
                                        color: elem.textColor || '#ffffff',
                                        fontWeight: elem.textBold ? 'bold' : 'normal',
                                        fontStyle: elem.textItalic ? 'italic' : 'normal',
                                        textDecoration: elem.textUnderline ? 'underline' : 'none',
                                        border: elem.textBorder ? ((elem.textBorderWidth || 2) + 'px solid ' + (elem.textBorderColor || '#ffffff')) : 'none',
                                        background: elem.textBgColor ? 
                                            (elem.textBgColor.startsWith('#') ? 
                                                elem.textBgColor + Math.round((elem.textBgOpacity !== undefined ? elem.textBgOpacity : 0.8) * 255).toString(16).padStart(2, '0') : 
                                                elem.textBgColor) : 
                                            ('rgba(0,0,0,' + (elem.textBgOpacity !== undefined ? elem.textBgOpacity : 0.8) + ')')
                                    } 
                                }, elem.content),
                                elem.type === 'button' && e('div', { 
                                    className: 'element-button' + (elem.buttonPulse ? ' anim-buttonPulse' : ''), 
                                    style: { 
                                        background: elem.color, 
                                        color: elem.buttonTextColor || '#ffffff', 
                                        fontSize: (elem.buttonTextSize || 20) + 'px',
                                        boxShadow: elem.buttonShadow ? '0 4px 15px rgba(0,0,0,0.4)' : 'none'
                                    } 
                                }, elem.content || 'Button'),
                                elem.type === 'audio' && elem.content && e('audio', { src: elem.content, autoPlay: elem.autoplay, loop: elem.loop, onEnded: () => !elem.loop && handleVideoEnd(elem) }),
                                elem.type === 'timer' && e('div', { className: 'element-timer' }, activeTimers[elem.id] !== undefined ? activeTimers[elem.id] : elem.countdown),
                                elem.type === 'draggable' && (
                                    elem.contentType === 'image' && elem.content ? 
                                        e('img', { src: elem.content, style: { width: '100%', height: '100%', objectFit: 'contain', pointerEvents: 'none' } }) :
                                        e('div', { style: { fontSize: elem.fontSize + 'px', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', pointerEvents: 'none' } }, elem.content || 'ðŸ“¦')
                                ),
                                elem.type === 'hotspot' && elem.showInGame && e('div', { style: { width: '100%', height: '100%', border: '3px dashed rgba(255,0,0,0.5)', background: 'rgba(255,0,0,0.05)' } }),
                                elem.type === 'object' && e('div', { 
                                    style: { 
                                        width: '100%', 
                                        height: '100%', 
                                        background: elem.objectColor || elem.color || '#f7931a',
                                        borderRadius: elem.objectShape === 'circle' ? '50%' : '0',
                                        clipPath: elem.objectShape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none',
                                        transform: 'scale(' + (elem.scaleX || 1) * (elem.flipH ? -1 : 1) + ', ' + (elem.scaleY || 1) * (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)',
                                        opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100
                                    }
                                }),
                                elem.type === 'embed' && e('div', {
                                    style: {
                                        width: '100%',
                                        height: '100%',
                                        background: elem.embedThumbnail ? 'transparent' : 'rgba(128,0,255,0.3)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        color: '#fff',
                                        fontSize: '1.5rem',
                                        cursor: 'pointer',
                                        position: 'relative'
                                    },
                                    onClick: (ev) => {
                                        ev.stopPropagation();
                                        setActiveEmbed(elem.id);
                                    }
                                }, 
                                    elem.embedThumbnail ? 
                                        e('img', { src: elem.embedThumbnail, style: { width: '100%', height: '100%', objectFit: 'cover' } }) :
                                        'â–¶ Click to Open'
                                )
                                ) // Close inner wrapper div
                            );
                        }),
                    // Active embed iframe
                    activeEmbed && (() => {
                        const embedElem = currentStep.elements.find(el => el.id === activeEmbed);
                        if (!embedElem) return null;
                        return e('div', {
                            style: {
                                position: 'absolute',
                                top: 0,
                                left: 0,
                                width: '100%',
                                height: '100%',
                                background: '#000',
                                zIndex: 9999
                            }
                        },
                            e('iframe', {
                                src: embedElem.embedUrl,
                                style: { width: '100%', height: '100%', border: 'none' },
                                sandbox: embedElem.embedAllowNavigation ? undefined : 'allow-scripts allow-same-origin'
                            }),
                            embedCloseVisible && e('button', {
                                style: {
                                    position: 'absolute',
                                    bottom: '10px',
                                    right: '10px',
                                    width: '36px',
                                    height: '36px',
                                    background: '#ef4444',
                                    border: 'none',
                                    borderRadius: '50%',
                                    color: 'white',
                                    fontSize: '20px',
                                    cursor: 'pointer',
                                    zIndex: 10000,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                },
                                onClick: () => {
                                    setActiveEmbed(null);
                                    // Trigger onEmbedClose events
                                    currentStep.events.forEach(event => {
                                        if (event.trigger.type === 'onEmbedClose' && event.trigger.sourceElement === activeEmbed) {
                                            if (checkCondition(event.condition)) {
                                                processActions(event.actions);
                                            }
                                        }
                                    });
                                }
                            }, 'âœ•')
                        );
                    })()
                ),
                // Combined inventory and varying display
                (showInventoryDisplay || showVaryingDisplay) && (visibleInvItems.length > 0 || visibleVaryingItems.length > 0) && e('div', { 
                    style: {
                        position: 'fixed',
                        ...getInvStyle(),
                        background: 'rgba(0,0,0,0.8)',
                        padding: '10px 15px',
                        borderRadius: '8px',
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '8px',
                        zIndex: 100,
                        minWidth: '120px'
                    }
                },
                    // Inventory items
                    showInventoryDisplay && visibleInvItems.map(itemName => {
                        const invItem = inventory.find(i => (i.name || i) === itemName);
                        const displayName = invItem && invItem.displayName ? invItem.displayName : itemName;
                        return e('div', { 
                            key: itemName, 
                            style: { 
                                display: 'flex', 
                                alignItems: 'center', 
                                gap: '8px',
                                color: '#f59e0b',
                                fontSize: '14px',
                                fontWeight: 'bold'
                            } 
                        },
                            e('span', { style: { color: '#fff' } }, 'â€¢ ' + displayName)
                        );
                    }),
                    // Varying items
                    showVaryingDisplay && visibleVaryingItems.map(vi => 
                        e('div', { 
                            key: vi.name, 
                            style: { 
                                display: 'flex', 
                                alignItems: 'center', 
                                gap: '8px',
                                color: '#f59e0b',
                                fontSize: '14px',
                                fontWeight: 'bold'
                            } 
                        },
                            e('span', { style: { color: '#fff' } }, (vi.displayName || vi.name) + ':'),
                            e('span', null, playerVaryingValues[vi.name] || 0)
                        )
                    )
                )
            );
        }

        function generateHTML(steps, inventory, varyingItems, options = {}, bgmTracks = [], inventorySettings = {}, canvasModeParam = 'landscape', saveKeyParam = '') {
            const { includeRefreshButton = false, optimizeVideoLoading = false, compactLandscape = false, fitToViewport = false } = options;
            const cWidth = canvasModeParam === 'portrait' ? 576 : 1024;
            const cHeight = canvasModeParam === 'portrait' ? 1024 : 576;
            const aspectRatio = cWidth / cHeight;
            const storageKey = saveKeyParam ? 'storyGameSave_' + saveKeyParam : 'storyGameSave';
            
            // Calculate inventory position styles
            const getInvPosition = () => {
                const pos = inventorySettings.position || 'bottom-left';
                if (pos === 'custom') return 'left:' + (inventorySettings.x || 20) + 'px;top:' + (inventorySettings.y || 20) + 'px;';
                if (pos === 'bottom-left') return 'bottom:20px;left:20px;';
                if (pos === 'bottom-right') return 'bottom:20px;right:20px;';
                if (pos === 'top-left') return 'top:20px;left:20px;';
                if (pos === 'top-right') return 'top:20px;right:20px;';
                return 'bottom:20px;left:20px;';
            };
            
            // Generate fit-to-viewport CSS and JS
            const fitToViewportCSS = fitToViewport ? `
        .canvas { transform-origin: center center; }` : '';
            
            const fitToViewportJS = fitToViewport ? `
function fitCanvasToViewport() {
    const canvas = document.getElementById("game");
    const cw = ${cWidth};
    const ch = ${cHeight};
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const scaleX = vw / cw;
    const scaleY = vh / ch;
    const scale = Math.min(scaleX, scaleY);
    canvas.style.transform = "translate(-50%, -50%) scale(" + scale + ")";
}
fitCanvasToViewport();
window.addEventListener("resize", fitCanvasToViewport);
` : '';
            
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Story</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        .canvas { width: ${cWidth}px; height: ${cHeight}px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); transform-origin: center center; }
        ${compactLandscape && canvasModeParam === 'landscape' ? '@media (orientation: landscape) { .canvas { transform: translate(-50%, -50%) scale(0.85); } }' : ''}${fitToViewportCSS}
        .elem { position: absolute; }
        .elem img, .elem video { width: 100%; height: 100%; object-fit: cover; }
        .elem video { pointer-events: none; }
        .elem video::-webkit-media-controls { display: none !important; }
        .elem video::-webkit-media-controls-enclosure { display: none !important; }
        .elem-text { padding: 15px; border-radius: 6px; text-align: center; white-space: pre-wrap; }
        .elem-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .elem-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .elem-draggable { cursor: grab; display: flex; align-items: center; justify-content: center; user-select: none; touch-action: none; }
        .elem-draggable:active { cursor: grabbing; }
        .elem-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .elem-hotspot-visible { border: 3px dashed rgba(255,0,0,0.5); background: rgba(255,0,0,0.05); }
        .inventory-display { position: fixed; ${getInvPosition()} background: rgba(0,0,0,0.8); padding: 10px 15px; border-radius: 8px; display: flex; flex-direction: column; gap: 8px; z-index: 100; min-width: 120px; }
        .inventory-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .inventory-item-icon { width: 40px; height: 40px; background: #f7931a; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .inventory-item-name { font-size: 10px; color: #fff; text-align: center; max-width: 50px; overflow: hidden; text-overflow: ellipsis; }
        .embed-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; background: #000; }
        .embed-container iframe { width: 100%; height: 100%; border: none; }
        .embed-close { position: absolute; bottom: 10px; right: 10px; width: 36px; height: 36px; background: #ef4444; border: none; border-radius: 50%; color: white; font-size: 20px; cursor: pointer; z-index: 10000; display: flex; align-items: center; justify-content: center; }
        @keyframes buttonPulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(247,147,26,0.4); } 50% { transform: scale(1.02); box-shadow: 0 0 10px 3px rgba(247,147,26,0.3); } }
        .anim-buttonPulse { animation: buttonPulse 1.5s ease-in-out infinite; }
        ${includeRefreshButton ? `.refresh-button { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(247,147,26,0.9); color: #000; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 14px; z-index: 10000; display: none; }
        @media (orientation: portrait) { .refresh-button { display: block; } }
        .refresh-button:active { background: rgba(247,147,26,1); transform: translateX(-50%) scale(0.95); }` : ''}
        .trans-fade { animation: fadeIn 0.5s ease-in forwards; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out forwards; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out forwards; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out forwards; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out forwards; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out forwards; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes wobble { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); } 20%, 40%, 60%, 80% { transform: translateX(2px); } }
        @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        .anim-pulse { animation: pulse 1s ease-in-out infinite; }
        .anim-spin { animation: spin 2s linear infinite; }
        .anim-bounce { animation: bounce 0.5s ease-in-out infinite; }
        .anim-wobble { animation: wobble 0.5s ease-in-out infinite; }
        .anim-shake { animation: shake 0.5s ease-in-out infinite; }
        .anim-glow { animation: glow 1.5s ease-in-out infinite; }
        .anim-float { animation: float 2s ease-in-out infinite; }
        .elem-object { display: flex; align-items: center; justify-content: center; }
    </style>
</head>
<body>
    <div id="game" class="canvas"></div>
    <div id="inventory" class="inventory-display" style="display:none"></div>
    ${bgmTracks.filter(t => t.url).map(t => '<audio id="bgm_' + t.id + '" ' + (t.loop !== false ? 'loop ' : '') + 'preload="auto" data-volume="' + (t.volume || 100) + '"><source src="' + t.url + '"></audio>').join('\n    ')}
    ${includeRefreshButton ? '<div class="refresh-button" onclick="refreshCurrentStep()">âŸ³ Refresh Step</div>' : ''}
    <script>
// Story data - properly formatted with indentation for readability
const STORY_DATA = ${JSON.stringify({ steps, inventoryItems: inventory, varyingItems: varyingItems || [] }, null, 2)};

const STEPS = STORY_DATA.steps;
const INVENTORY_ITEMS = STORY_DATA.inventoryItems;
const VARYING_ITEMS = STORY_DATA.varyingItems;

let current = STEPS[0].id;
let visible = {};
let inventory = [];
let varyingValues = {};
let timers = [];
let timerCountdowns = {};
let hiding = {};
let rendered = {};
let draggedElem = null;
let dragOffset = { x: 0, y: 0 };
let dragPos = { x: 0, y: 0 };
const OPTIMIZE_VIDEO = ${optimizeVideoLoading};
const STORAGE_KEY = "${storageKey}";
let stepHistory = [];
let showInvDisplay = true;
let showVaryDisplay = true;
let hiddenInvItems = {};
let hiddenVaryItems = {};
let activeEmbed = null;
let currentBgmId = null;

// BGM Functions
function playBGM(trackId) {
    // Stop any currently playing BGM
    stopBGM();
    // Play the specified track
    const bgm = document.getElementById("bgm_" + trackId);
    if (bgm) {
        bgm.volume = (parseInt(bgm.dataset.volume) || 100) / 100;
        bgm.play().catch(() => {});
        currentBgmId = trackId;
    }
}

function stopBGM() {
    // Stop all BGM tracks
    document.querySelectorAll('audio[id^="bgm_"]').forEach(audio => {
        audio.pause();
        audio.currentTime = 0;
    });
    currentBgmId = null;
}

function showEmbed(elemId) {
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === elemId);
    if (!elem || !elem.embedUrl) return;
    
    activeEmbed = elemId;
    const game = document.getElementById("game");
    const container = document.createElement("div");
    container.className = "embed-container";
    container.id = "embed-" + elemId;
    
    const delay = elem.embedCloseDelay || 0;
    const buttonStyle = delay > 0 ? 'display:none;' : '';
    const buttonId = 'embed-close-' + elemId;
    
    container.innerHTML = '<iframe src="' + elem.embedUrl + '" ' + (elem.embedAllowNavigation ? '' : 'sandbox="allow-scripts allow-same-origin"') + '></iframe>' +
        '<button id="' + buttonId + '" class="embed-close" style="' + buttonStyle + '" onclick="closeEmbed(\\'' + elemId + '\\')">âœ•</button>';
    game.appendChild(container);
    
    // Show close button after delay
    if (delay > 0) {
        setTimeout(() => {
            const btn = document.getElementById(buttonId);
            if (btn) btn.style.display = 'flex';
        }, delay * 1000);
    }
}

function closeEmbed(elemId) {
    const container = document.getElementById("embed-" + elemId);
    if (container) container.remove();
    activeEmbed = null;
    
    // Trigger onEmbedClose events
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "onEmbedClose" && ev.trigger.sourceElement === elemId && checkCond(ev.condition)) {
            exec(ev.actions);
        }
    });
}

function cleanupOldMedia() {
    // Keep last 2 steps in history, clean up everything older
    if (stepHistory.length <= 2) return;
    
    const keepSteps = stepHistory.slice(-2); // Last 2 steps
    const currentStepId = current;
    
    // Find all media elements from old steps (not in keepSteps or current)
    const game = document.getElementById("game");
    const allElements = game.querySelectorAll('[data-elem-id]');
    
    allElements.forEach(elemDiv => {
        const elemId = elemDiv.getAttribute('data-elem-id');
        
        // Find which step this element belongs to
        let belongsToOldStep = true;
        STEPS.forEach(step => {
            if (step.id === currentStepId || keepSteps.includes(step.id)) {
                if (step.elements.some(e => e.id === elemId)) {
                    belongsToOldStep = false;
                }
            }
        });
        
        if (belongsToOldStep) {
            // Clean up media before removing
            const video = elemDiv.querySelector('video');
            const audio = elemDiv.querySelector('audio');
            const img = elemDiv.querySelector('img');
            
            if (video) {
                video.pause();
                video.removeAttribute('src');
                video.load(); // Forces browser to release memory
            }
            if (audio) {
                audio.pause();
                audio.removeAttribute('src');
                audio.load();
            }
            if (img) {
                img.removeAttribute('src');
            }
            
            // Remove from DOM
            elemDiv.remove();
        }
    });
}

function refreshCurrentStep() {
    const s = STEPS.find(x => x.id === current);
    if (!s) return;
    fullDraw();
}

function render() {
    timers.forEach(t => clearTimeout(t));
    timers = [];
    timerCountdowns = {};
    hiding = {};
    rendered = {};
    draggedElem = null;
    
    // Track step history (keep last 10 steps max)
    if (stepHistory[stepHistory.length - 1] !== current) {
        stepHistory.push(current);
        if (stepHistory.length > 10) stepHistory.shift();
    }
    
    // Clean up media from steps older than 2 steps back
    cleanupOldMedia();
    
    const s = STEPS.find(x => x.id === current);
    if (!s) return;
    
    if (s.password) {
        const pwd = prompt("Password:");
        if (pwd !== s.password) {
            if (s.wrongPasswordStep) { current = s.wrongPasswordStep; render(); return; }
            else { alert("Wrong!"); return; }
        }
    }
    
    visible = {};
    s.elements.forEach(e => {
        visible[e.id] = e.visible;
        if (e.visible && e.duration && e.duration > 0) {
            const t = setTimeout(() => hideElem(e.id), e.duration * 1000);
            timers.push(t);
        }
        if (e.type === "timer" && e.visible) startTimer(e.id, e.countdown);
    });
    
    s.events.forEach(ev => {
        if (checkCond(ev.condition)) {
            if (ev.trigger.type === "onLoad") exec(ev.actions);
            else if (ev.trigger.type === "afterDelay") {
                const t = setTimeout(() => exec(ev.actions), (ev.trigger.delay || 0) * 1000);
                timers.push(t);
            }
        }
    });
    
    fullDraw();
}

function startTimer(id, countdown) {
    let rem = countdown;
    timerCountdowns[id] = rem;
    const int = setInterval(() => {
        rem--;
        timerCountdowns[id] = rem;
        const timerDiv = document.querySelector('[data-elem-id="' + id + '"] .elem-timer');
        if (timerDiv) timerDiv.textContent = rem;
        if (rem <= 0) {
            clearInterval(int);
            const s = STEPS.find(x => x.id === current);
            s.events.forEach(ev => {
                if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    }, 1000);
    timers.push(int);
}

function hideElem(id) {
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    const elemDiv = document.querySelector('[data-elem-id="' + id + '"]');
    
    if (!elemDiv) {
        visible[id] = false;
        delete rendered[id];
        return;
    }
    
    const audio = elemDiv.querySelector('audio');
    const video = elemDiv.querySelector('video');
    if (audio) { audio.pause(); audio.currentTime = 0; }
    if (video) { video.pause(); video.currentTime = 0; }
    
    // Determine outro transition: 'none' = instant, 'matchIntro' or undefined = use intro animation, specific value = use that
    const outTrans = elem.transitionOut === "none" ? null : 
        (elem.transitionOut === "matchIntro" || !elem.transitionOut) ? elem.transition : 
        elem.transitionOut;
    const outDur = elem.transitionOutDuration || elem.transitionDuration || 0.5;
    
    if (outTrans && outTrans !== "none") {
        hiding[id] = true;
        elemDiv.className = elemDiv.className.replace(/\\btrans-[\\w-]+\\b/g, '').replace(/\\banim-[\\w-]+\\b/g, '').trim() + ' trans-' + outTrans + '-out';
        elemDiv.style.animationDuration = outDur + 's';
        setTimeout(() => {
            visible[id] = false;
            hiding[id] = false;
            delete rendered[id];
            if (elemDiv.parentNode) elemDiv.remove();
        }, outDur * 1000);
    } else {
        visible[id] = false;
        delete rendered[id];
        elemDiv.remove();
    }
}

function showElem(id) {
    if (visible[id] && rendered[id]) return;
    visible[id] = true;
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    if (elem) {
        if (elem.type === "timer") startTimer(id, elem.countdown);
        if (elem.duration && elem.duration > 0) {
            const t = setTimeout(() => hideElem(id), elem.duration * 1000);
            timers.push(t);
        }
        addElement(elem, true);
    }
}

function checkCond(c) {
    if (!c) return true;
    if (c.type === "hasItem") {
        const items = c.items || (c.item ? [c.item] : []);
        if (items.length === 0) return true;
        const logic = c.logic || 'any';
        if (logic === 'all') return items.every(i => inventory.includes(i));
        return items.some(i => inventory.includes(i));
    }
    if (c.type === "notHasItem") {
        const items = c.items || (c.item ? [c.item] : []);
        if (items.length === 0) return true;
        const logic = c.logic || 'any';
        if (logic === 'all') return !items.every(i => inventory.includes(i));
        return items.every(i => !inventory.includes(i));
    }
    if (c.type === "varyingAtLeast") return (varyingValues[c.item] || 0) >= (c.amount || 0);
    if (c.type === "varyingAtMost") return (varyingValues[c.item] || 0) <= (c.amount || 0);
    if (c.type === "varyingBetween") return (varyingValues[c.item] || 0) >= (c.min || 0) && (varyingValues[c.item] || 0) <= (c.max || 0);
    return true;
}

function exec(acts) {
    acts.forEach(a => {
        if (a.type === "show" || a.type === "showDelay") {
            const delay = (a.type === "showDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => showElem(t), delay); });
        } else if (a.type === "hide" || a.type === "hideDelay") {
            const delay = (a.type === "hideDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => hideElem(t), delay); });
        } else if (a.type === "goto") {
            if (a.targets && a.targets.length > 0) current = a.targets[Math.floor(Math.random() * a.targets.length)];
            else if (a.target) current = a.target;
            render();
            return;
        } else if (a.type === "addItem" && !inventory.includes(a.target)) inventory.push(a.target);
        else if (a.type === "removeItem") inventory = inventory.filter(x => x !== a.target);
        else if (a.type === "addVarying") varyingValues[a.target] = (varyingValues[a.target] || 0) + (a.amount || 0);
        else if (a.type === "subtractVarying") varyingValues[a.target] = (varyingValues[a.target] || 0) - (a.amount || 0);
        else if (a.type === "setVarying") varyingValues[a.target] = a.amount || 0;
        else if (a.type === "bgmPlay") playBGM(a.target);
        else if (a.type === "bgmStop") stopBGM();
        else if (a.type === "showInventory") { showInvDisplay = true; }
        else if (a.type === "hideInventory") { showInvDisplay = false; }
        else if (a.type === "showInvItem") { if (a.target) hiddenInvItems[a.target] = false; }
        else if (a.type === "hideInvItem") { if (a.target) hiddenInvItems[a.target] = true; }
        else if (a.type === "showVarying") { showVaryDisplay = true; }
        else if (a.type === "hideVarying") { showVaryDisplay = false; }
        else if (a.type === "showVaryItem") { if (a.target) hiddenVaryItems[a.target] = false; }
        else if (a.type === "hideVaryItem") { if (a.target) hiddenVaryItems[a.target] = true; }
        else if (a.type === "saveState") {
            const saveData = { stepId: current, inventory: inventory, varying: varyingValues };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
        }
        else if (a.type === "loadState") {
            const saveData = localStorage.getItem(STORAGE_KEY);
            if (saveData) {
                const parsed = JSON.parse(saveData);
                inventory = parsed.inventory || [];
                varyingValues = parsed.varying || {};
                if (parsed.stepId) { current = parsed.stepId; render(); return; }
            }
        }
        else if (a.type === "clearState") {
            localStorage.removeItem(STORAGE_KEY);
        }
    });
    updateInventory();
}

function hexToRgba(hex, opacity) {
    if (!hex || hex.startsWith('rgba')) return hex || 'rgba(0,0,0,' + opacity + ')';
    hex = hex.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
}

function createElemHTML(e, withTransition) {
    const isHiding = hiding[e.id];
    // Determine outro transition: 'none' = instant, 'matchIntro' or undefined = use intro animation, specific value = use that
    const outTrans = isHiding ? 
        (e.transitionOut === "none" ? null : 
         (e.transitionOut === "matchIntro" || !e.transitionOut) ? e.transition : 
         e.transitionOut) : null;
    const transClass = withTransition && e.transition && e.transition !== "none" && !isHiding ? " trans-" + e.transition : (isHiding && outTrans ? " trans-" + outTrans + "-out" : "");
    // Duration animation works independently - apply it on inner wrapper
    const duringClass = e.animationDuring && e.animationDuring !== "none" && !isHiding ? " anim-" + e.animationDuring : "";
    const transDur = isHiding ? (e.transitionOutDuration || e.transitionDuration || 0.5) : (e.transitionDuration || 0.5);
    // Delay the during animation until intro finishes
    const duringDelay = (withTransition && e.transition && e.transition !== "none" && !isHiding) ? (e.transitionDuration || 0.5) : 0;
    const flipScaleX = e.flipH ? -1 : 1;
    const flipScaleY = e.flipV ? -1 : 1;
    const rotation = e.rotation || 0;
    const objectOpacity = (e.opacity !== undefined ? e.opacity : 100) / 100;
    const style = "left:" + e.x + "px;top:" + e.y + "px;width:" + e.width + "px;height:" + e.height + "px;z-index:" + e.layer + (e.shape === "circle" ? ";border-radius:50%" : "") + ";animation-duration:" + transDur + "s";
    const mousedown = e.type === "draggable" ? ' onmousedown="handleDragStart(event, \\'' + e.id + '\\')" ontouchstart="handleDragStart(event, \\'' + e.id + '\\')"' : "";
    const click = (e.type === "button" || (e.type === "hotspot" && e.hotspotMode !== "drop")) ? ' onclick="handleClick(\\'' + e.id + '\\')"' : "";
    const hotspotClass = (e.type === "hotspot" && e.showInGame) ? " elem-hotspot-visible" : "";
    const objectClass = e.type === "object" ? " elem-object" : "";
    const imgTransform = "transform:scale(" + flipScaleX + "," + flipScaleY + ") rotate(" + rotation + "deg);";
    
    let h = '<div class="elem' + (e.type === "draggable" ? " elem-draggable" : "") + hotspotClass + objectClass + transClass + '" data-elem-id="' + e.id + '" style="' + style + '"' + mousedown + click + '>';
    // Inner wrapper for during animation with delay
    if (duringClass) {
        h += '<div class="' + duringClass.trim() + '" style="width:100%;height:100%;animation-delay:' + duringDelay + 's">';
    }
    if (e.type === "image" && e.content) {
        if (e.cropEnabled) {
            const cropW = e.cropW || 100;
            const cropH = e.cropH || 100;
            const cropX = e.cropX || 0;
            const cropY = e.cropY || 0;
            const imgWidth = (100 / cropW) * 100;
            const imgHeight = (100 / cropH) * 100;
            const imgLeft = -(cropX / cropW) * 100;
            const imgTop = -(cropY / cropH) * 100;
            h += '<div style="width:100%;height:100%;overflow:hidden;position:relative"><img src="' + e.content + '" style="position:absolute;width:' + imgWidth + '%;height:' + imgHeight + '%;left:' + imgLeft + '%;top:' + imgTop + '%;object-fit:cover;' + imgTransform + 'opacity:' + ((e.opacity !== undefined ? e.opacity : 100) / 100) + ';"></div>';
        } else {
            h += '<img src="' + e.content + '" style="width:100%;height:100%;object-fit:cover;' + imgTransform + 'opacity:' + ((e.opacity !== undefined ? e.opacity : 100) / 100) + ';">';
        }
    }
    if (e.type === "video" && e.content) h += '<video playsinline webkit-playsinline ' + (OPTIMIZE_VIDEO ? 'preload="metadata" ' : '') + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop ' : '') + 'onended="handleVideoEnd(\\'' + e.id + '\\')" data-video-id="' + e.id + '"><source src="' + e.content + '"></video>';
    if (e.type === "text") {
        const bgOpacity = e.textBgOpacity !== undefined ? e.textBgOpacity : 0.8;
        const bgColor = hexToRgba(e.textBgColor || '#000000', bgOpacity);
        const textStyle = 'font-size:' + (e.textSize || 24) + 'px;color:' + (e.textColor || "#ffffff") + ';background:' + bgColor + 
            (e.textBold ? ';font-weight:bold' : '') + 
            (e.textItalic ? ';font-style:italic' : '') + 
            (e.textUnderline ? ';text-decoration:underline' : '') +
            (e.textBorder ? ';border:' + (e.textBorderWidth || 2) + 'px solid ' + (e.textBorderColor || '#ffffff') : '');
        h += '<div class="elem-text" style="' + textStyle + '">' + e.content + '</div>';
    }
    if (e.type === "button") {
        const shadowStyle = e.buttonShadow ? 'box-shadow:0 4px 15px rgba(0,0,0,0.4);' : '';
        const pulseClass = e.buttonPulse ? ' anim-buttonPulse' : '';
        h += '<div class="elem-button' + pulseClass + '" style="background:' + e.color + ';color:' + (e.buttonTextColor || '#ffffff') + ';font-size:' + (e.buttonTextSize || 20) + 'px;' + shadowStyle + '">' + (e.content || "Button") + '</div>';
    }
    if (e.type === "audio" && e.content) h += '<audio ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop ' : '') + 'onended="handleVideoEnd(\\'' + e.id + '\\')"><source src="' + e.content + '"></audio>';
    if (e.type === "timer") h += '<div class="elem-timer">' + (timerCountdowns[e.id] !== undefined ? timerCountdowns[e.id] : e.countdown) + '</div>';
    if (e.type === "draggable") {
        if (e.contentType === "image" && e.content) h += '<img src="' + e.content + '">';
        else h += '<div style="font-size:' + e.fontSize + 'px;color:#fff;pointer-events:none">' + (e.content || "ðŸ“¦") + '</div>';
    }
    if (e.type === "object") {
        const objStyle = "width:100%;height:100%;background:" + (e.objectColor || e.color || "#f7931a") + 
            (e.objectShape === "circle" ? ";border-radius:50%" : "") + 
            (e.objectShape === "triangle" ? ";clip-path:polygon(50% 0%, 0% 100%, 100% 100%)" : "") + 
            ";transform:scale(" + ((e.scaleX || 1) * flipScaleX) + "," + ((e.scaleY || 1) * flipScaleY) + ") rotate(" + rotation + "deg)" +
            ";opacity:" + objectOpacity;
        h += '<div style="' + objStyle + '"></div>';
    }
    if (e.type === "embed" && e.embedUrl) {
        if (e.embedThumbnail) {
            h += '<img src="' + e.embedThumbnail + '" style="width:100%;height:100%;object-fit:cover;cursor:pointer" onclick="showEmbed(\\'' + e.id + '\\')">';
        } else {
            h += '<div style="width:100%;height:100%;background:rgba(128,0,255,0.3);display:flex;align-items:center;justify-content:center;color:#fff;font-size:1.5rem;cursor:pointer" onclick="showEmbed(\\'' + e.id + '\\')">â–¶ Click to Open</div>';
        }
    }
    // Close inner wrapper if it was opened
    if (duringClass) {
        h += '</div>';
    }
    h += '</div>';
    return h;
}

function addElement(e, withTransition) {
    if (!e || rendered[e.id]) return;
    const game = document.getElementById("game");
    const s = STEPS.find(x => x.id === current);
    const temp = document.createElement('div');
    temp.innerHTML = createElemHTML(e, withTransition);
    const newElem = temp.firstChild;
    
    const existingElems = Array.from(game.querySelectorAll('[data-elem-id]'));
    let inserted = false;
    for (const existing of existingElems) {
        const existingE = s.elements.find(el => el.id === existing.getAttribute('data-elem-id'));
        if (existingE && existingE.layer > e.layer) {
            game.insertBefore(newElem, existing);
            inserted = true;
            break;
        }
    }
    if (!inserted) game.appendChild(newElem);
    rendered[e.id] = true;
}

function fullDraw() {
    const s = STEPS.find(x => x.id === current);
    const game = document.getElementById("game");
    game.style.background = s.bgColor || "#000";
    let h = "";
    
    if (s.bgShapes) {
        s.bgShapes.forEach(sh => {
            h += '<div style="position:absolute;left:' + sh.x + 'px;top:' + sh.y + 'px;width:' + sh.width + 'px;height:' + sh.height + 'px;background:' + sh.color + ';border-radius:' + (sh.type === "circle" ? "50%" : "0") + ';z-index:0"></div>';
        });
    }
    
    s.elements.filter(e => visible[e.id] || hiding[e.id]).sort((a, b) => a.layer - b.layer).forEach(e => {
        h += createElemHTML(e, true);
        rendered[e.id] = true;
    });
    
    game.innerHTML = h;
    updateInventory();
}

function updateInventory() {
    const inv = document.getElementById("inventory");
    const visInv = showInvDisplay ? inventory.filter(item => {
        const invItem = INVENTORY_ITEMS.find(i => (i.name || i) === item);
        if (!invItem) return false;
        // Check per-item runtime visibility
        if (hiddenInvItems[item]) return false;
        if (typeof invItem === "string") return true;
        return invItem.visible !== false;
    }) : [];
    const visVarying = showVaryDisplay ? VARYING_ITEMS.filter(vi => {
        // Check per-item runtime visibility
        if (hiddenVaryItems[vi.name]) return false;
        return vi.visible !== false;
    }) : [];
    
    if (visInv.length > 0 || visVarying.length > 0) {
        inv.style.display = "flex";
        let html = "";
        // Inventory items as text
        visInv.forEach(itemName => {
            const invItem = INVENTORY_ITEMS.find(i => (i.name || i) === itemName);
            const displayName = invItem && invItem.displayName ? invItem.displayName : itemName;
            html += '<div style="display:flex;align-items:center;gap:8px;color:#f59e0b;font-size:14px;font-weight:bold"><span style="color:#fff">â€¢ ' + displayName + '</span></div>';
        });
        // Varying items
        visVarying.forEach(vi => {
            const displayName = vi.displayName || vi.name;
            html += '<div style="display:flex;align-items:center;gap:8px;color:#f59e0b;font-size:14px;font-weight:bold"><span style="color:#fff">' + displayName + ':</span><span>' + (varyingValues[vi.name] || 0) + '</span></div>';
        });
        inv.innerHTML = html;
    } else {
        inv.style.display = "none";
    }
}

function getEventPos(ev) {
    if (ev.touches && ev.touches.length > 0) {
        return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
    }
    if (ev.changedTouches && ev.changedTouches.length > 0) {
        return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY };
    }
    return { x: ev.clientX, y: ev.clientY };
}

function handleDragStart(ev, elemId) {
    ev.preventDefault();
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === elemId);
    if (!elem) return;
    draggedElem = elem;
    const rect = ev.target.getBoundingClientRect();
    const canvas = document.getElementById("game");
    const canvasRect = canvas.getBoundingClientRect();
    const pos = getEventPos(ev);
    dragOffset.x = pos.x - rect.left;
    dragOffset.y = pos.y - rect.top;
    dragPos.x = pos.x - canvasRect.left;
    dragPos.y = pos.y - canvasRect.top;
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('touchend', handleDragEnd);
}

function handleDragMove(ev) {
    if (!draggedElem) return;
    ev.preventDefault();
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    const pos = getEventPos(ev);
    dragPos.x = pos.x - rect.left;
    dragPos.y = pos.y - rect.top;
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = (dragPos.x - dragOffset.x) + 'px';
        draggedDiv.style.top = (dragPos.y - dragOffset.y) + 'px';
    }
}

function handleDragEnd(ev) {
    if (!draggedElem) return;
    const s = STEPS.find(x => x.id === current);
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    const pos = getEventPos(ev);
    const dropX = pos.x - rect.left;
    const dropY = pos.y - rect.top;
    s.elements.filter(e => e.type === "hotspot" && visible[e.id] && e.hotspotMode !== "click").forEach(h => {
        if (dropX >= h.x && dropX <= h.x + h.width && dropY >= h.y && dropY <= h.y + h.height) {
            s.events.forEach(ev => {
                if (ev.trigger.type === "onDrop" && ev.trigger.sourceElement === h.id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    });
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    document.removeEventListener('touchmove', handleDragMove);
    document.removeEventListener('touchend', handleDragEnd);
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = draggedElem.x + 'px';
        draggedDiv.style.top = draggedElem.y + 'px';
    }
    draggedElem = null;
}

function handleVideoEnd(id) {
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
    });
}

let lastClickTime = 0;
const CLICK_DEBOUNCE_MS = 300;

function handleClick(id) {
    const now = Date.now();
    if (now - lastClickTime < CLICK_DEBOUNCE_MS) return;
    lastClickTime = now;
    
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "onClick") {
            const sources = ev.trigger.sourceElements || (ev.trigger.sourceElement ? [ev.trigger.sourceElement] : []);
            if (sources.includes(id) && checkCond(ev.condition)) exec(ev.actions);
        }
    });
}

render();
${fitToViewportJS}
    <\/script>
</body>
</html>`;
        }

        ReactDOM.render(React.createElement(StoryBuilder), document.getElementById('root'));
    </script>
</body>
</html>
