<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Story Builder Final</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: #0a0e27; color: #fff; overflow: hidden; }
        .app { display: grid; grid-template-columns: 200px 1fr 340px; grid-template-rows: 55px 1fr; height: 100vh; }
        .header { grid-column: 1/-1; background: #1a1f3a; border-bottom: 2px solid #f7931a; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; }
        .logo { font-size: 1.2rem; font-weight: 900; color: #f7931a; }
        .header-buttons { display: flex; gap: 6px; }
        .btn { padding: 6px 12px; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 11px; white-space: nowrap; }
        .btn-primary { background: #f7931a; color: #000; }
        .btn-secondary { background: #2d3748; color: #fff; }
        .btn-success { background: #10b981; color: #fff; }
        .btn-danger { background: #ef4444; color: #fff; }
        .btn-small { padding: 4px 8px; font-size: 10px; }
        .sidebar { background: #141829; border-right: 1px solid #2d3748; overflow-y: auto; padding: 10px; }
        .sidebar-right { border-left: 1px solid #2d3748; border-right: none; }
        .section-title { font-size: 0.65rem; font-weight: 700; text-transform: uppercase; color: #f7931a; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 2px solid #f7931a; }
        .step-item { background: #1a1f3a; border: 2px solid #2d3748; border-radius: 4px; padding: 6px; margin-bottom: 5px; cursor: move; font-size: 0.8rem; transition: all 0.2s; }
        .step-item:hover { border-color: #f7931a; }
        .step-item.active { border-color: #f7931a; background: #1f2541; }
        .step-item.drag-over { border: 2px dashed #10b981; background: #1e3a32; }
        .step-title { font-weight: 600; }
        .canvas { background: #0a0e27; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .preview-container { transform-origin: center center; }
        .preview { width: 1024px; height: 576px; background: #000; position: relative; border: 2px solid #f7931a; }
        .element { position: absolute; cursor: move; border: 2px dashed transparent; }
        .element:hover { border-color: #f7931a; }
        .element.selected { border-color: #10b981; border-style: solid; }
        .element img, .element video { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .element-text { background: rgba(0,0,0,0.8); padding: 15px; border-radius: 6px; color: white; font-size: 1.5rem; text-align: center; word-wrap: break-word; overflow: hidden; white-space: pre-wrap; }
        .element-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; text-align: center; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .element-hotspot { border: 2px solid red; background: rgba(255,0,0,0.1); }
        .element-audio { background: rgba(0,100,200,0.3); border: 2px dashed #00aaff; display: flex; align-items: center; justify-content: center; font-size: 2rem; }
        .element-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .element-draggable { border: 2px dashed #00ff64; display: flex; align-items: center; justify-content: center; cursor: grab; overflow: hidden; }
        .element-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .resize-handle { position: absolute; width: 10px; height: 10px; background: #f7931a; right: -5px; bottom: -5px; cursor: se-resize; }
        .element-label { position: absolute; top: -20px; left: 0; background: #f7931a; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 700; }
        .form-group { margin-bottom: 10px; }
        .form-label { display: block; font-size: 0.65rem; font-weight: 600; text-transform: uppercase; color: #f7931a; margin-bottom: 4px; }
        .form-input, .form-textarea, .form-select { width: 100%; padding: 6px; background: #1a1f3a; border: 2px solid #2d3748; border-radius: 4px; color: #fff; font-size: 11px; }
        .form-textarea { resize: vertical; min-height: 50px; font-family: inherit; }
        .form-checkbox { margin-right: 6px; }
        .tabs { display: flex; gap: 3px; margin-bottom: 10px; border-bottom: 2px solid #2d3748; flex-wrap: wrap; }
        .tab { padding: 6px 8px; background: transparent; border: none; color: #6b7280; cursor: pointer; font-weight: 600; font-size: 0.65rem; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab.active { color: #f7931a; border-bottom-color: #f7931a; }
        .event-item { background: #1a1f3a; border: 1px solid #2d3748; border-radius: 4px; padding: 6px; margin-bottom: 5px; }
        .action-item { background: #0a0e27; padding: 5px; margin-top: 3px; border-radius: 4px; border: 1px solid #2d3748; }
        .condition-box { background: rgba(16, 185, 129, 0.1); border: 1px solid #10b981; padding: 5px; margin-bottom: 5px; border-radius: 4px; }
        .add-btn { width: 100%; padding: 6px; background: #2d3748; border: 1px dashed #6b7280; color: #6b7280; border-radius: 4px; cursor: pointer; font-size: 0.65rem; margin-top: 5px; }
        .add-btn:hover { background: #3d4758; border-color: #f7931a; color: #f7931a; }
        .info-box { background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; padding: 6px; margin-bottom: 10px; font-size: 0.65rem; line-height: 1.3; }
        .play-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 1000; }
        .play-exit { position: absolute; top: 20px; right: 20px; z-index: 1001; }
        .play-canvas { 
            width: 1024px; 
            height: 576px; 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .inventory-display { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; display: flex; gap: 10px; z-index: 100; }
        .inventory-item-icon { width: 40px; height: 40px; background: #f7931a; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .trans-fade { animation: fadeIn 0.5s ease-in; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
        .draggable-active { cursor: grabbing !important; opacity: 0.7; z-index: 9999 !important; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0e27; }
        ::-webkit-scrollbar-thumb { background: #2d3748; border-radius: 3px; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 4px; background: #1a1f3a; border-radius: 3px; margin-bottom: 3px; }
        .collapsible-header:hover { background: #252b45; }
        .collapsible-arrow { transition: transform 0.2s; font-size: 10px; }
        .collapsible-arrow.open { transform: rotate(90deg); }
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .collapsible-content.open { max-height: 500px; overflow-y: auto; }
        .element-list-item { padding: 5px 8px; background: #1a1f3a; border: 1px solid #2d3748; border-radius: 3px; margin-bottom: 3px; cursor: pointer; font-size: 0.7rem; display: flex; justify-content: space-between; align-items: center; }
        .element-list-item:hover { border-color: #f7931a; background: #1f2541; }
        .element-list-item.selected { border-color: #10b981; background: #1a3a2e; }
        .element-type-badge { font-size: 0.55rem; padding: 2px 5px; border-radius: 3px; background: #2d3748; color: #9ca3af; }
        .btn-add-event { background: #10b981 !important; color: #fff !important; }
        .btn-add-action { background: #f59e0b !important; color: #000 !important; }
        .event-item { background: #1a1f3a; border: 2px solid #f7931a; border-radius: 6px; padding: 8px; margin-bottom: 8px; }
        .event-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 4px; background: #252b45; border-radius: 4px; margin-bottom: 5px; }
        .event-header:hover { background: #2d3450; }
        .event-drag-handle { cursor: grab; padding: 0 5px; color: #f7931a; }
        .event-drag-handle:active { cursor: grabbing; }
        .event-item.drag-over { border: 2px dashed #10b981; background: #1e3a32; }
        .canvas-grid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .element-object { display: flex; align-items: center; justify-content: center; }
        .snap-indicator { position: absolute; background: rgba(16, 185, 129, 0.3); pointer-events: none; z-index: 9998; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes wobble { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); } 20%, 40%, 60%, 80% { transform: translateX(2px); } }
        @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        .anim-pulse { animation: pulse 1s ease-in-out infinite; }
        .anim-spin { animation: spin 2s linear infinite; }
        .anim-bounce { animation: bounce 0.5s ease-in-out infinite; }
        .anim-wobble { animation: wobble 0.5s ease-in-out infinite; }
        .anim-shake { animation: shake 0.5s ease-in-out infinite; }
        .anim-glow { animation: glow 1.5s ease-in-out infinite; }
        .anim-float { animation: float 2s ease-in-out infinite; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
        const { createElement: e, useState, useEffect, useRef } = React;

        function sanitizeStepName(name) {
            return name.replace(/[^a-zA-Z0-9_-]/g, '_');
        }

        function generateUniqueStepId(title, existingSteps) {
            let base = sanitizeStepName(title) || 'step';
            let id = base;
            let counter = 2;
            while (existingSteps.some(s => s.id === id)) {
                id = base + counter;
                counter++;
            }
            return id;
        }

        function createStep(title, existingSteps) {
            const id = generateUniqueStepId(title, existingSteps);
            return { id, title, elements: [], events: [], password: '', wrongPasswordStep: '', bgColor: '#000000', bgShapes: [] };
        }

        function createElement2(type) {
            const baseId = type + '_' + Date.now();
            return {
                id: baseId,
                type: type,
                label: type + '1',
                x: 100,
                y: 100,
                width: type === 'text' || type === 'button' ? 300 : type === 'audio' ? 200 : type === 'timer' ? 150 : type === 'draggable' ? 100 : type === 'object' ? 100 : 400,
                height: type === 'text' ? 100 : type === 'button' ? 60 : type === 'audio' ? 60 : type === 'timer' ? 150 : type === 'draggable' ? 100 : type === 'object' ? 100 : 300,
                content: '',
                visible: true,
                layer: 0,
                duration: 0,
                loop: false,
                autoplay: type === 'audio' || type === 'video',
                shape: type === 'object' ? 'rect' : 'rect',
                color: '#f7931a',
                countdown: 10,
                fontSize: 24,
                contentType: 'text',
                hotspotMode: 'both',
                transition: 'none',
                transitionDuration: 0.5,
                transitionOut: 'none',
                transitionOutDuration: 0.5,
                animationDuring: 'none',
                textColor: '#ffffff',
                textBgColor: 'rgba(0,0,0,0.8)',
                textSize: 24,
                buttonTextColor: '#ffffff',
                buttonTextSize: 20,
                objectShape: 'rect',
                objectColor: '#f7931a',
                scaleX: 1,
                scaleY: 1,
                rotation: 0,
                flipH: false,
                flipV: false,
                opacity: 100,
                textBgOpacity: 80
            };
        }

        function createEvent() {
            return {
                id: 'event_' + Date.now(),
                trigger: { type: 'onLoad', delay: 0, sourceElement: '' },
                condition: null,
                actions: []
            };
        }

        function StoryBuilder() {
            // Try to load from localStorage on init
            const savedData = localStorage.getItem('storyBuilderAutosave');
            const initialData = savedData ? JSON.parse(savedData) : null;
            
            const [steps, setSteps] = useState(initialData?.steps || []);
            const [currentStepId, setCurrentStepId] = useState(initialData?.currentStepId || null);
            const [selectedElementId, setSelectedElementId] = useState(null);
            const [activeTab, setActiveTab] = useState('elements');
            const [collapsedActions, setCollapsedActions] = useState({});
            const [collapsedEvents, setCollapsedEvents] = useState({});
            const [varyingItems, setVaryingItems] = useState(initialData?.varyingItems || []);
            const [snapEnabled, setSnapEnabled] = useState(false);
            const [showGrid, setShowGrid] = useState(true);
            const [clipboard, setClipboard] = useState(null);
            const [draggedEventId, setDraggedEventId] = useState(null);
            const [dragging, setDragging] = useState(null);
            const [playMode, setPlayMode] = useState(false);
            const [playStartStep, setPlayStartStep] = useState(null);
            const [draggedStepId, setDraggedStepId] = useState(null);
            const [dragOverStepId, setDragOverStepId] = useState(null);
            const [scale, setScale] = useState(1);
            const [inventory, setInventory] = useState(initialData?.inventory || []);
            const [draggedInPlay, setDraggedInPlay] = useState(null);
            const [lastSaved, setLastSaved] = useState(null);
            const canvasRef = useRef(null);

            useEffect(() => {
                const updateScale = () => {
                    if (canvasRef.current) {
                        const container = canvasRef.current.parentElement;
                        const scaleX = (container.clientWidth - 40) / 1024;
                        const scaleY = (container.clientHeight - 40) / 576;
                        setScale(Math.min(scaleX, scaleY, 1));
                    }
                };
                updateScale();
                window.addEventListener('resize', updateScale);
                return () => window.removeEventListener('resize', updateScale);
            }, []);

            // Autosave to localStorage every 5 seconds when there are changes
            useEffect(() => {
                if (steps.length === 0 && inventory.length === 0 && varyingItems.length === 0) return;
                
                const autosaveTimer = setTimeout(() => {
                    const data = { steps, inventory, varyingItems, currentStepId };
                    localStorage.setItem('storyBuilderAutosave', JSON.stringify(data));
                    setLastSaved(new Date().toLocaleTimeString());
                }, 2000);
                
                return () => clearTimeout(autosaveTimer);
            }, [steps, inventory, varyingItems, currentStepId]);

            const getCurrentStep = () => steps.find(s => s.id === currentStepId);
            const getSelectedElement = () => {
                const step = getCurrentStep();
                return step?.elements.find(el => el.id === selectedElementId);
            };

            const updateStep = (updates) => {
                setSteps(steps.map(s => {
                    if (s.id === currentStepId) {
                        const updated = { ...s, ...updates };
                        if (updates.title && updates.title !== s.title) {
                            const newId = generateUniqueStepId(updates.title, steps.filter(st => st.id !== s.id));
                            if (newId !== s.id) {
                                updated.id = newId;
                                setCurrentStepId(newId);
                            }
                        }
                        return updated;
                    }
                    return s;
                }));
            };

            const updateElement = (elemId, updates) => {
                const step = getCurrentStep();
                if (step) {
                    const elements = step.elements.map(el => {
                        if (el.id === elemId) {
                            const updated = { ...el, ...updates };
                            if (updates.label) {
                                const sameType = step.elements.filter(e => e.type === el.type && e.id !== el.id);
                                const match = updates.label.match(/^(.*?)(\d+)$/);
                                if (match) {
                                    const base = match[1];
                                    let num = parseInt(match[2]);
                                    while (sameType.some(e => e.label === base + num)) {
                                        num++;
                                    }
                                    updated.label = base + num;
                                }
                            }
                            return updated;
                        }
                        return el;
                    });
                    updateStep({ elements });
                }
            };

            const createNewStep = () => {
                const title = prompt('Step name:', 'Step ' + (steps.length + 1));
                if (!title) return;
                const step = createStep(title, steps);
                setSteps([...steps, step]);
                setCurrentStepId(step.id);
            };

            const handleStepDragStart = (e, stepId) => {
                setDraggedStepId(stepId);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleStepDragOver = (e, stepId) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                if (stepId !== draggedStepId) {
                    setDragOverStepId(stepId);
                }
            };

            const handleStepDrop = (e, targetStepId) => {
                e.preventDefault();
                if (!draggedStepId || draggedStepId === targetStepId) {
                    setDraggedStepId(null);
                    setDragOverStepId(null);
                    return;
                }

                const draggedIndex = steps.findIndex(s => s.id === draggedStepId);
                const targetIndex = steps.findIndex(s => s.id === targetStepId);
                
                const newSteps = [...steps];
                const [draggedStep] = newSteps.splice(draggedIndex, 1);
                newSteps.splice(targetIndex, 0, draggedStep);
                
                setSteps(newSteps);
                setDraggedStepId(null);
                setDragOverStepId(null);
            };

            const handleStepDragEnd = () => {
                setDraggedStepId(null);
                setDragOverStepId(null);
            };

            const addElement = (type) => {
                const step = getCurrentStep();
                if (step) {
                    const elem = createElement2(type);
                    const sameType = step.elements.filter(e => e.type === type);
                    elem.label = type + (sameType.length + 1);
                    updateStep({ elements: [...step.elements, elem] });
                    setSelectedElementId(elem.id);
                }
            };

            const deleteElement = (elemId) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ elements: step.elements.filter(el => el.id !== elemId) });
                    if (selectedElementId === elemId) setSelectedElementId(null);
                }
            };

            const addInventoryItem = () => {
                const name = prompt('Inventory item name:');
                if (name && !inventory.find(i => i.name === name)) {
                    setInventory([...inventory, { name: name, visible: true }]);
                }
            };

            const deleteInventoryItem = (item) => {
                setInventory(inventory.filter(i => i.name !== item.name));
            };

            const addVaryingItem = () => {
                const name = prompt('Varying item name (e.g., dollars, points, friends):');
                if (name && !varyingItems.find(i => i.name === name)) {
                    setVaryingItems([...varyingItems, { name: name, visible: true }]);
                }
            };

            const deleteVaryingItem = (item) => {
                setVaryingItems(varyingItems.filter(i => i.name !== item.name));
            };

            const toggleActionCollapse = (actionKey) => {
                setCollapsedActions(prev => ({ ...prev, [actionKey]: !prev[actionKey] }));
            };

            const toggleEventCollapse = (eventId) => {
                setCollapsedEvents(prev => ({ ...prev, [eventId]: !prev[eventId] }));
            };

            const copyElement = (elem) => {
                setClipboard({ ...elem, id: null });
            };

            const pasteElement = () => {
                if (!clipboard) return;
                const newElem = {
                    ...clipboard,
                    id: clipboard.type + '_' + Date.now(),
                    label: clipboard.label + '_copy',
                    x: clipboard.x + 20,
                    y: clipboard.y + 20
                };
                setSteps(steps.map(s => s.id === currentStepId ? { ...s, elements: [...s.elements, newElem] } : s));
                setSelectedElementId(newElem.id);
            };

            const snapToGrid = (value, gridSize = 51.2) => {
                return Math.round(value / gridSize) * gridSize;
            };

            const handleEventDragStart = (ev, eventId) => {
                setDraggedEventId(eventId);
                ev.dataTransfer.effectAllowed = 'move';
            };

            const handleEventDragOver = (ev, eventId) => {
                ev.preventDefault();
                ev.dataTransfer.dropEffect = 'move';
            };

            const handleEventDrop = (ev, targetEventId) => {
                ev.preventDefault();
                if (!draggedEventId || draggedEventId === targetEventId) return;
                
                const events = [...currentStep.events];
                const dragIdx = events.findIndex(e => e.id === draggedEventId);
                const dropIdx = events.findIndex(e => e.id === targetEventId);
                
                if (dragIdx === -1 || dropIdx === -1) return;
                
                const [draggedEvent] = events.splice(dragIdx, 1);
                events.splice(dropIdx, 0, draggedEvent);
                
                setSteps(steps.map(s => s.id === currentStepId ? { ...s, events } : s));
                setDraggedEventId(null);
            };

            const handleEventDragEnd = () => {
                setDraggedEventId(null);
            };

            const addEvent = () => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ events: [...step.events, createEvent()] });
                }
            };

            const updateEvent = (eventId, updates) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({
                        events: step.events.map(ev => ev.id === eventId ? { ...ev, ...updates } : ev)
                    });
                }
            };

            const deleteEvent = (eventId) => {
                const step = getCurrentStep();
                if (step) {
                    updateStep({ events: step.events.filter(ev => ev.id !== eventId) });
                }
            };

            const addEventAction = (eventId) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: [...event.actions, { id: 'action_' + Date.now(), type: 'show', target: '', value: '' }]
                    });
                }
            };

            const updateEventAction = (eventId, actionId, updates) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: event.actions.map(a => a.id === actionId ? { ...a, ...updates } : a)
                    });
                }
            };

            const deleteEventAction = (eventId, actionId) => {
                const step = getCurrentStep();
                const event = step?.events.find(ev => ev.id === eventId);
                if (event) {
                    updateEvent(eventId, {
                        actions: event.actions.filter(a => a.id !== actionId)
                    });
                }
            };

            const handleMouseDown = (ev, elemId) => {
                const elem = currentStep?.elements.find(e => e.id === elemId);
                if (ev.target.classList.contains('resize-handle')) {
                    setDragging({ type: 'resize', elemId });
                } else {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = (ev.clientX - rect.left) / scale;
                    const mouseY = (ev.clientY - rect.top) / scale;
                    setDragging({ 
                        type: 'move', 
                        elemId, 
                        offsetX: mouseX - (elem?.x || 0),
                        offsetY: mouseY - (elem?.y || 0)
                    });
                }
                setSelectedElementId(elemId);
            };

            const handleMouseMove = (ev) => {
                if (!dragging) return;
                const elem = getSelectedElement();
                if (!elem) return;

                if (dragging.type === 'move') {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    // Calculate absolute position from mouse
                    let newX = (ev.clientX - rect.left) / scale - dragging.offsetX;
                    let newY = (ev.clientY - rect.top) / scale - dragging.offsetY;
                    // Clamp to canvas bounds
                    newX = Math.max(0, Math.min(1024 - elem.width, newX));
                    newY = Math.max(0, Math.min(576 - elem.height, newY));
                    if (snapEnabled) {
                        newX = snapToGrid(newX);
                        newY = snapToGrid(newY);
                    }
                    updateElement(elem.id, { x: newX, y: newY });
                } else if (dragging.type === 'resize') {
                    const canvas = document.querySelector('.preview');
                    const rect = canvas.getBoundingClientRect();
                    let newWidth = Math.max(50, Math.min(1024 - elem.x, (ev.clientX - rect.left) / scale - elem.x));
                    let newHeight = Math.max(50, Math.min(576 - elem.y, (ev.clientY - rect.top) / scale - elem.y));
                    if (snapEnabled) {
                        newWidth = snapToGrid(newWidth);
                        newHeight = snapToGrid(newHeight);
                    }
                    updateElement(elem.id, { width: newWidth, height: newHeight });
                }
            };

            const handleMouseUp = () => setDragging(null);

            useEffect(() => {
                if (dragging) {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [dragging, scale]);

            const newProject = () => {
                if (steps.length > 0 && !confirm('Start a new project? This will clear current work.\n\n(Your work is autosaved, but starting new will clear it)')) {
                    return;
                }
                setSteps([]);
                setCurrentStepId(null);
                setSelectedElementId(null);
                setInventory([]);
                setVaryingItems([]);
                localStorage.removeItem('storyBuilderAutosave');
                setLastSaved(null);
            };

            const saveProject = () => {
                const data = JSON.stringify({ steps, inventory, varyingItems }, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'story.json';
                a.click();
            };

            const loadProject = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (ev) => {
                    const file = ev.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            setSteps(data.steps);
                            setInventory(data.inventory || []);
                            setVaryingItems(data.varyingItems || []);
                            setCurrentStepId(data.steps[0]?.id);
                            alert('Loaded!');
                        } catch (err) {
                            alert('Error: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const exportHTML = () => {
                const html = generateHTML(steps, inventory, varyingItems);
                navigator.clipboard.writeText(html).then(() => {
                    alert('âœ… HTML copied!');
                }).catch(() => {
                    const textarea = document.createElement('textarea');
                    textarea.value = html;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('âœ… HTML copied!');
                });
            };

            if (playMode) {
                return e(PlayMode, { steps, inventory, varyingItems, onExit: () => setPlayMode(false), startStepId: playStartStep || currentStepId });
            }

            const currentStep = getCurrentStep();
            const selectedElement = getSelectedElement();

            return e('div', { className: 'app' },
                e('header', { className: 'header' },
                    e('div', { style: { display: 'flex', alignItems: 'center', gap: '15px' } },
                        e('div', { className: 'logo' }, 'Builder'),
                        lastSaved && e('div', { style: { fontSize: '0.6rem', color: '#10b981' } }, 'âœ“ Saved ' + lastSaved)
                    ),
                    e('div', { className: 'header-buttons' },
                        e('button', { 
                            className: 'btn ' + (showGrid ? 'btn-primary' : 'btn-secondary'), 
                            onClick: () => setShowGrid(!showGrid), 
                            title: 'Toggle Grid',
                            style: { fontSize: '10px' }
                        }, 'âŠž'),
                        e('button', { 
                            className: 'btn ' + (snapEnabled ? 'btn-success' : 'btn-secondary'), 
                            onClick: () => setSnapEnabled(!snapEnabled), 
                            title: 'Toggle Snap to Grid',
                            style: { fontSize: '10px' }
                        }, 'ðŸ§²'),
                        e('button', { className: 'btn btn-primary', onClick: () => { setPlayStartStep(steps[0]?.id); setPlayMode(true); }, title: 'Test All Steps' }, 'â–¶ All'),
                        e('button', { className: 'btn btn-primary', onClick: () => { setPlayStartStep(currentStepId); setPlayMode(true); }, title: 'Preview Current Step', style: { background: '#10b981' } }, 'â–¶ Step'),
                        e('button', { className: 'btn btn-danger', onClick: newProject, title: 'New Project' }, 'ðŸ—‘ï¸'),
                        e('button', { className: 'btn btn-secondary', onClick: saveProject, title: 'Save to File' }, 'ðŸ’¾'),
                        e('button', { className: 'btn btn-secondary', onClick: loadProject, title: 'Load from File' }, 'ðŸ“‚'),
                        e('button', { className: 'btn btn-success', onClick: exportHTML, title: 'Export HTML' }, 'âš¡')
                    )
                ),
                
                e('aside', { className: 'sidebar' },
                    e('div', { className: 'section-title' }, 'Steps'),
                    e('button', { className: 'btn btn-primary btn-small', style: { width: '100%', marginBottom: '6px' }, onClick: createNewStep }, '+ Step'),
                    steps.map(step =>
                        e('div', {
                            key: step.id,
                            className: 'step-item' + (step.id === currentStepId ? ' active' : '') + (step.id === dragOverStepId ? ' drag-over' : ''),
                            draggable: true,
                            onDragStart: (ev) => handleStepDragStart(ev, step.id),
                            onDragOver: (ev) => handleStepDragOver(ev, step.id),
                            onDrop: (ev) => handleStepDrop(ev, step.id),
                            onDragEnd: handleStepDragEnd,
                            style: { opacity: step.id === draggedStepId ? 0.5 : 1 }
                        },
                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
                                e('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', flex: 1 } },
                                    e('div', { style: { cursor: 'grab', fontSize: '12px', opacity: 0.5 } }, 'â˜°'),
                                    e('div', { className: 'step-title', onClick: () => setCurrentStepId(step.id), style: { flex: 1, cursor: 'pointer' } }, step.title)
                                ),
                                e('div', { style: { display: 'flex', gap: '3px' } },
                                    e('button', { 
                                        className: 'btn btn-secondary btn-small', 
                                        onClick: (ev) => {
                                            ev.stopPropagation();
                                            const newTitle = prompt('Rename step:', step.title);
                                            if (newTitle && newTitle !== step.title) {
                                                setSteps(steps.map(s => s.id === step.id ? { ...s, title: newTitle } : s));
                                            }
                                        },
                                        style: { padding: '2px 4px', fontSize: '10px' }
                                    }, 'âœï¸'),
                                    e('button', { 
                                        className: 'btn btn-success btn-small', 
                                        onClick: (ev) => {
                                            ev.stopPropagation();
                                            const clonedStep = JSON.parse(JSON.stringify(step));
                                            clonedStep.id = step.id + '_2';
                                            clonedStep.title = step.title + ' 2';
                                            const insertIndex = steps.findIndex(s => s.id === step.id) + 1;
                                            setSteps([...steps.slice(0, insertIndex), clonedStep, ...steps.slice(insertIndex)]);
                                        },
                                        style: { padding: '2px 4px', fontSize: '10px' }
                                    }, 'ðŸ“‹'),
                                    e('button', { 
                                        className: 'btn btn-danger btn-small', 
                                        onClick: (ev) => {
                                            ev.stopPropagation();
                                            if (steps.length === 1) {
                                                alert('Cannot delete the last step!');
                                                return;
                                            }
                                            if (confirm('Delete "' + step.title + '"?')) {
                                                const newSteps = steps.filter(s => s.id !== step.id);
                                                setSteps(newSteps);
                                                if (currentStepId === step.id) {
                                                    setCurrentStepId(newSteps[0].id);
                                                }
                                            }
                                        },
                                        style: { padding: '2px 4px', fontSize: '10px' }
                                    }, 'Ã—')
                                )
                            )
                        )
                    )
                ),

                e('main', { className: 'canvas' },
                    e('div', { ref: canvasRef, className: 'preview-container', style: { transform: 'scale(' + scale + ')' } },
                        e('div', { className: 'preview', style: { background: currentStep ? (currentStep.bgColor || '#000') : '#000' } },
                            showGrid && e('svg', { className: 'canvas-grid', width: '1024', height: '576' },
                                // Vertical lines every ~102px (10% of 1024)
                                [0, 102.4, 204.8, 307.2, 409.6, 512, 614.4, 716.8, 819.2, 921.6, 1024].map((x, i) =>
                                    e('line', { key: 'v' + i, x1: x, y1: 0, x2: x, y2: 576, stroke: i === 5 ? 'rgba(247,147,26,0.4)' : (i === 0 || i === 10 || i === 2 || i === 8) ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.1)', strokeWidth: i === 5 ? 2 : 1 })
                                ),
                                // Horizontal lines every ~57.6px (10% of 576)
                                [0, 57.6, 115.2, 172.8, 230.4, 288, 345.6, 403.2, 460.8, 518.4, 576].map((y, i) =>
                                    e('line', { key: 'h' + i, x1: 0, y1: y, x2: 1024, y2: y, stroke: i === 5 ? 'rgba(247,147,26,0.4)' : (i === 0 || i === 10 || i === 2 || i === 8) ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.1)', strokeWidth: i === 5 ? 2 : 1 })
                                )
                            ),
                            currentStep && currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                                e('div', {
                                    key: shape.id,
                                    style: {
                                        position: 'absolute',
                                        left: shape.x + 'px',
                                        top: shape.y + 'px',
                                        width: shape.width + 'px',
                                        height: shape.height + 'px',
                                        background: shape.color,
                                        borderRadius: shape.type === 'circle' ? '50%' : '0',
                                        zIndex: 0
                                    }
                                })
                            ),
                            currentStep ? 
                                currentStep.elements
                                    .sort((a, b) => a.layer - b.layer)
                                    .filter(elem => elem.visible)
                                    .map(elem =>
                                        e('div', {
                                            key: elem.id,
                                            className: 'element' + (elem.id === selectedElementId ? ' selected' : '') + 
                                                      (elem.type === 'hotspot' ? ' element-hotspot' : ''),
                                            style: {
                                                left: elem.x + 'px',
                                                top: elem.y + 'px',
                                                width: elem.width + 'px',
                                                height: elem.height + 'px',
                                                zIndex: elem.layer,
                                                borderRadius: elem.shape === 'circle' ? '50%' : '0'
                                            },
                                            onMouseDown: (ev) => handleMouseDown(ev, elem.id)
                                        },
                                            e('div', { className: 'element-label' }, elem.label),
                                            elem.type === 'image' && elem.content && e('img', { src: elem.content, style: { transform: 'scale(' + (elem.flipH ? -1 : 1) + ', ' + (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)', opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100 } }),
                                            elem.type === 'video' && elem.content && e('video', { src: elem.content, autoPlay: true, loop: elem.loop, playsInline: true }),
                                            elem.type === 'text' && e('div', { 
                                    className: 'element-text',
                                    style: { 
                                        fontSize: (elem.textSize || 24) + 'px',
                                        color: elem.textColor || '#ffffff',
                                        background: elem.textBgColor ? 
                                            (elem.textBgColor.startsWith('#') ? 
                                                elem.textBgColor + Math.round((elem.textBgOpacity || 0.8) * 255).toString(16).padStart(2, '0') : 
                                                elem.textBgColor) : 
                                            'rgba(0,0,0,0.8)'
                                    }
                                }, elem.content),
                                            elem.type === 'button' && e('div', { className: 'element-button', style: { background: elem.color, color: elem.buttonTextColor || '#ffffff', fontSize: (elem.buttonTextSize || 20) + 'px' } }, elem.content || 'Button'),
                                            elem.type === 'audio' && e('div', { className: 'element-audio' }, 'ðŸ”Š'),
                                            elem.type === 'timer' && e('div', { className: 'element-timer' }, elem.countdown),
                                            elem.type === 'draggable' && e('div', { className: 'element-draggable' },
                                                elem.contentType === 'image' && elem.content ? e('img', { src: elem.content }) :
                                                e('div', { style: { fontSize: elem.fontSize + 'px', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%' } }, elem.content || 'ðŸ“¦')
                                            ),
                                            elem.type === 'hotspot' && e('div', { style: { width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.8rem' } }, elem.label),
                                            elem.type === 'object' && e('div', { 
                                                className: 'element-object',
                                                style: { 
                                                    width: '100%', 
                                                    height: '100%', 
                                                    background: elem.objectColor || elem.color || '#f7931a',
                                                    borderRadius: elem.objectShape === 'circle' ? '50%' : '0',
                                                    clipPath: elem.objectShape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none',
                                                    transform: 'scale(' + (elem.scaleX || 1) * (elem.flipH ? -1 : 1) + ', ' + (elem.scaleY || 1) * (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)',
                                                    opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100
                                                }
                                            }),
                                            e('div', { className: 'resize-handle' })
                                        )
                                    ) :
                                e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', color: '#6b7280', fontSize: '1.2rem' } }, 'Create a step')
                        )
                    )
                ),

                e('aside', { className: 'sidebar sidebar-right' },
                    currentStep ? e('div', null,
                        e('div', { className: 'form-group' },
                            e('input', {
                                className: 'form-input',
                                value: currentStep.title,
                                placeholder: 'Step Name',
                                onChange: (ev) => updateStep({ title: ev.target.value })
                            })
                        ),
                        currentStep.password && e('div', { style: { fontSize: '0.6rem', color: '#f7931a', marginBottom: '8px' } }, 'ðŸ”’ Password: ' + currentStep.password),
                        
                        e('div', { className: 'tabs' },
                            e('button', { className: 'tab' + (activeTab === 'elements' ? ' active' : ''), onClick: () => setActiveTab('elements') }, 'Elements'),
                            e('button', { className: 'tab' + (activeTab === 'events' ? ' active' : ''), onClick: () => setActiveTab('events') }, 'Events'),
                            e('button', { className: 'tab' + (activeTab === 'inventory' ? ' active' : ''), onClick: () => setActiveTab('inventory') }, 'Inventory'),
                            e('button', { className: 'tab' + (activeTab === 'settings' ? ' active' : ''), onClick: () => setActiveTab('settings') }, 'Settings')
                        ),

                        activeTab === 'elements' && e('div', null,
                            e('div', { className: 'section-title' }, 'Add'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('image') }, 'ðŸ–¼ï¸ Image'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('video') }, 'ðŸŽ¥ Video'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('text') }, 'ðŸ“ Text'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('button') }, 'ðŸ”˜ Button'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('audio') }, 'ðŸ”Š Audio'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('timer') }, 'â±ï¸ Timer'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('draggable') }, 'ðŸŽ¯ Draggable'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '2px' }, onClick: () => addElement('hotspot') }, 'ðŸ“ Hotspot'),
                            e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '8px' }, onClick: () => addElement('object') }, 'â¬œ Object'),
                            
                            selectedElement && e('div', null,
                                e('div', { className: 'section-title' }, selectedElement.label),
                                e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Label'),
                                    e('input', { className: 'form-input', value: selectedElement.label, onChange: (ev) => updateElement(selectedElement.id, { label: ev.target.value }) })
                                ),
                                
                                selectedElement.type === 'draggable' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Content Type'),
                                    e('select', { className: 'form-select', value: selectedElement.contentType || 'text', onChange: (ev) => updateElement(selectedElement.id, { contentType: ev.target.value }) },
                                        e('option', { value: 'text' }, 'Text/Emoji'),
                                        e('option', { value: 'image' }, 'Image URL')
                                    )
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'text' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text/Emoji'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'ðŸª³ or text', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }) })
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'text' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Font Size'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.fontSize, onChange: (ev) => updateElement(selectedElement.id, { fontSize: parseInt(ev.target.value) || 24 }) })
                                ),

                                selectedElement.type === 'draggable' && selectedElement.contentType === 'image' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Image URL or Upload'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                    e('input', { 
                                        type: 'file', 
                                        className: 'form-input',
                                        accept: 'image/*',
                                        onChange: (ev) => {
                                            const file = ev.target.files[0];
                                            if (file) {
                                                const url = URL.createObjectURL(file);
                                                updateElement(selectedElement.id, { content: url });
                                            }
                                        }
                                    })
                                ),

                                (selectedElement.type !== 'hotspot' && selectedElement.type !== 'audio' && selectedElement.type !== 'timer' && selectedElement.type !== 'draggable' && selectedElement.type !== 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, selectedElement.type === 'text' || selectedElement.type === 'button' ? 'Text' : 'URL or Upload'),
                                    selectedElement.type === 'text' || selectedElement.type === 'button' ?
                                        e('textarea', { className: 'form-textarea', value: selectedElement.content, onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }) }) :
                                        e('div', null,
                                            e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                            e('input', { 
                                                type: 'file', 
                                                className: 'form-input',
                                                accept: selectedElement.type === 'image' ? 'image/*' : 'video/*',
                                                onChange: (ev) => {
                                                    const file = ev.target.files[0];
                                                    if (file) {
                                                        const url = URL.createObjectURL(file);
                                                        updateElement(selectedElement.id, { content: url });
                                                    }
                                                }
                                            })
                                        )
                                ),
                                selectedElement.type === 'audio' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Audio URL or Upload'),
                                    e('input', { className: 'form-input', value: selectedElement.content, placeholder: 'https://...', onChange: (ev) => updateElement(selectedElement.id, { content: ev.target.value }), style: { marginBottom: '5px' } }),
                                    e('input', { 
                                        type: 'file', 
                                        className: 'form-input',
                                        accept: 'audio/*',
                                        onChange: (ev) => {
                                            const file = ev.target.files[0];
                                            if (file) {
                                                const url = URL.createObjectURL(file);
                                                updateElement(selectedElement.id, { content: url });
                                            }
                                        }
                                    })
                                ),
                                selectedElement.type === 'timer' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Countdown (seconds)'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.countdown, onChange: (ev) => updateElement(selectedElement.id, { countdown: parseInt(ev.target.value) || 10 }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Button Color'),
                                    e('input', { type: 'color', className: 'form-input', value: selectedElement.color, onChange: (ev) => updateElement(selectedElement.id, { color: ev.target.value }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text Color'),
                                    e('input', { type: 'color', className: 'form-input', value: selectedElement.buttonTextColor || '#ffffff', onChange: (ev) => updateElement(selectedElement.id, { buttonTextColor: ev.target.value }) })
                                ),
                                selectedElement.type === 'button' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Text Size'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.buttonTextSize || 20, onChange: (ev) => updateElement(selectedElement.id, { buttonTextSize: parseInt(ev.target.value) || 20 }) })
                                ),
                                selectedElement.type === 'hotspot' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Interaction Mode'),
                                    e('select', { className: 'form-select', value: selectedElement.hotspotMode || 'both', onChange: (ev) => updateElement(selectedElement.id, { hotspotMode: ev.target.value }) },
                                        e('option', { value: 'both' }, 'Click & Drop'),
                                        e('option', { value: 'click' }, 'Click Only'),
                                        e('option', { value: 'drop' }, 'Drop Only')
                                    )
                                ),
                                selectedElement.type === 'hotspot' && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '0.65rem' } },
                                        e('input', { type: 'checkbox', className: 'form-checkbox', checked: selectedElement.showInGame, onChange: (ev) => updateElement(selectedElement.id, { showInGame: ev.target.checked }) }),
                                        'Visible in Game'
                                    )
                                ),
                                e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Layer'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.layer, onChange: (ev) => updateElement(selectedElement.id, { layer: parseInt(ev.target.value) || 0 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'video' || selectedElement.type === 'text') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Duration (0=forever)'),
                                    e('input', { type: 'number', className: 'form-input', value: selectedElement.duration, onChange: (ev) => updateElement(selectedElement.id, { duration: parseFloat(ev.target.value) || 0 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'â–¶ Intro Animation'),
                                    e('select', { className: 'form-select', value: selectedElement.transition || 'none', onChange: (ev) => updateElement(selectedElement.id, { transition: ev.target.value }) },
                                        e('option', { value: 'none' }, 'None'),
                                        e('option', { value: 'fade' }, 'Fade In'),
                                        e('option', { value: 'slideLeft' }, 'Slide from Left'),
                                        e('option', { value: 'slideRight' }, 'Slide from Right'),
                                        e('option', { value: 'slideUp' }, 'Slide from Top'),
                                        e('option', { value: 'slideDown' }, 'Slide from Bottom'),
                                        e('option', { value: 'zoom' }, 'Zoom In')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && selectedElement.transition && selectedElement.transition !== 'none' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Intro Duration (sec)'),
                                    e('input', { type: 'number', step: '0.1', className: 'form-input', value: selectedElement.transitionDuration || 0.5, onChange: (ev) => updateElement(selectedElement.id, { transitionDuration: parseFloat(ev.target.value) || 0.5 }) })
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'ðŸ”„ During Animation'),
                                    e('select', { className: 'form-select', value: selectedElement.animationDuring || 'none', onChange: (ev) => updateElement(selectedElement.id, { animationDuring: ev.target.value }) },
                                        e('option', { value: 'none' }, 'None'),
                                        e('option', { value: 'pulse' }, 'Pulse'),
                                        e('option', { value: 'spin' }, 'Spin'),
                                        e('option', { value: 'bounce' }, 'Bounce'),
                                        e('option', { value: 'wobble' }, 'Wobble'),
                                        e('option', { value: 'shake' }, 'Shake'),
                                        e('option', { value: 'glow' }, 'Glow'),
                                        e('option', { value: 'float' }, 'Float')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'â—€ Outro Animation'),
                                    e('select', { className: 'form-select', value: selectedElement.transitionOut || 'none', onChange: (ev) => updateElement(selectedElement.id, { transitionOut: ev.target.value }) },
                                        e('option', { value: 'none' }, 'None (use Intro reverse)'),
                                        e('option', { value: 'fade' }, 'Fade Out'),
                                        e('option', { value: 'slideLeft' }, 'Slide to Left'),
                                        e('option', { value: 'slideRight' }, 'Slide to Right'),
                                        e('option', { value: 'slideUp' }, 'Slide to Top'),
                                        e('option', { value: 'slideDown' }, 'Slide to Bottom'),
                                        e('option', { value: 'zoom' }, 'Zoom Out')
                                    )
                                ),
                                (selectedElement.type === 'image' || selectedElement.type === 'text' || selectedElement.type === 'object') && selectedElement.transitionOut && selectedElement.transitionOut !== 'none' && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Outro Duration (sec)'),
                                    e('input', { type: 'number', step: '0.1', className: 'form-input', value: selectedElement.transitionOutDuration || 0.5, onChange: (ev) => updateElement(selectedElement.id, { transitionOutDuration: parseFloat(ev.target.value) || 0.5 }) })
                                ),
                                selectedElement.type === 'text' && e('div', null,
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Font Size'),
                                        e('input', { type: 'number', className: 'form-input', value: selectedElement.textSize || 24, onChange: (ev) => updateElement(selectedElement.id, { textSize: parseInt(ev.target.value) || 24 }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Text Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.textColor || '#ffffff', onChange: (ev) => updateElement(selectedElement.id, { textColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Background Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.textBgColor ? selectedElement.textBgColor.replace('rgba(0,0,0,0.8)', '#000000') : '#000000', onChange: (ev) => updateElement(selectedElement.id, { textBgColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Background Opacity (0-100)'),
                                        e('input', { type: 'number', min: '0', max: '100', className: 'form-input', value: selectedElement.textBgOpacity !== undefined ? Math.round(selectedElement.textBgOpacity * 100) : 80, onChange: (ev) => updateElement(selectedElement.id, { textBgOpacity: Math.max(0, Math.min(100, parseInt(ev.target.value) || 0)) / 100 }) })
                                    )
                                ),
                                (selectedElement.type === 'audio' || selectedElement.type === 'video') && e('div', { className: 'form-group' },
                                    e('label', { style: { display: 'flex', alignItems: 'center', cursor: 'pointer', fontSize: '0.65rem' } },
                                        e('input', { type: 'checkbox', className: 'form-checkbox', checked: selectedElement.loop, onChange: (ev) => updateElement(selectedElement.id, { loop: ev.target.checked }) }),
                                        'Loop'
                                    )
                                ),
                                (selectedElement.type === 'hotspot' || selectedElement.type === 'draggable') && e('div', { className: 'form-group' },
                                    e('label', { className: 'form-label' }, 'Shape'),
                                    e('select', { className: 'form-select', value: selectedElement.shape, onChange: (ev) => updateElement(selectedElement.id, { shape: ev.target.value }) },
                                        e('option', { value: 'rect' }, 'Rectangle'),
                                        e('option', { value: 'circle' }, 'Circle')
                                    )
                                ),
                                selectedElement.type === 'object' && e('div', null,
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Object Shape'),
                                        e('select', { className: 'form-select', value: selectedElement.objectShape || 'rect', onChange: (ev) => updateElement(selectedElement.id, { objectShape: ev.target.value }) },
                                            e('option', { value: 'rect' }, 'Rectangle'),
                                            e('option', { value: 'circle' }, 'Circle/Oval'),
                                            e('option', { value: 'triangle' }, 'Triangle')
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Object Color'),
                                        e('input', { type: 'color', className: 'form-input', value: selectedElement.objectColor || '#f7931a', onChange: (ev) => updateElement(selectedElement.id, { objectColor: ev.target.value }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Opacity (0-100)'),
                                        e('input', { type: 'number', min: '0', max: '100', className: 'form-input', value: selectedElement.opacity !== undefined ? selectedElement.opacity : 100, onChange: (ev) => updateElement(selectedElement.id, { opacity: Math.max(0, Math.min(100, parseInt(ev.target.value) || 0)) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Scale X (stretch)'),
                                        e('input', { type: 'range', min: '0.2', max: '3', step: '0.1', className: 'form-input', value: selectedElement.scaleX || 1, onChange: (ev) => updateElement(selectedElement.id, { scaleX: parseFloat(ev.target.value) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Scale Y (stretch)'),
                                        e('input', { type: 'range', min: '0.2', max: '3', step: '0.1', className: 'form-input', value: selectedElement.scaleY || 1, onChange: (ev) => updateElement(selectedElement.id, { scaleY: parseFloat(ev.target.value) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Rotation'),
                                        e('div', { style: { display: 'flex', gap: '3px', flexWrap: 'wrap' } },
                                            [0, 45, 90, 135, 180, 225, 270, 315].map(deg =>
                                                e('button', { 
                                                    key: deg,
                                                    className: 'btn btn-small ' + ((selectedElement.rotation || 0) === deg ? 'btn-primary' : 'btn-secondary'),
                                                    style: { padding: '3px 6px', fontSize: '0.6rem' },
                                                    onClick: () => updateElement(selectedElement.id, { rotation: deg })
                                                }, deg + 'Â°')
                                            )
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Flip'),
                                        e('div', { style: { display: 'flex', gap: '5px' } },
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipH ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipH: !selectedElement.flipH })
                                            }, 'â†” Horizontal'),
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipV ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipV: !selectedElement.flipV })
                                            }, 'â†• Vertical')
                                        )
                                    )
                                ),
                                selectedElement.type === 'image' && e('div', null,
                                    e('div', { className: 'section-title', style: { marginTop: '10px' } }, 'Transform'),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Opacity (0-100)'),
                                        e('input', { type: 'number', min: '0', max: '100', className: 'form-input', value: selectedElement.opacity !== undefined ? selectedElement.opacity : 100, onChange: (ev) => updateElement(selectedElement.id, { opacity: Math.max(0, Math.min(100, parseInt(ev.target.value) || 0)) }) })
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Rotation'),
                                        e('div', { style: { display: 'flex', gap: '3px', flexWrap: 'wrap' } },
                                            [0, 45, 90, 135, 180, 225, 270, 315].map(deg =>
                                                e('button', { 
                                                    key: deg,
                                                    className: 'btn btn-small ' + ((selectedElement.rotation || 0) === deg ? 'btn-primary' : 'btn-secondary'),
                                                    style: { padding: '3px 6px', fontSize: '0.6rem' },
                                                    onClick: () => updateElement(selectedElement.id, { rotation: deg })
                                                }, deg + 'Â°')
                                            )
                                        )
                                    ),
                                    e('div', { className: 'form-group' },
                                        e('label', { className: 'form-label' }, 'Flip'),
                                        e('div', { style: { display: 'flex', gap: '5px' } },
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipH ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipH: !selectedElement.flipH })
                                            }, 'â†” Horizontal'),
                                            e('button', { 
                                                className: 'btn btn-small ' + (selectedElement.flipV ? 'btn-primary' : 'btn-secondary'),
                                                onClick: () => updateElement(selectedElement.id, { flipV: !selectedElement.flipV })
                                            }, 'â†• Vertical')
                                        )
                                    )
                                ),
                                e('div', { style: { display: 'flex', gap: '5px', marginTop: '10px' } },
                                    e('button', { className: 'btn btn-secondary btn-small', style: { flex: 1 }, onClick: () => copyElement(selectedElement) }, 'ðŸ“‹ Copy'),
                                    e('button', { className: 'btn btn-danger btn-small', style: { flex: 1 }, onClick: () => deleteElement(selectedElement.id) }, 'ðŸ—‘ï¸ Delete')
                                )
                            ),

                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'All Elements'),
                            clipboard && e('button', { className: 'btn btn-success btn-small', style: { width: '100%', marginBottom: '5px' }, onClick: pasteElement }, 'ðŸ“‹ Paste: ' + clipboard.label),
                            e('div', { style: { maxHeight: '200px', overflowY: 'auto' } },
                                currentStep.elements.length === 0 ? 
                                    e('div', { style: { fontSize: '0.7rem', color: '#6b7280', padding: '10px', textAlign: 'center' } }, 'No elements yet') :
                                    currentStep.elements.map(el =>
                                        e('div', { 
                                            key: el.id, 
                                            className: 'element-list-item' + (selectedElementId === el.id ? ' selected' : ''),
                                            onClick: () => setSelectedElementId(el.id)
                                        },
                                            e('span', null, el.label),
                                            e('span', { className: 'element-type-badge' }, el.type)
                                        )
                                    )
                            )
                        ),

                        activeTab === 'events' && e('div', null,
                            e('div', { className: 'info-box' }, 'Events trigger actions. Drag â‰¡ to reorder. Events run top-to-bottom.'),
                            currentStep.events.map((event, idx) =>
                                e('div', { 
                                    key: event.id, 
                                    className: 'event-item' + (draggedEventId === event.id ? ' drag-over' : ''),
                                    onDragOver: (ev) => handleEventDragOver(ev, event.id),
                                    onDrop: (ev) => handleEventDrop(ev, event.id)
                                },
                                    e('div', { 
                                        className: 'event-header',
                                        onClick: () => toggleEventCollapse(event.id)
                                    },
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                                            e('span', { 
                                                className: 'event-drag-handle',
                                                draggable: true,
                                                onDragStart: (ev) => handleEventDragStart(ev, event.id),
                                                onDragEnd: handleEventDragEnd,
                                                onClick: (ev) => ev.stopPropagation()
                                            }, 'â‰¡'),
                                            e('span', { style: { fontSize: '0.7rem', fontWeight: 600, color: '#f7931a' } }, 'Event ' + (idx + 1)),
                                            e('span', { style: { fontSize: '0.6rem', color: '#9ca3af' } }, ' - ' + event.trigger.type)
                                        ),
                                        e('div', { style: { display: 'flex', alignItems: 'center', gap: '5px' } },
                                            e('span', { className: 'collapsible-arrow' + (collapsedEvents[event.id] ? '' : ' open') }, 'â–¶'),
                                            e('button', { 
                                                className: 'btn btn-danger btn-small', 
                                                onClick: (ev) => { ev.stopPropagation(); deleteEvent(event.id); },
                                                style: { padding: '2px 6px' }
                                            }, 'Ã—')
                                        )
                                    ),
                                    e('div', { className: 'collapsible-content' + (!collapsedEvents[event.id] ? ' open' : '') },
                                        e('div', { style: { display: 'flex', justifyContent: 'space-between', marginBottom: '5px', marginTop: '5px' } },
                                            e('select', { className: 'form-select', style: { flex: 1, marginRight: '4px', fontSize: '0.6rem' }, value: event.trigger.type, onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, type: ev.target.value } }) },
                                                e('option', { value: 'onLoad' }, 'On Load'),
                                                e('option', { value: 'afterDelay' }, 'After Delay'),
                                                e('option', { value: 'afterElement' }, 'After Element'),
                                                e('option', { value: 'onClick' }, 'On Click'),
                                                e('option', { value: 'onDrop' }, 'On Drop')
                                            )
                                        ),
                                        event.trigger.type === 'afterDelay' && e('input', { type: 'number', className: 'form-input', placeholder: 'Seconds', value: event.trigger.delay || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, delay: parseFloat(ev.target.value) || 0 } }), style: { marginBottom: '5px' } }),
                                        event.trigger.type === 'afterElement' && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                            e('option', { value: '' }, '-- Select Element --'),
                                            currentStep.elements.map(el => e('option', { key: el.id, value: el.id }, el.label))
                                        ),
                                        (event.trigger.type === 'onClick' || event.trigger.type === 'onDrop') && e('select', { className: 'form-select', value: event.trigger.sourceElement || '', onChange: (ev) => updateEvent(event.id, { trigger: { ...event.trigger, sourceElement: ev.target.value } }), style: { marginBottom: '5px' } },
                                            e('option', { value: '' }, event.trigger.type === 'onClick' ? '-- Click Target --' : '-- Drop Zone --'),
                                            currentStep.elements.filter(el => el.type === 'button' || el.type === 'hotspot').map(el => e('option', { key: el.id, value: el.id }, el.label))
                                        ),
                                        
                                        event.condition && e('div', { className: 'condition-box' },
                                            e('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '3px' } },
                                                e('span', { style: { fontSize: '0.6rem', fontWeight: 700 } }, 'CONDITION'),
                                                e('button', { className: 'btn btn-danger btn-small', onClick: () => updateEvent(event.id, { condition: null }) }, 'Ã—')
                                            ),
                                            e('select', { className: 'form-select', value: event.condition.type, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, type: ev.target.value } }), style: { marginBottom: '3px', fontSize: '0.6rem' } },
                                                e('option', { value: 'hasItem' }, 'Has Item'),
                                                e('option', { value: 'notHasItem' }, 'Does NOT Have Item'),
                                                e('option', { value: 'varyingAtLeast' }, 'ðŸ“Š Has At Least'),
                                                e('option', { value: 'varyingAtMost' }, 'ðŸ“Š Has At Most'),
                                            e('option', { value: 'varyingBetween' }, 'ðŸ“Š Has Between')
                                        ),
                                        (event.condition.type === 'hasItem' || event.condition.type === 'notHasItem') ?
                                            e('select', { className: 'form-select', value: event.condition.item, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, item: ev.target.value } }) },
                                                e('option', { value: '' }, '-- Item --'),
                                                inventory.map(item => e('option', { key: item.name || item, value: item.name || item }, item.name || item))
                                            ) :
                                        (event.condition.type === 'varyingAtLeast' || event.condition.type === 'varyingAtMost') ?
                                            e('div', null,
                                                e('select', { className: 'form-select', value: event.condition.item, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, item: ev.target.value } }), style: { marginBottom: '3px' } },
                                                    e('option', { value: '' }, '-- Varying Item --'),
                                                    varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                ),
                                                e('input', { type: 'number', className: 'form-input', placeholder: 'Amount', value: event.condition.amount || 0, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, amount: parseFloat(ev.target.value) || 0 } }) })
                                            ) :
                                        event.condition.type === 'varyingBetween' ?
                                            e('div', null,
                                                e('select', { className: 'form-select', value: event.condition.item, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, item: ev.target.value } }), style: { marginBottom: '3px' } },
                                                    e('option', { value: '' }, '-- Varying Item --'),
                                                    varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                ),
                                                e('div', { style: { display: 'flex', gap: '5px' } },
                                                    e('input', { type: 'number', className: 'form-input', placeholder: 'Min', value: event.condition.min || 0, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, min: parseFloat(ev.target.value) || 0 } }) }),
                                                    e('input', { type: 'number', className: 'form-input', placeholder: 'Max', value: event.condition.max || 0, onChange: (ev) => updateEvent(event.id, { condition: { ...event.condition, max: parseFloat(ev.target.value) || 0 } }) })
                                                )
                                            ) : null
                                    ),
                                    !event.condition && e('button', { className: 'btn btn-secondary btn-small', style: { width: '100%', marginBottom: '5px' }, onClick: () => updateEvent(event.id, { condition: { type: 'hasItem', item: '' } }) }, '+ Add Condition'),
                                    
                                    event.actions.map(action =>
                                        e('div', { key: action.id, className: 'action-item' },
                                            e('select', { className: 'form-select', value: action.type, onChange: (ev) => updateEventAction(event.id, action.id, { type: ev.target.value }), style: { marginBottom: '3px', fontSize: '0.6rem' } },
                                                e('option', { value: 'show' }, 'Show'),
                                                e('option', { value: 'hide' }, 'Hide'),
                                                e('option', { value: 'showDelay' }, 'Show (Delayed)'),
                                                e('option', { value: 'hideDelay' }, 'Hide (Delayed)'),
                                                e('option', { value: 'goto' }, 'Go To Step'),
                                                e('option', { value: 'addItem' }, 'Add Inventory'),
                                                e('option', { value: 'removeItem' }, 'Remove Inventory'),
                                                e('option', { value: 'addVarying' }, 'ðŸ“Š Add to Varying'),
                                                e('option', { value: 'subtractVarying' }, 'ðŸ“Š Subtract from Varying')
                                            ),
                                            action.type === 'goto' ?
                                                e('div', null,
                                                    e('div', { style: { fontSize: '0.6rem', color: '#f7931a', marginBottom: '3px' } }, 'Select one or more (random if multiple):'),
                                                    steps.map(s =>
                                                        e('label', { key: s.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', marginBottom: '2px', cursor: 'pointer' } },
                                                            e('input', { 
                                                                type: 'checkbox', 
                                                                className: 'form-checkbox',
                                                                checked: action.targets ? action.targets.includes(s.id) : action.target === s.id,
                                                                onChange: (ev) => {
                                                                    if (ev.target.checked) {
                                                                        const newTargets = action.targets ? [...action.targets, s.id] : [action.target, s.id].filter(Boolean);
                                                                        updateEventAction(event.id, action.id, { targets: newTargets, target: '' });
                                                                    } else {
                                                                        const newTargets = action.targets ? action.targets.filter(t => t !== s.id) : [];
                                                                        updateEventAction(event.id, action.id, { targets: newTargets.length > 0 ? newTargets : undefined, target: newTargets.length === 0 ? '' : action.target });
                                                                    }
                                                                }
                                                            }),
                                                            s.title
                                                        )
                                                    )
                                                ) :
                                            action.type === 'addItem' || action.type === 'removeItem' ?
                                                e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Item --'),
                                                    inventory.map(item => e('option', { key: item.name || item, value: item.name || item }, item.name || item))
                                                ) :
                                            action.type === 'addVarying' || action.type === 'subtractVarying' ?
                                                e('div', null,
                                                    e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }), style: { marginBottom: '5px' } },
                                                        e('option', { value: '' }, '-- Varying Item --'),
                                                        varyingItems.map(item => e('option', { key: item.name, value: item.name }, item.name))
                                                    ),
                                                    e('div', { className: 'form-group', style: { marginBottom: '0' } },
                                                        e('label', { className: 'form-label' }, 'Amount'),
                                                        e('input', { type: 'number', className: 'form-input', value: action.amount || 0, onChange: (ev) => updateEventAction(event.id, action.id, { amount: parseFloat(ev.target.value) || 0 }) })
                                                    )
                                                ) :
                                            (action.type === 'show' || action.type === 'hide' || action.type === 'showDelay' || action.type === 'hideDelay') ?
                                                e('div', null,
                                                    (action.type === 'showDelay' || action.type === 'hideDelay') && e('div', { className: 'form-group', style: { marginBottom: '5px' } },
                                                        e('label', { className: 'form-label' }, 'Delay (seconds)'),
                                                        e('input', { type: 'number', step: '0.1', className: 'form-input', value: action.delay || 0, onChange: (ev) => updateEventAction(event.id, action.id, { delay: parseFloat(ev.target.value) || 0 }) })
                                                    ),
                                                    e('div', { 
                                                        className: 'collapsible-header', 
                                                        onClick: () => toggleActionCollapse(event.id + '_' + action.id)
                                                    },
                                                        e('span', { style: { fontSize: '0.6rem', color: '#10b981' } }, 
                                                            'Elements (' + (action.targets ? action.targets.length : (action.target ? 1 : 0)) + ' selected)'
                                                        ),
                                                        e('span', { className: 'collapsible-arrow' + (collapsedActions[event.id + '_' + action.id] === false || collapsedActions[event.id + '_' + action.id] === undefined ? '' : ' open') }, 'â–¶')
                                                    ),
                                                    e('div', { className: 'collapsible-content' + (collapsedActions[event.id + '_' + action.id] ? ' open' : '') },
                                                        currentStep.elements.map(el =>
                                                            e('label', { key: el.id, style: { display: 'flex', alignItems: 'center', fontSize: '0.65rem', marginBottom: '2px', cursor: 'pointer' } },
                                                                e('input', { 
                                                                    type: 'checkbox', 
                                                                    className: 'form-checkbox',
                                                                    checked: action.targets ? action.targets.includes(el.id) : action.target === el.id,
                                                                    onChange: (ev) => {
                                                                        if (ev.target.checked) {
                                                                            const newTargets = action.targets ? [...action.targets, el.id] : [action.target, el.id].filter(Boolean);
                                                                            updateEventAction(event.id, action.id, { targets: newTargets, target: '' });
                                                                        } else {
                                                                            const newTargets = action.targets ? action.targets.filter(t => t !== el.id) : [];
                                                                            updateEventAction(event.id, action.id, { targets: newTargets.length > 0 ? newTargets : undefined, target: newTargets.length === 0 ? '' : action.target });
                                                                        }
                                                                    }
                                                                }),
                                                                el.label
                                                            )
                                                        )
                                                    )
                                                ) :
                                                e('select', { className: 'form-select', value: action.target, onChange: (ev) => updateEventAction(event.id, action.id, { target: ev.target.value }) },
                                                    e('option', { value: '' }, '-- Element --'),
                                                    currentStep.elements.map(el => e('option', { key: el.id, value: el.id }, el.label))
                                                ),
                                            e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteEventAction(event.id, action.id), style: { marginTop: '3px', width: '100%' } }, 'Remove')
                                        )
                                    ),
                                    e('button', { className: 'add-btn btn-add-action', onClick: () => addEventAction(event.id) }, '+ Action')
                                    )
                                )
                            ),
                            e('button', { className: 'add-btn btn-add-event', onClick: addEvent }, '+ Event')
                        ),

                        activeTab === 'inventory' && e('div', null,
                            e('div', { className: 'info-box' }, 'Global inventory items. Visible items show at bottom-left in game.'),
                            inventory.map(item =>
                                e('div', { key: item.name || item, style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '5px', background: '#1a1f3a', marginBottom: '4px', borderRadius: '4px' } },
                                    e('span', { style: { fontSize: '0.75rem', flex: 1 } }, item.name || item),
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', marginRight: '8px', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: typeof item === 'string' ? true : item.visible,
                                            onChange: (ev) => {
                                                if (typeof item === 'string') {
                                                    setInventory(inventory.map(i => i === item ? { name: item, visible: ev.target.checked } : i));
                                                } else {
                                                    setInventory(inventory.map(i => i.name === item.name ? { ...i, visible: ev.target.checked } : i));
                                                }
                                            }
                                        }),
                                        'Visible'
                                    ),
                                    e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteInventoryItem(item) }, 'Ã—')
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: addInventoryItem }, '+ Item'),

                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Varying Items'),
                            e('div', { className: 'info-box' }, 'Items with numeric values (money, points, etc). Use actions to add/subtract.'),
                            varyingItems.map(item =>
                                e('div', { key: item.name, style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '5px', background: '#1a1f3a', marginBottom: '4px', borderRadius: '4px', border: '1px solid #f59e0b' } },
                                    e('span', { style: { fontSize: '0.75rem', flex: 1, color: '#f59e0b' } }, 'ðŸ“Š ' + item.name),
                                    e('label', { style: { display: 'flex', alignItems: 'center', fontSize: '0.6rem', marginRight: '8px', cursor: 'pointer' } },
                                        e('input', { 
                                            type: 'checkbox', 
                                            className: 'form-checkbox',
                                            checked: item.visible,
                                            onChange: (ev) => {
                                                setVaryingItems(varyingItems.map(i => i.name === item.name ? { ...i, visible: ev.target.checked } : i));
                                            }
                                        }),
                                        'Visible'
                                    ),
                                    e('button', { className: 'btn btn-danger btn-small', onClick: () => deleteVaryingItem(item) }, 'Ã—')
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: addVaryingItem }, '+ Varying Item')
                        ),

                        activeTab === 'settings' && e('div', null,
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Background Color'),
                                e('input', { type: 'color', className: 'form-input', value: currentStep.bgColor || '#000000', onChange: (ev) => updateStep({ bgColor: ev.target.value }) })
                            ),
                            e('div', { className: 'section-title' }, 'Background Shapes'),
                            currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                                e('div', { key: shape.id, style: { background: '#1a1f3a', padding: '8px', marginBottom: '5px', borderRadius: '4px' } },
                                    e('div', { style: { display: 'flex', gap: '5px', marginBottom: '5px' } },
                                        e('select', { className: 'form-select', style: { flex: 1 }, value: shape.type, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, type: ev.target.value } : s) }) },
                                            e('option', { value: 'rect' }, 'Rectangle'),
                                            e('option', { value: 'circle' }, 'Circle')
                                        ),
                                        e('input', { type: 'color', className: 'form-input', style: { width: '60px' }, value: shape.color, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, color: ev.target.value } : s) }) }),
                                        e('button', { className: 'btn btn-danger btn-small', onClick: () => updateStep({ bgShapes: currentStep.bgShapes.filter(s => s.id !== shape.id) }) }, 'Ã—')
                                    ),
                                    e('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px', fontSize: '0.6rem' } },
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'X', value: shape.x, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, x: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Y', value: shape.y, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, y: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Width', value: shape.width, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, width: parseInt(ev.target.value) || 0 } : s) }) }),
                                        e('input', { type: 'number', className: 'form-input', placeholder: 'Height', value: shape.height, onChange: (ev) => updateStep({ bgShapes: currentStep.bgShapes.map(s => s.id === shape.id ? { ...s, height: parseInt(ev.target.value) || 0 } : s) }) })
                                    )
                                )
                            ),
                            e('button', { className: 'add-btn', onClick: () => updateStep({ bgShapes: [...(currentStep.bgShapes || []), { id: 'shape_' + Date.now(), type: 'rect', color: '#ffffff', x: 100, y: 100, width: 200, height: 200 }] }) }, '+ Shape'),
                            e('div', { className: 'section-title', style: { marginTop: '15px' } }, 'Password'),
                            e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Password Lock'),
                                e('input', { className: 'form-input', value: currentStep.password, placeholder: 'Optional', onChange: (ev) => updateStep({ password: ev.target.value }) })
                            ),
                            currentStep.password && e('div', { className: 'form-group' },
                                e('label', { className: 'form-label' }, 'Wrong Password â†’ Go To'),
                                e('select', { className: 'form-select', value: currentStep.wrongPasswordStep, onChange: (ev) => updateStep({ wrongPasswordStep: ev.target.value }) },
                                    e('option', { value: '' }, '-- Exit Game --'),
                                    steps.map(s => e('option', { key: s.id, value: s.id }, s.title))
                                )
                            ),
                            e('div', { className: 'info-box' }, 'Background shapes appear behind all elements')
                        )
                    ) : e('div', { className: 'info-box' }, 'â† Create a step')
                )
            );
        }

        function PlayMode({ steps, inventory, varyingItems, onExit, startStepId }) {
            const [currentStepId, setCurrentStepId] = useState(startStepId || steps[0]?.id);
            const [visibleElements, setVisibleElements] = useState({});
            const [playerInventory, setPlayerInventory] = useState([]);
            const [playerVaryingValues, setPlayerVaryingValues] = useState({});
            const [activeTimers, setActiveTimers] = useState({});
            const [eventTimers, setEventTimers] = useState([]);
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
            const [hidingElements, setHidingElements] = useState({});

            const currentStep = steps.find(s => s.id === currentStepId);

            useEffect(() => {
                eventTimers.forEach(timer => clearTimeout(timer));
                setEventTimers([]);
                setActiveTimers({});  // Clear all active timers when step changes
                setHidingElements({}); // Clear hiding state
                
                if (!currentStep) return;

                if (currentStep.password) {
                    const pwd = prompt('Enter password:');
                    if (pwd !== currentStep.password) {
                        if (currentStep.wrongPasswordStep) {
                            setCurrentStepId(currentStep.wrongPasswordStep);
                        } else {
                            alert('Wrong password!');
                            onExit();
                        }
                        return;
                    }
                }

                const visible = {};
                const newTimers = [];
                currentStep.elements.forEach(elem => {
                    visible[elem.id] = elem.visible;
                    // Set duration timers for elements with duration > 0
                    if (elem.visible && elem.duration && elem.duration > 0) {
                        const timer = setTimeout(() => {
                            setVisibleElements(prev => ({ ...prev, [elem.id]: false }));
                        }, elem.duration * 1000);
                        newTimers.push(timer);
                    }
                });
                setVisibleElements(visible);
                
                // Process onLoad and afterDelay events
                currentStep.events.forEach(event => {
                    if (checkCondition(event.condition)) {
                        if (event.trigger.type === 'onLoad') {
                            processActions(event.actions);
                        } else if (event.trigger.type === 'afterDelay') {
                            const timer = setTimeout(() => processActions(event.actions), (event.trigger.delay || 0) * 1000);
                            newTimers.push(timer);
                        }
                    }
                });
                
                // Start timers AFTER onLoad events (so hidden timers don't start)
                setTimeout(() => {
                    const currentVisibility = visibleElements;
                    currentStep.elements.forEach(elem => {
                        if (elem.type === 'timer' && currentVisibility[elem.id] !== false && visible[elem.id]) {
                            let remaining = elem.countdown;
                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                            const interval = setInterval(() => {
                                remaining--;
                                setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                if (remaining <= 0) {
                                    clearInterval(interval);
                                    currentStep.events.forEach(event => {
                                        if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                            if (checkCondition(event.condition)) {
                                                processActions(event.actions);
                                            }
                                        }
                                    });
                                }
                            }, 1000);
                            newTimers.push(interval);
                        }
                    });
                    setEventTimers(newTimers);
                }, 100);
                
                setEventTimers(newTimers);

                return () => {
                    newTimers.forEach(timer => clearTimeout(timer));
                };
            }, [currentStepId]);

            const checkCondition = (condition) => {
                if (!condition) return true;
                if (condition.type === 'hasItem') {
                    return playerInventory.includes(condition.item);
                } else if (condition.type === 'notHasItem') {
                    return !playerInventory.includes(condition.item);
                } else if (condition.type === 'varyingAtLeast') {
                    return (playerVaryingValues[condition.item] || 0) >= (condition.amount || 0);
                } else if (condition.type === 'varyingAtMost') {
                    return (playerVaryingValues[condition.item] || 0) <= (condition.amount || 0);
                } else if (condition.type === 'varyingBetween') {
                    const val = playerVaryingValues[condition.item] || 0;
                    return val >= (condition.min || 0) && val <= (condition.max || 0);
                }
                return true;
            };

            const processActions = (actions) => {
                actions.forEach(action => {
                    if (action.type === 'show' || action.type === 'showDelay') {
                        const showAction = () => {
                            if (action.targets && action.targets.length > 0) {
                                action.targets.forEach(targetId => {
                                    setVisibleElements(prev => ({ ...prev, [targetId]: true }));
                                    const elem = currentStep.elements.find(e => e.id === targetId);
                                    if (elem) {
                                        // Start timer if it's a timer element
                                        if (elem.type === 'timer') {
                                            let remaining = elem.countdown;
                                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                            const interval = setInterval(() => {
                                                remaining--;
                                                setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                                if (remaining <= 0) {
                                                    clearInterval(interval);
                                                    currentStep.events.forEach(event => {
                                                        if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                                            if (checkCondition(event.condition)) {
                                                                processActions(event.actions);
                                                            }
                                                        }
                                                    });
                                                }
                                            }, 1000);
                                            setEventTimers(prev => [...prev, interval]);
                                        }
                                        // Handle duration
                                        if (elem.duration && elem.duration > 0) {
                                            const timer = setTimeout(() => {
                                                setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                            }, elem.duration * 1000);
                                            setEventTimers(prev => [...prev, timer]);
                                        }
                                    }
                                });
                            } else if (action.target) {
                                setVisibleElements(prev => ({ ...prev, [action.target]: true }));
                                const elem = currentStep.elements.find(e => e.id === action.target);
                                if (elem) {
                                    // Start timer if it's a timer element
                                    if (elem.type === 'timer') {
                                        let remaining = elem.countdown;
                                        setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                        const interval = setInterval(() => {
                                            remaining--;
                                            setActiveTimers(prev => ({ ...prev, [elem.id]: remaining }));
                                            if (remaining <= 0) {
                                                clearInterval(interval);
                                                currentStep.events.forEach(event => {
                                                    if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                                                        if (checkCondition(event.condition)) {
                                                            processActions(event.actions);
                                                        }
                                                    }
                                                });
                                            }
                                        }, 1000);
                                        setEventTimers(prev => [...prev, interval]);
                                    }
                                    // Handle duration
                                    if (elem.duration && elem.duration > 0) {
                                        const timer = setTimeout(() => {
                                            setVisibleElements(prev => ({ ...prev, [action.target]: false }));
                                        }, elem.duration * 1000);
                                        setEventTimers(prev => [...prev, timer]);
                                    }
                                }
                            }
                        };
                        if (action.type === 'showDelay' && action.delay) {
                            const timer = setTimeout(showAction, action.delay * 1000);
                            setEventTimers(prev => [...prev, timer]);
                        } else {
                            showAction();
                        }
                    } else if (action.type === 'hide' || action.type === 'hideDelay') {
                        const hideAction = () => {
                            const elementsToHide = action.targets && action.targets.length > 0 ? action.targets : [action.target];
                            elementsToHide.forEach(targetId => {
                                if (!targetId) return;
                                const elem = currentStep.elements.find(e => e.id === targetId);
                                const outTrans = elem?.transitionOut && elem.transitionOut !== 'none' ? elem.transitionOut : elem?.transition;
                                const outDur = elem?.transitionOut && elem.transitionOut !== 'none' ? (elem.transitionOutDuration || 0.5) : (elem?.transitionDuration || 0.5);
                                if (outTrans && outTrans !== 'none') {
                                    // Mark as hiding to show out-transition
                                    setHidingElements(prev => ({ ...prev, [targetId]: true }));
                                    // Actually hide after transition duration
                                    const duration = outDur * 1000;
                                    const timer = setTimeout(() => {
                                        setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                        setHidingElements(prev => ({ ...prev, [targetId]: false }));
                                    }, duration);
                                    setEventTimers(prev => [...prev, timer]);
                                } else {
                                    // No transition, hide immediately
                                    setVisibleElements(prev => ({ ...prev, [targetId]: false }));
                                }
                            });
                        };
                        if (action.type === 'hideDelay' && action.delay) {
                            const timer = setTimeout(hideAction, action.delay * 1000);
                            setEventTimers(prev => [...prev, timer]);
                        } else {
                            hideAction();
                        }
                    } else if (action.type === 'goto') {
                        if (action.targets && action.targets.length > 0) {
                            // Random selection from multiple steps
                            const randomStep = action.targets[Math.floor(Math.random() * action.targets.length)];
                            setCurrentStepId(randomStep);
                        } else if (action.target) {
                            setCurrentStepId(action.target);
                        }
                    } else if (action.type === 'addItem') {
                        setPlayerInventory(prev => prev.includes(action.target) ? prev : [...prev, action.target]);
                    } else if (action.type === 'removeItem') {
                        setPlayerInventory(prev => prev.filter(item => item !== action.target));
                    } else if (action.type === 'addVarying') {
                        setPlayerVaryingValues(prev => ({ ...prev, [action.target]: (prev[action.target] || 0) + (action.amount || 0) }));
                    } else if (action.type === 'subtractVarying') {
                        setPlayerVaryingValues(prev => ({ ...prev, [action.target]: (prev[action.target] || 0) - (action.amount || 0) }));
                    }
                });
            };

            const handleVideoEnd = (elem) => {
                if (!currentStep) return;
                currentStep.events.forEach(event => {
                    if (event.trigger.type === 'afterElement' && event.trigger.sourceElement === elem.id) {
                        if (checkCondition(event.condition)) {
                            processActions(event.actions);
                        }
                    }
                });
            };

            const handleClick = (elem) => {
                if (!currentStep) return;
                if (elem.type === 'hotspot' && (elem.hotspotMode === 'drop')) return;
                
                currentStep.events.forEach(event => {
                    if (event.trigger.type === 'onClick' && event.trigger.sourceElement === elem.id) {
                        if (checkCondition(event.condition)) {
                            processActions(event.actions);
                        }
                    }
                });
            };

            const handleDragStart = (ev, elem) => {
                ev.preventDefault();
                const rect = ev.currentTarget.getBoundingClientRect();
                const canvas = document.querySelector('.play-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                setDragOffset({
                    x: ev.clientX - rect.left,
                    y: ev.clientY - rect.top
                });
                setDraggedItem(elem);
                setDragPos({ x: ev.clientX - canvasRect.left, y: ev.clientY - canvasRect.top });
            };

            const handleDragMove = (ev) => {
                if (!draggedItem) return;
                ev.preventDefault();
                const canvas = document.querySelector('.play-canvas');
                const rect = canvas.getBoundingClientRect();
                setDragPos({ x: ev.clientX - rect.left, y: ev.clientY - rect.top });
            };

            const handleDragEnd = (ev) => {
                if (!draggedItem) return;
                
                const canvas = document.querySelector('.play-canvas');
                const rect = canvas.getBoundingClientRect();
                const dropX = ev.clientX - rect.left;
                const dropY = ev.clientY - rect.top;

                currentStep.elements.filter(e => e.type === 'hotspot' && visibleElements[e.id] && (e.hotspotMode !== 'click')).forEach(hotspot => {
                    if (dropX >= hotspot.x && dropX <= hotspot.x + hotspot.width && 
                        dropY >= hotspot.y && dropY <= hotspot.y + hotspot.height) {
                        currentStep.events.forEach(event => {
                            if (event.trigger.type === 'onDrop' && event.trigger.sourceElement === hotspot.id) {
                                if (checkCondition(event.condition)) {
                                    processActions(event.actions);
                                }
                            }
                        });
                    }
                });

                setDraggedItem(null);
            };

            useEffect(() => {
                if (draggedItem) {
                    document.addEventListener('mousemove', handleDragMove);
                    document.addEventListener('mouseup', handleDragEnd);
                    return () => {
                        document.removeEventListener('mousemove', handleDragMove);
                        document.removeEventListener('mouseup', handleDragEnd);
                    };
                }
            }, [draggedItem]);

            if (!currentStep) {
                return e('div', { className: 'play-overlay' },
                    e('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', color: '#fff', fontSize: '1.5rem' } }, 'Story ended')
                );
            }

            return e('div', { className: 'play-overlay' },
                e('button', { className: 'btn btn-danger play-exit', onClick: onExit }, 'âœ• Exit'),
                e('div', { className: 'play-canvas', style: { background: currentStep.bgColor || '#000' } },
                    currentStep.bgShapes && currentStep.bgShapes.map(shape =>
                        e('div', {
                            key: shape.id,
                            style: {
                                position: 'absolute',
                                left: shape.x + 'px',
                                top: shape.y + 'px',
                                width: shape.width + 'px',
                                height: shape.height + 'px',
                                background: shape.color,
                                borderRadius: shape.type === 'circle' ? '50%' : '0',
                                zIndex: 0
                            }
                        })
                    ),
                    currentStep.elements
                        .filter(elem => visibleElements[elem.id] || hidingElements[elem.id])
                        .sort((a, b) => a.layer - b.layer)
                        .map(elem => {
                            const isHiding = hidingElements[elem.id];
                            const outTrans = elem.transitionOut && elem.transitionOut !== 'none' ? elem.transitionOut : elem.transition;
                            const transClass = isHiding ? 
                                (outTrans && outTrans !== 'none' ? 'trans-' + outTrans + '-out' : '') :
                                (elem.transition && elem.transition !== 'none' ? 'trans-' + elem.transition : '');
                            const duringClass = !isHiding && elem.animationDuring && elem.animationDuring !== 'none' ? 'anim-' + elem.animationDuring : '';
                            const transDur = isHiding ? (elem.transitionOutDuration || elem.transitionDuration || 0.5) : (elem.transitionDuration || 0.5);
                            return e('div', {
                                key: elem.id,
                                className: (transClass + ' ' + duringClass).trim(),
                                onMouseDown: elem.type === 'draggable' ? (ev) => handleDragStart(ev, elem) : undefined,
                                style: {
                                    position: 'absolute',
                                    left: (draggedItem?.id === elem.id ? dragPos.x - dragOffset.x : elem.x) + 'px',
                                    top: (draggedItem?.id === elem.id ? dragPos.y - dragOffset.y : elem.y) + 'px',
                                    width: elem.width + 'px',
                                    height: elem.height + 'px',
                                    zIndex: draggedItem?.id === elem.id ? 9999 : elem.layer,
                                    cursor: elem.type === 'draggable' ? (draggedItem?.id === elem.id ? 'grabbing' : 'grab') : (elem.type === 'button' || (elem.type === 'hotspot' && elem.hotspotMode !== 'drop')) ? 'pointer' : 'default',
                                    borderRadius: elem.shape === 'circle' ? '50%' : '0',
                                    opacity: draggedItem?.id === elem.id ? 0.7 : 1,
                                    animationDuration: transDur + 's'
                                },
                                onClick: () => handleClick(elem)
                            },
                                elem.type === 'image' && elem.content && e('img', { src: elem.content, style: { width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none', transform: 'scale(' + (elem.flipH ? -1 : 1) + ', ' + (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)', opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100 } }),
                                elem.type === 'video' && elem.content && e('video', { 
                                    src: elem.content, 
                                    autoPlay: elem.autoplay, 
                                    loop: elem.loop, 
                                    playsInline: true, 
                                    onEnded: () => !elem.loop && handleVideoEnd(elem),
                                    style: { width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none' } 
                                }),
                                elem.type === 'text' && e('div', { 
                                    className: 'element-text', 
                                    style: { 
                                        fontSize: (elem.textSize || 24) + 'px',
                                        color: elem.textColor || '#ffffff',
                                        background: elem.textBgColor ? 
                                            (elem.textBgColor.startsWith('#') ? 
                                                elem.textBgColor + Math.round((elem.textBgOpacity || 0.8) * 255).toString(16).padStart(2, '0') : 
                                                elem.textBgColor) : 
                                            'rgba(0,0,0,0.8)'
                                    } 
                                }, elem.content),
                                elem.type === 'button' && e('div', { className: 'element-button', style: { background: elem.color, color: elem.buttonTextColor || '#ffffff', fontSize: (elem.buttonTextSize || 20) + 'px' } }, elem.content || 'Button'),
                                elem.type === 'audio' && elem.content && e('audio', { src: elem.content, autoPlay: elem.autoplay, loop: elem.loop, onEnded: () => !elem.loop && handleVideoEnd(elem) }),
                                elem.type === 'timer' && e('div', { className: 'element-timer' }, activeTimers[elem.id] !== undefined ? activeTimers[elem.id] : elem.countdown),
                                elem.type === 'draggable' && (
                                    elem.contentType === 'image' && elem.content ? 
                                        e('img', { src: elem.content, style: { width: '100%', height: '100%', objectFit: 'contain', pointerEvents: 'none' } }) :
                                        e('div', { style: { fontSize: elem.fontSize + 'px', display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', pointerEvents: 'none' } }, elem.content || 'ðŸ“¦')
                                ),
                                elem.type === 'hotspot' && elem.showInGame && e('div', { style: { width: '100%', height: '100%', border: '3px dashed rgba(255,0,0,0.5)', background: 'rgba(255,0,0,0.05)' } }),
                                elem.type === 'object' && e('div', { 
                                    style: { 
                                        width: '100%', 
                                        height: '100%', 
                                        background: elem.objectColor || elem.color || '#f7931a',
                                        borderRadius: elem.objectShape === 'circle' ? '50%' : '0',
                                        clipPath: elem.objectShape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none',
                                        transform: 'scale(' + (elem.scaleX || 1) * (elem.flipH ? -1 : 1) + ', ' + (elem.scaleY || 1) * (elem.flipV ? -1 : 1) + ') rotate(' + (elem.rotation || 0) + 'deg)',
                                        opacity: (elem.opacity !== undefined ? elem.opacity : 100) / 100
                                    }
                                })
                            );
                        })
                ),
                playerInventory.filter(itemName => {
                    const invItem = inventory.find(i => (i.name || i) === itemName);
                    return !invItem || (typeof invItem === 'string') || invItem.visible;
                }).length > 0 && e('div', { className: 'inventory-display' },
                    playerInventory.filter(itemName => {
                        const invItem = inventory.find(i => (i.name || i) === itemName);
                        return !invItem || (typeof invItem === 'string') || invItem.visible;
                    }).map(item => e('div', { key: item, className: 'inventory-item-icon' }, item[0]))
                ),
                // Varying items display
                varyingItems && varyingItems.filter(vi => vi.visible).length > 0 && e('div', { 
                    className: 'varying-display',
                    style: {
                        position: 'fixed',
                        top: '20px',
                        left: '20px',
                        background: 'rgba(0,0,0,0.8)',
                        padding: '10px',
                        borderRadius: '8px',
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '5px',
                        zIndex: 100
                    }
                },
                    varyingItems.filter(vi => vi.visible).map(vi => 
                        e('div', { 
                            key: vi.name, 
                            style: { 
                                display: 'flex', 
                                alignItems: 'center', 
                                gap: '8px',
                                color: '#f59e0b',
                                fontSize: '14px',
                                fontWeight: 'bold'
                            } 
                        },
                            e('span', { style: { color: '#fff' } }, vi.name + ':'),
                            e('span', null, playerVaryingValues[vi.name] || 0)
                        )
                    )
                )
            );
        }

        function generateHTML(steps, inventory, varyingItems) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Story</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; }
        .canvas { width: 1024px; height: 576px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .elem { position: absolute; }
        .elem img, .elem video { width: 100%; height: 100%; object-fit: cover; }
        .elem video { pointer-events: none; }
        .elem video::-webkit-media-controls { display: none !important; }
        .elem video::-webkit-media-controls-enclosure { display: none !important; }
        .elem-text { padding: 15px; border-radius: 6px; text-align: center; white-space: pre-wrap; }
        .elem-button { padding: 15px 30px; border-radius: 6px; font-weight: 700; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .elem-timer { background: rgba(247,147,26,0.8); color: #fff; font-size: 3rem; font-weight: 900; display: flex; align-items: center; justify-content: center; border-radius: 8px; font-family: monospace; }
        .elem-draggable { cursor: grab; display: flex; align-items: center; justify-content: center; user-select: none; touch-action: none; }
        .elem-draggable:active { cursor: grabbing; }
        .elem-draggable img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        .elem-hotspot-visible { border: 3px dashed rgba(255,0,0,0.5); background: rgba(255,0,0,0.05); }
        .inventory-display { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; display: flex; gap: 10px; }
        .trans-fade { animation: fadeIn 0.5s ease-in forwards; }
        .trans-fade-out { animation: fadeOut 0.5s ease-out forwards; }
        .trans-slideLeft { animation: slideLeft 0.5s ease-out forwards; }
        .trans-slideLeft-out { animation: slideLeftOut 0.5s ease-in forwards; }
        .trans-slideRight { animation: slideRight 0.5s ease-out forwards; }
        .trans-slideRight-out { animation: slideRightOut 0.5s ease-in forwards; }
        .trans-slideUp { animation: slideUp 0.5s ease-out forwards; }
        .trans-slideUp-out { animation: slideUpOut 0.5s ease-in forwards; }
        .trans-slideDown { animation: slideDown 0.5s ease-out forwards; }
        .trans-slideDown-out { animation: slideDownOut 0.5s ease-in forwards; }
        .trans-zoom { animation: zoomIn 0.5s ease-out forwards; }
        .trans-zoom-out { animation: zoomOut 0.5s ease-in forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideLeftOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slideRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideRightOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes slideUp { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideUpOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-100%); opacity: 0; } }
        @keyframes slideDown { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideDownOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(100%); opacity: 0; } }
        @keyframes zoomIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes zoomOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0); opacity: 0; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes wobble { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); } 20%, 40%, 60%, 80% { transform: translateX(2px); } }
        @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        .anim-pulse { animation: pulse 1s ease-in-out infinite; }
        .anim-spin { animation: spin 2s linear infinite; }
        .anim-bounce { animation: bounce 0.5s ease-in-out infinite; }
        .anim-wobble { animation: wobble 0.5s ease-in-out infinite; }
        .anim-shake { animation: shake 0.5s ease-in-out infinite; }
        .anim-glow { animation: glow 1.5s ease-in-out infinite; }
        .anim-float { animation: float 2s ease-in-out infinite; }
        .elem-object { display: flex; align-items: center; justify-content: center; }
    </style>
</head>
<body>
    <div id="game" class="canvas"></div>
    <div id="inventory" class="inventory-display" style="display:none"></div>
    <div id="varying" style="position:fixed;top:20px;left:20px;background:rgba(0,0,0,0.8);padding:10px;border-radius:8px;display:none;flex-direction:column;gap:5px;z-index:100"></div>
    <script>
// Story data - properly formatted with indentation for readability
const STORY_DATA = ${JSON.stringify({ steps, inventoryItems: inventory, varyingItems: varyingItems || [] }, null, 2)};

const STEPS = STORY_DATA.steps;
const INVENTORY_ITEMS = STORY_DATA.inventoryItems;
const VARYING_ITEMS = STORY_DATA.varyingItems;

let current = STEPS[0].id;
let visible = {};
let inventory = [];
let varyingValues = {};
let timers = [];
let timerCountdowns = {};
let hiding = {};
let rendered = {};
let draggedElem = null;
let dragOffset = { x: 0, y: 0 };
let dragPos = { x: 0, y: 0 };

function render() {
    timers.forEach(t => clearTimeout(t));
    timers = [];
    timerCountdowns = {};
    hiding = {};
    rendered = {};
    draggedElem = null;
    
    const s = STEPS.find(x => x.id === current);
    if (!s) return;
    
    if (s.password) {
        const pwd = prompt("Password:");
        if (pwd !== s.password) {
            if (s.wrongPasswordStep) { current = s.wrongPasswordStep; render(); return; }
            else { alert("Wrong!"); return; }
        }
    }
    
    visible = {};
    s.elements.forEach(e => {
        visible[e.id] = e.visible;
        if (e.visible && e.duration && e.duration > 0) {
            const t = setTimeout(() => hideElem(e.id), e.duration * 1000);
            timers.push(t);
        }
        if (e.type === "timer" && e.visible) startTimer(e.id, e.countdown);
    });
    
    s.events.forEach(ev => {
        if (checkCond(ev.condition)) {
            if (ev.trigger.type === "onLoad") exec(ev.actions);
            else if (ev.trigger.type === "afterDelay") {
                const t = setTimeout(() => exec(ev.actions), (ev.trigger.delay || 0) * 1000);
                timers.push(t);
            }
        }
    });
    
    fullDraw();
}

function startTimer(id, countdown) {
    let rem = countdown;
    timerCountdowns[id] = rem;
    const int = setInterval(() => {
        rem--;
        timerCountdowns[id] = rem;
        const timerDiv = document.querySelector('[data-elem-id="' + id + '"] .elem-timer');
        if (timerDiv) timerDiv.textContent = rem;
        if (rem <= 0) {
            clearInterval(int);
            const s = STEPS.find(x => x.id === current);
            s.events.forEach(ev => {
                if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    }, 1000);
    timers.push(int);
}

function hideElem(id) {
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    const elemDiv = document.querySelector('[data-elem-id="' + id + '"]');
    
    if (!elemDiv) {
        visible[id] = false;
        delete rendered[id];
        return;
    }
    
    const audio = elemDiv.querySelector('audio');
    const video = elemDiv.querySelector('video');
    if (audio) { audio.pause(); audio.currentTime = 0; }
    if (video) { video.pause(); video.currentTime = 0; }
    
    const outTrans = elem && elem.transitionOut && elem.transitionOut !== "none" ? elem.transitionOut : (elem ? elem.transition : "none");
    const outDur = elem && elem.transitionOut && elem.transitionOut !== "none" ? (elem.transitionOutDuration || 0.5) : (elem ? (elem.transitionDuration || 0.5) : 0.5);
    
    if (outTrans && outTrans !== "none") {
        hiding[id] = true;
        elemDiv.className = elemDiv.className.replace(/\\btrans-[\\w-]+\\b/g, '').replace(/\\banim-[\\w-]+\\b/g, '').trim() + ' trans-' + outTrans + '-out';
        elemDiv.style.animationDuration = outDur + 's';
        setTimeout(() => {
            visible[id] = false;
            hiding[id] = false;
            delete rendered[id];
            if (elemDiv.parentNode) elemDiv.remove();
        }, outDur * 1000);
    } else {
        visible[id] = false;
        delete rendered[id];
        elemDiv.remove();
    }
}

function showElem(id) {
    if (visible[id] && rendered[id]) return;
    visible[id] = true;
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === id);
    if (elem) {
        if (elem.type === "timer") startTimer(id, elem.countdown);
        if (elem.duration && elem.duration > 0) {
            const t = setTimeout(() => hideElem(id), elem.duration * 1000);
            timers.push(t);
        }
        addElement(elem, true);
    }
}

function checkCond(c) {
    if (!c) return true;
    if (c.type === "hasItem") return inventory.includes(c.item);
    if (c.type === "notHasItem") return !inventory.includes(c.item);
    if (c.type === "varyingAtLeast") return (varyingValues[c.item] || 0) >= (c.amount || 0);
    if (c.type === "varyingAtMost") return (varyingValues[c.item] || 0) <= (c.amount || 0);
    if (c.type === "varyingBetween") return (varyingValues[c.item] || 0) >= (c.min || 0) && (varyingValues[c.item] || 0) <= (c.max || 0);
    return true;
}

function exec(acts) {
    acts.forEach(a => {
        if (a.type === "show" || a.type === "showDelay") {
            const delay = (a.type === "showDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => showElem(t), delay); });
        } else if (a.type === "hide" || a.type === "hideDelay") {
            const delay = (a.type === "hideDelay" && a.delay) ? a.delay * 1000 : 0;
            const targets = a.targets && a.targets.length > 0 ? a.targets : [a.target];
            targets.forEach(t => { if (t) setTimeout(() => hideElem(t), delay); });
        } else if (a.type === "goto") {
            if (a.targets && a.targets.length > 0) current = a.targets[Math.floor(Math.random() * a.targets.length)];
            else if (a.target) current = a.target;
            render();
            return;
        } else if (a.type === "addItem" && !inventory.includes(a.target)) inventory.push(a.target);
        else if (a.type === "removeItem") inventory = inventory.filter(x => x !== a.target);
        else if (a.type === "addVarying") varyingValues[a.target] = (varyingValues[a.target] || 0) + (a.amount || 0);
        else if (a.type === "subtractVarying") varyingValues[a.target] = (varyingValues[a.target] || 0) - (a.amount || 0);
    });
    updateInventory();
}

function hexToRgba(hex, opacity) {
    if (!hex || hex.startsWith('rgba')) return hex || 'rgba(0,0,0,' + opacity + ')';
    hex = hex.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
}

function createElemHTML(e, withTransition) {
    const isHiding = hiding[e.id];
    const outTrans = e.transitionOut && e.transitionOut !== "none" ? e.transitionOut : e.transition;
    const transClass = withTransition && e.transition && e.transition !== "none" && !isHiding ? " trans-" + e.transition : (isHiding && outTrans && outTrans !== "none" ? " trans-" + outTrans + "-out" : "");
    const duringClass = e.animationDuring && e.animationDuring !== "none" && !isHiding ? " anim-" + e.animationDuring : "";
    const transDur = isHiding ? (e.transitionOutDuration || e.transitionDuration || 0.5) : (e.transitionDuration || 0.5);
    const flipScaleX = e.flipH ? -1 : 1;
    const flipScaleY = e.flipV ? -1 : 1;
    const rotation = e.rotation || 0;
    const objectOpacity = (e.opacity !== undefined ? e.opacity : 100) / 100;
    const objectStyle = e.type === "object" ? ";background:" + (e.objectColor || e.color || "#f7931a") + (e.objectShape === "circle" ? ";border-radius:50%" : "") + (e.objectShape === "triangle" ? ";clip-path:polygon(50% 0%, 0% 100%, 100% 100%)" : "") + ";transform:scale(" + ((e.scaleX || 1) * flipScaleX) + "," + ((e.scaleY || 1) * flipScaleY) + ") rotate(" + rotation + "deg);opacity:" + objectOpacity : "";
    const style = "left:" + e.x + "px;top:" + e.y + "px;width:" + e.width + "px;height:" + e.height + "px;z-index:" + e.layer + (e.shape === "circle" ? ";border-radius:50%" : "") + ";animation-duration:" + transDur + "s" + objectStyle;
    const mousedown = e.type === "draggable" ? ' onmousedown="handleDragStart(event, \\'' + e.id + '\\')" ontouchstart="handleDragStart(event, \\'' + e.id + '\\')"' : "";
    const click = (e.type === "button" || (e.type === "hotspot" && e.hotspotMode !== "drop")) ? ' onclick="handleClick(\\'' + e.id + '\\')"' : "";
    const hotspotClass = (e.type === "hotspot" && e.showInGame) ? " elem-hotspot-visible" : "";
    const objectClass = e.type === "object" ? " elem-object" : "";
    const imgTransform = (e.flipH || e.flipV || rotation) ? "transform:scale(" + flipScaleX + "," + flipScaleY + ") rotate(" + rotation + "deg);" : "";
    
    let h = '<div class="elem' + (e.type === "draggable" ? " elem-draggable" : "") + hotspotClass + objectClass + transClass + duringClass + '" data-elem-id="' + e.id + '" style="' + style + '"' + mousedown + click + '>';
    if (e.type === "image" && e.content) h += '<img src="' + e.content + '" style="' + imgTransform + 'opacity:' + ((e.opacity !== undefined ? e.opacity : 100) / 100) + ';">';
    if (e.type === "video" && e.content) h += '<video playsinline webkit-playsinline ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop ' : '') + 'onended="handleVideoEnd(\\'' + e.id + '\\')" data-video-id="' + e.id + '"><source src="' + e.content + '"></video>';
    if (e.type === "text") {
        const bgOpacity = e.textBgOpacity !== undefined ? e.textBgOpacity : 0.8;
        const bgColor = hexToRgba(e.textBgColor || '#000000', bgOpacity);
        h += '<div class="elem-text" style="font-size:' + (e.textSize || 24) + 'px;color:' + (e.textColor || "#ffffff") + ';background:' + bgColor + '">' + e.content + '</div>';
    }
    if (e.type === "button") h += '<div class="elem-button" style="background:' + e.color + ';color:' + (e.buttonTextColor || '#ffffff') + ';font-size:' + (e.buttonTextSize || 20) + 'px">' + (e.content || "Button") + '</div>';
    if (e.type === "audio" && e.content) h += '<audio ' + (e.autoplay ? 'autoplay ' : '') + (e.loop ? 'loop ' : '') + 'onended="handleVideoEnd(\\'' + e.id + '\\')"><source src="' + e.content + '"></audio>';
    if (e.type === "timer") h += '<div class="elem-timer">' + (timerCountdowns[e.id] !== undefined ? timerCountdowns[e.id] : e.countdown) + '</div>';
    if (e.type === "draggable") {
        if (e.contentType === "image" && e.content) h += '<img src="' + e.content + '">';
        else h += '<div style="font-size:' + e.fontSize + 'px;color:#fff;pointer-events:none">' + (e.content || "ðŸ“¦") + '</div>';
    }
    if (e.type === "object") h += '';
    h += '</div>';
    return h;
}

function addElement(e, withTransition) {
    if (!e || rendered[e.id]) return;
    const game = document.getElementById("game");
    const s = STEPS.find(x => x.id === current);
    const temp = document.createElement('div');
    temp.innerHTML = createElemHTML(e, withTransition);
    const newElem = temp.firstChild;
    
    const existingElems = Array.from(game.querySelectorAll('[data-elem-id]'));
    let inserted = false;
    for (const existing of existingElems) {
        const existingE = s.elements.find(el => el.id === existing.getAttribute('data-elem-id'));
        if (existingE && existingE.layer > e.layer) {
            game.insertBefore(newElem, existing);
            inserted = true;
            break;
        }
    }
    if (!inserted) game.appendChild(newElem);
    rendered[e.id] = true;
}

function fullDraw() {
    const s = STEPS.find(x => x.id === current);
    const game = document.getElementById("game");
    game.style.background = s.bgColor || "#000";
    let h = "";
    
    if (s.bgShapes) {
        s.bgShapes.forEach(sh => {
            h += '<div style="position:absolute;left:' + sh.x + 'px;top:' + sh.y + 'px;width:' + sh.width + 'px;height:' + sh.height + 'px;background:' + sh.color + ';border-radius:' + (sh.type === "circle" ? "50%" : "0") + ';z-index:0"></div>';
        });
    }
    
    s.elements.filter(e => visible[e.id] || hiding[e.id]).sort((a, b) => a.layer - b.layer).forEach(e => {
        h += createElemHTML(e, true);
        rendered[e.id] = true;
    });
    
    game.innerHTML = h;
    updateInventory();
}

function updateInventory() {
    const inv = document.getElementById("inventory");
    const visInv = inventory.filter(item => {
        const invItem = INVENTORY_ITEMS.find(i => (i.name || i) === item);
        return !invItem || (typeof invItem === "string") || invItem.visible;
    });
    if (visInv.length > 0) {
        inv.style.display = "flex";
        inv.innerHTML = visInv.map(x => '<div style="width:40px;height:40px;background:#f7931a;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px">' + x[0] + '</div>').join("");
    } else {
        inv.style.display = "none";
    }
    updateVarying();
}

function updateVarying() {
    const vd = document.getElementById("varying");
    const visVarying = VARYING_ITEMS.filter(vi => vi.visible);
    if (visVarying.length > 0) {
        vd.style.display = "flex";
        vd.innerHTML = visVarying.map(vi => 
            '<div style="display:flex;align-items:center;gap:8px;color:#f59e0b;font-size:14px;font-weight:bold">' +
            '<span style="color:#fff">' + vi.name + ':</span>' +
            '<span>' + (varyingValues[vi.name] || 0) + '</span>' +
            '</div>'
        ).join("");
    } else {
        vd.style.display = "none";
    }
}

function getEventPos(ev) {
    if (ev.touches && ev.touches.length > 0) {
        return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
    }
    if (ev.changedTouches && ev.changedTouches.length > 0) {
        return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY };
    }
    return { x: ev.clientX, y: ev.clientY };
}

function handleDragStart(ev, elemId) {
    ev.preventDefault();
    const s = STEPS.find(x => x.id === current);
    const elem = s.elements.find(e => e.id === elemId);
    if (!elem) return;
    draggedElem = elem;
    const rect = ev.target.getBoundingClientRect();
    const canvas = document.getElementById("game");
    const canvasRect = canvas.getBoundingClientRect();
    const pos = getEventPos(ev);
    dragOffset.x = pos.x - rect.left;
    dragOffset.y = pos.y - rect.top;
    dragPos.x = pos.x - canvasRect.left;
    dragPos.y = pos.y - canvasRect.top;
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('touchend', handleDragEnd);
}

function handleDragMove(ev) {
    if (!draggedElem) return;
    ev.preventDefault();
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    const pos = getEventPos(ev);
    dragPos.x = pos.x - rect.left;
    dragPos.y = pos.y - rect.top;
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = (dragPos.x - dragOffset.x) + 'px';
        draggedDiv.style.top = (dragPos.y - dragOffset.y) + 'px';
    }
}

function handleDragEnd(ev) {
    if (!draggedElem) return;
    const s = STEPS.find(x => x.id === current);
    const canvas = document.getElementById("game");
    const rect = canvas.getBoundingClientRect();
    const pos = getEventPos(ev);
    const dropX = pos.x - rect.left;
    const dropY = pos.y - rect.top;
    s.elements.filter(e => e.type === "hotspot" && visible[e.id] && e.hotspotMode !== "click").forEach(h => {
        if (dropX >= h.x && dropX <= h.x + h.width && dropY >= h.y && dropY <= h.y + h.height) {
            s.events.forEach(ev => {
                if (ev.trigger.type === "onDrop" && ev.trigger.sourceElement === h.id && checkCond(ev.condition)) exec(ev.actions);
            });
        }
    });
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    document.removeEventListener('touchmove', handleDragMove);
    document.removeEventListener('touchend', handleDragEnd);
    const draggedDiv = document.querySelector('[data-elem-id="' + draggedElem.id + '"]');
    if (draggedDiv) {
        draggedDiv.style.left = draggedElem.x + 'px';
        draggedDiv.style.top = draggedElem.y + 'px';
    }
    draggedElem = null;
}

function handleVideoEnd(id) {
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "afterElement" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
    });
}

function handleClick(id) {
    const s = STEPS.find(x => x.id === current);
    s.events.forEach(ev => {
        if (ev.trigger.type === "onClick" && ev.trigger.sourceElement === id && checkCond(ev.condition)) exec(ev.actions);
    });
}

render();
    <\/script>
</body>
</html>`;
        }

        ReactDOM.render(React.createElement(StoryBuilder), document.getElementById('root'));
    </script>
</body>
</html>
